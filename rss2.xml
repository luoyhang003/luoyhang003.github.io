<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>远航</title>
    <link>http://blog.luoyuanhang.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Aim high.</description>
    <pubDate>Thu, 25 Jul 2019 03:32:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>fibos-vote-intro</title>
      <link>http://blog.luoyuanhang.com/2019/07/25/fibos-vote-intro/</link>
      <guid>http://blog.luoyuanhang.com/2019/07/25/fibos-vote-intro/</guid>
      <pubDate>Thu, 25 Jul 2019 03:30:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;FIBOS 的链上治理很重要的一个操作就是&lt;strong&gt;投票&lt;/strong&gt;，在 FIBOS 中是存在两种投票操作的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户进行投票选出超级节点；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超级节点进行投票通过/反对提案&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>FIBOS 的链上治理很重要的一个操作就是<strong>投票</strong>，在 FIBOS 中是存在两种投票操作的：</p><ul><li><strong>用户进行投票选出超级节点；</strong></li><li><strong>超级节点进行投票通过/反对提案</strong></li></ul><a id="more"></a><h2 id="用户投票"><a href="#用户投票" class="headerlink" title="用户投票"></a>用户投票</h2><p>用户执行投票可以选出超级节点，对于 FIBOS 主链来说，排名在前 21 的超级节点需要承担生产区块的责任，并且能够得到生产区块的奖励。</p><p>用户投票的具体过程如下：</p><ol><li>用户抵押治理币获取 CPU、NET 资源</li><li>用户执行投票操作，使用 CPU、NET 资源进行投票</li></ol><p>说明：</p><ol><li>一个治理币所抵押的 CPU、NET 资源在投票之后表示一票</li><li>用户的每一票最多可以投给 30 个超级节点，最少需要投给 1 个节点（如果投给 0 个节点则表示撤票）（这几个参数可以修改智能合约来配置）</li><li>用户的票权不可分割，不能一部分票投给 A 另一部分投给 B，一旦执行投票表示所有票权都将投给选择的超级节点</li><li>执行撤票操作（即投票给 0 个节点）会将用户投给所有超级节点的票权撤销，不允许部分撤票</li><li>超级节点的排名由每个超级节点得到的总票数排序而来，用户执行投票后，排名前 21 的超级节点可以得到生产区块权，排名在后边的节点作为候选节点，在用户投票导致排名上升后可以获得生产区块权</li><li>超级节点的排名更新周期为 1 分钟，如果未发生用户投票行为或投票为导致排名变化则不更新</li></ol><p><strong>举例：</strong></p><blockquote><p>假设 A 用户拥有 1000 FO，他抵押 200 FO 获取 CPU 资源以及抵押 100 FO 获取 NET 资源，也就意味着 A 当前拥有 300 票。A 用户可以给超级节点 BP1，BP2 进行投票（一次操作就可以给多个超级节点投票），则 BP1，BP2 各获得 300 票。如果此时 A 用户再次执行投票，给 BP3，BP4 进行投票，则相当于自动执行了给 BP1，BP2 的撤票，并且给 BP3，BP4 各投了 300 票。</p></blockquote><h2 id="超级节点投票"><a href="#超级节点投票" class="headerlink" title="超级节点投票"></a>超级节点投票</h2><p>超级节点在 FIBOS 网络中承担着十分重要的社区治理的作用，更新系统合约等重要操作则需要提起多签提案，由超级节点投票通过后，才允许被执行。</p><p>这一过程主要由以下操作构成：</p><ul><li>提案者提出多签提案（所有账户都可以提出提案）</li><li>超级节点对多签提案进行投票（FIBOS 主链只有排名前 21 的超级节点具有权限，这一参数可以修改智能合约来配置）</li><li>提案者对获取到 2/3 以上超级节点支持的提案进行执行</li></ul><p>说明：</p><ol><li>超级节点对于提案的投票，每一个超级节点能够投出一票</li><li>整个网络可以同时拥有多个提案</li><li>提案在未被执行之前可以由提案者进行撤销</li><li>提出提案需要消耗提案者的 RAM，提案被执行或者被撤销后占用的 RAM 会被释放</li></ol><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2019/07/25/fibos-vote-intro/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FIBOS 链上资源模型介绍</title>
      <link>http://blog.luoyuanhang.com/2019/07/25/FIBOS%20%E8%B6%85%E7%BA%A7%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE%E4%BB%A5%E5%8F%8A%E6%8F%90%E6%A1%88%E5%A4%9A%E7%AD%BE%E4%BB%8B%E7%BB%8D/</link>
      <guid>http://blog.luoyuanhang.com/2019/07/25/FIBOS%20%E8%B6%85%E7%BA%A7%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE%E4%BB%A5%E5%8F%8A%E6%8F%90%E6%A1%88%E5%A4%9A%E7%AD%BE%E4%BB%8B%E7%BB%8D/</guid>
      <pubDate>Thu, 25 Jul 2019 03:25:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;FIBOS 链上的资源的获取是通过链上的治理币来完成的（对于 FIBOS 主链来说是 FO），其模型分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抵押型（CPU、NET）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消耗型（RAM）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>FIBOS 链上的资源的获取是通过链上的治理币来完成的（对于 FIBOS 主链来说是 FO），其模型分为两种：</p><ul><li><strong>抵押型（CPU、NET）</strong></li><li><strong>消耗型（RAM）</strong></li></ul><a id="more"></a><h2 id="抵押型资源（CPU、NET）"><a href="#抵押型资源（CPU、NET）" class="headerlink" title="抵押型资源（CPU、NET）"></a>抵押型资源（CPU、NET）</h2><p>在 FIBOS 中抵押型资源有两种：</p><ul><li>CPU：表示消耗的链上的计算资源，单位是毫秒（ms）</li><li>NET：表示消耗的链上的网络带宽，单位是 KB</li></ul><p><strong>抵押型的资源需要用户在链上使用治理币来抵押才能获取资源</strong>，进行抵押后的治理币不可进行转账等操作，只有经过解抵押操作治理币才能进行正常转账，而解抵押的周期为 3 天。当然，如果进行解抵押操作，也就意味着释放了使用之前已抵押资源的权利。抵押型的资源可以自己给自己抵押，也可以给他人抵押。</p><p><strong>链上的哪些操作需要抵押型的资源呢？</strong></p><p>广义上来讲，在 FIBOS 链上进行的所有操作都需要消耗抵押型资源：调用智能合约，代币转账，创建新账户，包括抵押资源本身等等。所有与链上合约的交互都需要消耗抵押型资源。</p><p><strong>抵押型的资源会不会消耗完？</strong></p><p>既然是称其为『资源』就说明它是会消耗完的。但是不同于消耗型的资源，抵押型资源的『消耗』只是表示的是在一个时间段内资源被消耗完全。</p><p>举个简单的例子：</p><blockquote><p>某用户 A 抵押了 2.0000 FO 的 CPU 以及 1.0000 FO 的 NET 资源，假设他抵押的这些资源足够进行 5 笔转账，在今天下午 16:00，A 执行了 5 笔转账消耗完了自己的抵押型资源。也就意味着再进行第 6 笔转账会失败。但是在 24 小时之后，A 『消耗』之后的资源会得到恢复，A又可以继续进行转账了。</p></blockquote><p>当然，链上真正的抵押型资源的抵押和消耗要比上述例子要复杂一些。一个账户所拥有的抵押型资源能够真正允许他在链上执行多少操作并不是一个固定的值，这个是和全网的资源总抵押量和整个网络的拥堵程度是有关的。假设一个账户所拥有的 CPU、NET 资源是固定的，如果全网的总抵押量越高，他能执行的操作也就越少，网络越拥堵（单位时间内链上交易的多少）他能执行的操作也越少。</p><p>回到上边的例子，也就意味着：</p><blockquote><p>A 所拥有的 2.0000 FO 的 CPU 以及 1.0000 FO 的 NET 资源，满足他在今天下午 16:00 执行 5 笔操作，即便他什么操作也没有执行，也有可能这些资源在 18:00 的时候能够满足他执行 3 笔 或者 10 笔转账操作，而这具体取决于链的当前情况。</p></blockquote><p><strong>如果抵押型的资源全部消耗完了呢？</strong></p><p>如果在单位时间内的抵押型资源消耗完成，可以等待到下一个资源使用周期（24小时），之前消耗的资源达到恢复周期，从而继续使用已恢复的资源；</p><p>也可以继续使用治理币来进行抵押来换取资源。</p><h2 id="消耗型资源（RAM）"><a href="#消耗型资源（RAM）" class="headerlink" title="消耗型资源（RAM）"></a>消耗型资源（RAM）</h2><p>RAM 属于 FIBOS 链上的消耗型资源，主要用于链上的存储消耗。某账户使用了链上的智能合约存储空间就需要消耗该账户所拥有的 RAM。</p><p><strong>RAM 该如何获得？</strong></p><p>在 FIBOS 链上，RAM 是需要使用治理币来进行购买的。FIBOS 的系统合约有一个基于 Bancor 算法的交易市场，用户可以使用治理币进行 RAM 的购买和卖出。用户可以给自己购买 RAM，也可以给其他账户购买 RAM。</p><p><strong>哪些场景会消耗 RAM？</strong></p><ul><li>某用户给未持有该币种用户的转账：例如 A 用户给 B 用户转账 FO 代币，而 B 用户并未持有 FO，则该笔转账会消耗 A 用户的 RAM。原因是在于，链上所有的持币信息是存储于智能合约的，当前链上并没有 B 用户的持币记录，A 给 B 转账需要使用合约存储来保存这一持币记录，因此需要消耗 RAM。但是，A 如果再给 B 转账就不再会消耗 RAM了，因为 B 已经拥有这部分存储，至于这部分存储存的是 100 FO 还是 10000 FO 并不会占用多余的存储；</li><li>多签提案：发起多签提案需要消耗提案者的 RAM；</li><li>调用需要占用存储的非系统智能合约；</li><li>创建新账户；</li><li>……</li></ul><p><strong>RAM 可以被释放吗？</strong></p><p>RAM 是可以被释放的。例如，发起多签者的多签被执行之后，或者被否决之后，该提案将不再占用智能合约的存储空间，对应的 RAM 会得到释放。该账户可以将未被使用的 RAM 在 RAM 交易市场中卖出以换回治理币。</p><h2 id="FIBOS-的新账户创建"><a href="#FIBOS-的新账户创建" class="headerlink" title="FIBOS 的新账户创建"></a>FIBOS 的新账户创建</h2><p>FIBOS 的账户机制不同于比特币或者以太坊的地址，FIBOS 新账户的创建是依赖于 FIBOS 的旧账户的。也就是说，FIBOS 中每一个新账户的创建都是由已存在的账户来操作的。</p><p>已存在的旧账户需要给新创建的账户购买 RAM，抵押 CPU 和 NET 才能保证新账户能够正常进行各种链上操作。</p><p>FIBOS 的账户只能被创建，不能被销毁。</p><h2 id="FIBOS-的超级节点投票机制"><a href="#FIBOS-的超级节点投票机制" class="headerlink" title="FIBOS 的超级节点投票机制"></a>FIBOS 的超级节点投票机制</h2><p>FIBOS 中的超级节点（BP）是整个链上非常重要的角色，承载着区块产生，升级系统合约等责任。在 FIBOS 网络中，只有排名前 21 的超级节点具有生产区块的权利和义务，其余排名靠后的节点作为候选节点，排名上升后也会开始生产区块，生产区块是能够获得治理币的奖励的。</p><p>而超级节点的排名是由治理币的持币用户投票来决定的，而投票的票权是由用户所抵押的 CPU 和 NET 决定的。也就意味着，一个用户所抵押获得的 CPU、NET资源越多，它的票权就越大。超级节点可以获得各个用户的投票，根据总票权来决定自己在全部超级节点中的排名。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2019/07/25/FIBOS%20%E8%B6%85%E7%BA%A7%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE%E4%BB%A5%E5%8F%8A%E6%8F%90%E6%A1%88%E5%A4%9A%E7%AD%BE%E4%BB%8B%E7%BB%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>以太坊智能合约开发 - 环境搭建</title>
      <link>http://blog.luoyuanhang.com/2018/07/10/starting-on-ethereum-smart-contract-env/</link>
      <guid>http://blog.luoyuanhang.com/2018/07/10/starting-on-ethereum-smart-contract-env/</guid>
      <pubDate>Tue, 10 Jul 2018 13:44:57 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;在区块链的世界中，比特币被称为区块链1.0，以太坊进化为区块链2.0，这一跨越的实现缘于以太坊对智能合约的实现。智能合约在以太坊网络中扮演着至关重要的角色，目前ERC20代币的发行、多重签名乃至DApp的开发等都需要通过智能合约来进行实现等，因此学习智能合约的开发是很重要的。这篇文章会详细阐述该如何进行以太坊合约开发环境的搭建，以及编写第一个以太坊上的智能合约。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>在区块链的世界中，比特币被称为区块链1.0，以太坊进化为区块链2.0，这一跨越的实现缘于以太坊对智能合约的实现。智能合约在以太坊网络中扮演着至关重要的角色，目前ERC20代币的发行、多重签名乃至DApp的开发等都需要通过智能合约来进行实现等，因此学习智能合约的开发是很重要的。这篇文章会详细阐述该如何进行以太坊合约开发环境的搭建，以及编写第一个以太坊上的智能合约。</p></blockquote><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>进行以太坊智能合约的开发需要我们有一个以太坊网络的环境，我建议使用自己搭建的私链进行测试，在自己的私链上，以太币的获取比较容易，对于以太坊私链的的搭建可以参考我的另一篇博文<a href="http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/">《【Ethereum基础实践】：以太坊测试私链的搭建》</a>。</p><h1 id="Remix的使用"><a href="#Remix的使用" class="headerlink" title="Remix的使用"></a>Remix的使用</h1><p>Remix是以太坊官方推荐使用的IDE，在Remix上我们可以进行合约的编写，并且还可以对以太坊环境进行集成，进行智能合约的部署与调试。</p><p>Remix有Web版本和Electron APP两个版本：</p><ul><li>Web：<a href="http://remix.ethereum.org/" target="_blank" rel="noopener">http://remix.ethereum.org/</a></li><li>Electron APP：<a href="https://github.com/horizon-games/remix-app" target="_blank" rel="noopener">https://github.com/horizon-games/remix-app</a></li></ul><p>你可以选择Web版或者Electron版本，它们的功能没有任何差别。</p><p><img src="http://wx2.sinaimg.cn/large/4858d6a8gy1ft4rcqp1zhj21hc0u0doq.jpg" alt=""></p><h2 id="安装Remixd服务"><a href="#安装Remixd服务" class="headerlink" title="安装Remixd服务"></a>安装Remixd服务</h2><p>由于Remix提供的是一个在线的Web环境，因此在本地不会存储你所编写的智能合约源文件，如果你希望文件能一直保存在本地，你可以安装Remixd服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g remixd</span><br></pre></td></tr></table></figure><p>启动remixd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用绝对路径</span></span><br><span class="line">remixd -s /Users/username/path_you_store_contracts</span><br></pre></td></tr></table></figure><p>点击Remix IDE左上方按钮连接至remixd服务：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4ri7sob7j205e03ha9z.jpg" alt=""></p><p>这样就可以在本地编写智能合约了：</p><p><img src="http://wx2.sinaimg.cn/large/4858d6a8gy1ft4rsnerayj205v04xt8q.jpg" alt=""></p><h2 id="连接到以太坊节点"><a href="#连接到以太坊节点" class="headerlink" title="连接到以太坊节点"></a>连接到以太坊节点</h2><p>在Remix IDE中，我们可以连接我们自己的以太坊节点进行测试，在控制面板的<code>Run</code>页面中可以配置自定义的以太坊节点，在<code>Environment</code>中选择<code>Web3 Provider</code>:</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4t29qttbj20aw0da0tt.jpg" alt=""></p><p>输入节点对应的IP地址和RPC端口即可进行连接：</p><p><img src="http://wx1.sinaimg.cn/large/4858d6a8gy1ft4t3wel8tj20qq043q30.jpg" alt=""></p><p>在连接节点之后，我们可以看到私链中的各个账户的余额等信息：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4thr2vetj20ak04j74k.jpg" alt=""></p><p>这样我们就可以使用自己的以太坊私链进行智能合约的部署与测试了。</p><h1 id="一个简单的智能合约"><a href="#一个简单的智能合约" class="headerlink" title="一个简单的智能合约"></a>一个简单的智能合约</h1><p>接下来我们会编写和部署一个简单的智能合约来演示一下整个流程。</p><p>先来看一下合约的源文件代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">uint8 _initial</span>) </span>&#123;</span><br><span class="line">        number = _initial;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        number = number +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约的功能是在合约中存储了一个数字<code>number</code>，并且提供了一个对该数字进行+1的方法<code>add()</code>.</p><p>我们先对源代码进行编译：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4tl0v372j20b706rjrz.jpg" alt=""></p><p>之后在<code>Run</code>面板点击<code>Create</code>进行部署：</p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8gy1ft4unsg1irj20ao0cf3zd.jpg" alt=""></p><p>由于该合约的构造方法中需要一个参数，来对<code>number</code>进行初始化，这里我填的是<code>10</code>，另外，在<code>Account</code>中需要选择部署该合约的账户（需要消耗gas），并且输入对应的密码对账户进行解锁：</p><p><img src="http://wx2.sinaimg.cn/large/4858d6a8gy1ft4unnccb3j20qm043dg1.jpg" alt=""></p><p>待创建合约的交易广播至矿工节点并且被打包至区块中之后，我们就可以在面板中看到相关的合约信息了：</p><p><img src="http://wx1.sinaimg.cn/large/4858d6a8gy1ft4unil8f0j20ac03y3yi.jpg" alt=""></p><p>点击<code>number</code>可以查看当前的值：</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8gy1ft4uu5cqj9j20ad03xjrf.jpg" alt=""></p><p>点击<code>add</code>可以触发对应方法（该操作是一个transaction，需要消耗gas），<code>number</code>的值会进行+1：</p><p><img src="http://wx3.sinaimg.cn/large/4858d6a8gy1ft4uuapmdmj20ac040gln.jpg" alt=""></p><p>我们在控制台中可以看到该交易的详细信息：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4unck0pdj210108ft9x.jpg" alt=""></p><p>至此，我们就完成了一个简单的智能合约的部署。</p><h1 id="部署一个ERC20的合约"><a href="#部署一个ERC20的合约" class="headerlink" title="部署一个ERC20的合约"></a>部署一个ERC20的合约</h1><p>在这部分，我们会以以太坊上的EOS代币合约为例，进行ERC20代币的合约部署与测试。</p><p>首先，我们要获取EOS智能合约的源代码，可以在etherscan上获取对应源码：</p><p><a href="https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code" target="_blank" rel="noopener">https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line">contract DSNote &#123;</span><br><span class="line">    event LogNote(</span><br><span class="line">        bytes4   indexed  sig,</span><br><span class="line">        address  indexed  guy,</span><br><span class="line">        bytes32  indexed  foo,</span><br><span class="line">        bytes32  indexed  bar,</span><br><span class="line">uint   wad,</span><br><span class="line">        bytes             fax</span><br><span class="line">    ) anonymous;</span><br><span class="line"></span><br><span class="line">    modifier note &#123;</span><br><span class="line">        bytes32 foo;</span><br><span class="line">        bytes32 bar;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            foo := calldataload(<span class="number">4</span>)</span><br><span class="line">            bar := calldataload(<span class="number">36</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);</span><br><span class="line"></span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSAuthority &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">canCall</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address src, address dst, bytes4 sig</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">DSAuthEvents</span> </span>&#123;</span><br><span class="line">    event LogSetAuthority (address indexed authority);</span><br><span class="line">    event LogSetOwner     (address indexed owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSAuth is DSAuthEvents &#123;</span><br><span class="line">    DSAuthority  public  authority;</span><br><span class="line">    address      public  owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DSAuth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        LogSetOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setOwner</span>(<span class="params">address owner_</span>)</span></span><br><span class="line"><span class="function">        <span class="title">auth</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        owner = owner_;</span><br><span class="line">        LogSetOwner(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAuthority</span>(<span class="params">DSAuthority authority_</span>)</span></span><br><span class="line"><span class="function">        <span class="title">auth</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        authority = authority_;</span><br><span class="line">        LogSetAuthority(authority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier auth &#123;</span><br><span class="line">        assert(isAuthorized(msg.sender, msg.sig));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier authorized(bytes4 sig) &#123;</span><br><span class="line">        assert(isAuthorized(msg.sender, sig));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isAuthorized</span>(<span class="params">address src, bytes4 sig</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (src == address(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src == owner) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (authority == DSAuthority(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> authority.canCall(src, <span class="keyword">this</span>, sig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">bool x</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSStop is DSAuth, DSNote &#123;</span><br><span class="line"></span><br><span class="line">    bool public stopped;</span><br><span class="line"></span><br><span class="line">    modifier stoppable &#123;</span><br><span class="line">        assert (!stopped);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params"></span>) <span class="title">auth</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        stopped = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) <span class="title">auth</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        stopped = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSMath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    standard uint256 functions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x + y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x - y) &lt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x * y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        z = x / y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    uint128 functions (h is for half)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hadd</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x + y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hsub</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x - y) &lt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hmul</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x * y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hdiv</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = x / y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hmin</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hmax</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int256 functions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">imin</span>(<span class="params">int256 x, int256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">int256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">imax</span>(<span class="params">int256 x, int256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">int256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    WAD math</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    uint128 constant WAD = <span class="number">10</span> ** <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wadd</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hadd(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wsub</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hsub(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wmul</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * y + WAD / <span class="number">2</span>) / WAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wdiv</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * WAD + y / <span class="number">2</span>) / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wmin</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmin(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wmax</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmax(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RAY math</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    uint128 constant RAY = <span class="number">10</span> ** <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">radd</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hadd(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rsub</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hsub(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rmul</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * y + RAY / <span class="number">2</span>) / RAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rdiv</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * RAY + y / <span class="number">2</span>) / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rpow</span>(<span class="params">uint128 x, uint64 n</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This famous algorithm is called "exponentiation by squaring"</span></span><br><span class="line">        <span class="comment">// and calculates x^n with x as fixed-point and n as regular unsigned.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// It's O(log n), instead of O(n) for naive repeated multiplication.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// These facts are why it works:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  If n is even, then x^n = (x^2)^(n/2).</span></span><br><span class="line">        <span class="comment">//  If n is odd,  then x^n = x * x^(n-1),</span></span><br><span class="line">        <span class="comment">//   and applying the equation for even x gives</span></span><br><span class="line">        <span class="comment">//    x^n = x * (x^2)^((n-1) / 2).</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  Also, EVM division is flooring and</span></span><br><span class="line">        <span class="comment">//    floor[(n-1) / 2] = floor[n / 2].</span></span><br><span class="line"></span><br><span class="line">        z = n % <span class="number">2</span> != <span class="number">0</span> ? x : RAY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (n /= <span class="number">2</span>; n != <span class="number">0</span>; n /= <span class="number">2</span>) &#123;</span><br><span class="line">            x = rmul(x, x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                z = rmul(z, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rmin</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmin(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rmax</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmax(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cast</span>(<span class="params">uint256 x</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = uint128(x)) == x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint supply</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params"> address who </span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint value</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params"> address owner, address spender </span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint _allowance</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params"> address to, uint value</span>) <span class="title">returns</span> (<span class="params">bool ok</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params"> address from, address to, uint value</span>) <span class="title">returns</span> (<span class="params">bool ok</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params"> address spender, uint value </span>) <span class="title">returns</span> (<span class="params">bool ok</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params"> address indexed from, address indexed to, uint value</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params"> address indexed owner, address indexed spender, uint value</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">DSTokenBase</span> <span class="title">is</span> <span class="title">ERC20</span>, <span class="title">DSMath</span> </span>&#123;</span><br><span class="line">    uint256                                            _supply;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)                       _balances;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256))  _approvals;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DSTokenBase</span>(<span class="params">uint256 supply</span>) </span>&#123;</span><br><span class="line">        _balances[msg.sender] = supply;</span><br><span class="line">        _supply = supply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _supply;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address src</span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _balances[src];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params">address src, address guy</span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _approvals[src][guy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address dst, uint wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        assert(_balances[msg.sender] &gt;= wad);</span><br><span class="line">        </span><br><span class="line">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class="line">        _balances[dst] = add(_balances[dst], wad);</span><br><span class="line">        </span><br><span class="line">        Transfer(msg.sender, dst, wad);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address src, address dst, uint wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        assert(_balances[src] &gt;= wad);</span><br><span class="line">        assert(_approvals[src][msg.sender] &gt;= wad);</span><br><span class="line">        </span><br><span class="line">        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);</span><br><span class="line">        _balances[src] = sub(_balances[src], wad);</span><br><span class="line">        _balances[dst] = add(_balances[dst], wad);</span><br><span class="line">        </span><br><span class="line">        Transfer(src, dst, wad);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address guy, uint256 wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        _approvals[msg.sender][guy] = wad;</span><br><span class="line">        </span><br><span class="line">        Approval(msg.sender, guy, wad);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSToken is DSTokenBase(<span class="number">0</span>), DSStop &#123;</span><br><span class="line"></span><br><span class="line">    bytes32  public  symbol;</span><br><span class="line">    uint256  public  decimals = <span class="number">18</span>; <span class="comment">// standard token precision. override to customize</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DSToken</span>(<span class="params">bytes32 symbol_</span>) </span>&#123;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address dst, uint wad</span>) <span class="title">stoppable</span> <span class="title">note</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.transfer(dst, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address src, address dst, uint wad</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">stoppable</span> <span class="title">note</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.transferFrom(src, dst, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address guy, uint wad</span>) <span class="title">stoppable</span> <span class="title">note</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.approve(guy, wad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">address dst, uint128 wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transfer(dst, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pull</span>(<span class="params">address src, uint128 wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transferFrom(src, msg.sender, wad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">uint128 wad</span>) <span class="title">auth</span> <span class="title">stoppable</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        _balances[msg.sender] = add(_balances[msg.sender], wad);</span><br><span class="line">        _supply = add(_supply, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint128 wad</span>) <span class="title">auth</span> <span class="title">stoppable</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class="line">        _supply = sub(_supply, wad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional token name</span></span><br><span class="line"></span><br><span class="line">    bytes32   public  name = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">bytes32 name_</span>) <span class="title">auth</span> </span>&#123;</span><br><span class="line">        name = name_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述相同的部署方法，我们就可以看到EOS合约中提供的相关方法，并且开始测试了：</p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8gy1ft4v6h504aj20ad0ko75d.jpg" alt=""></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/07/10/starting-on-ethereum-smart-contract-env/#disqus_thread</comments>
    </item>
    
    <item>
      <title>以太坊区块的生成</title>
      <link>http://blog.luoyuanhang.com/2018/05/02/eth-basis-block-concepts/</link>
      <guid>http://blog.luoyuanhang.com/2018/05/02/eth-basis-block-concepts/</guid>
      <pubDate>Wed, 02 May 2018 03:57:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;从名称上来看，区块（Block）也是区块链系统中的核心概念，区块链简单来说就是将区块联结成链，区块中保存的是打包成的各种区块信息。在以太坊中，区块中保存的是各种交易信息。一个区块中可以包含若干个交易，也可以不包含任何交易。这篇文章主要会阐释以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区块是什么？包含了哪些信息？&lt;/li&gt;
&lt;li&gt;区块是如何被打包的，写入到区块链的？&lt;/li&gt;
&lt;li&gt;一个区块的大小是多少？可以包含多少交易？&lt;/li&gt;
&lt;li&gt;多长时间可以产生一个区块？&lt;/li&gt;
&lt;li&gt;为什么有的区块中没有交易？&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>从名称上来看，区块（Block）也是区块链系统中的核心概念，区块链简单来说就是将区块联结成链，区块中保存的是打包成的各种区块信息。在以太坊中，区块中保存的是各种交易信息。一个区块中可以包含若干个交易，也可以不包含任何交易。这篇文章主要会阐释以下问题：</p><ul><li>区块是什么？包含了哪些信息？</li><li>区块是如何被打包的，写入到区块链的？</li><li>一个区块的大小是多少？可以包含多少交易？</li><li>多长时间可以产生一个区块？</li><li>为什么有的区块中没有交易？</li></ul><a id="more"></a><h2 id="以太坊区块"><a href="#以太坊区块" class="headerlink" title="以太坊区块"></a>以太坊区块</h2><p>以太坊的区块中保存了许多信息，最主要的有该区块的区块信息以及该区块中所包含的交易的信息。<br>我们可以在<a href="https://github.com/ethereum/go-ethereum/blob/63687f04e441c97cbb39d6b0ebea346b154d2e73/core/types/block.go" target="_blank" rel="noopener">go-ethereum中的源码</a>看到区块的结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents an entire block in the Ethereum blockchain.</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">header       *Header</span><br><span class="line">uncles       []*Header</span><br><span class="line">transactions Transactions</span><br><span class="line"></span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line"></span><br><span class="line"><span class="comment">// Td is used by package core to store the total difficulty</span></span><br><span class="line"><span class="comment">// of the chain up to and including the block.</span></span><br><span class="line">td *big.Int</span><br><span class="line"></span><br><span class="line"><span class="comment">// These fields are used by package eth to track</span></span><br><span class="line"><span class="comment">// inter-peer block relay.</span></span><br><span class="line">ReceivedAt   time.Time</span><br><span class="line">ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有下列主要属性：</p><ul><li><code>header</code>：存储的是该区块的信息（结构体为Header）</li><li><code>uncles</code>：存储的是该区块所包含的叔块（uncle block）的信息，关于叔块的相关内容将会在之后的文章中进行讨论</li></ul><p>其中Header结构体中是一个区块中所包含的信息，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header represents a block header in the Ethereum blockchain.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">ParentHash  common.Hash    <span class="string">`json:"parentHash"       gencodec:"required"`</span></span><br><span class="line">UncleHash   common.Hash    <span class="string">`json:"sha3Uncles"       gencodec:"required"`</span></span><br><span class="line">Coinbase    common.Address <span class="string">`json:"miner"            gencodec:"required"`</span></span><br><span class="line">Root        common.Hash    <span class="string">`json:"stateRoot"        gencodec:"required"`</span></span><br><span class="line">TxHash      common.Hash    <span class="string">`json:"transactionsRoot" gencodec:"required"`</span></span><br><span class="line">ReceiptHash common.Hash    <span class="string">`json:"receiptsRoot"     gencodec:"required"`</span></span><br><span class="line">Bloom       Bloom          <span class="string">`json:"logsBloom"        gencodec:"required"`</span></span><br><span class="line">Difficulty  *big.Int       <span class="string">`json:"difficulty"       gencodec:"required"`</span></span><br><span class="line">Number      *big.Int       <span class="string">`json:"number"           gencodec:"required"`</span></span><br><span class="line">GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:"gasLimit"         gencodec:"required"`</span></span><br><span class="line">GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:"gasUsed"          gencodec:"required"`</span></span><br><span class="line">Time        *big.Int       <span class="string">`json:"timestamp"        gencodec:"required"`</span></span><br><span class="line">Extra       []<span class="keyword">byte</span>         <span class="string">`json:"extraData"        gencodec:"required"`</span></span><br><span class="line">MixDigest   common.Hash    <span class="string">`json:"mixHash"          gencodec:"required"`</span></span><br><span class="line">Nonce       BlockNonce     <span class="string">`json:"nonce"            gencodec:"required"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到一个区块中包含了如下信息：</p><ul><li><code>ParentHash</code>：该区块的父区块的Hash值</li><li><code>UncleHash</code>：该区块的叔区块的Hash值</li><li><code>Coinbase</code>：打包该区块矿工的地址，矿工费和发现区块的奖励会被发送到该地址</li><li><code>Root</code>：Merkle树根节点的Hash，以太坊中的交易状态信息是以Merkle状态树的形式进行存储的，Root是该状态树的根节点的Hash值</li><li><code>TxHash</code>：保存该区块中交易Merkle树的根节点的Hash值</li><li><code>ReceiptHash</code>：一个区块中所包含的交易中的接收者也是以Merkle树的形式进行存储的，该值是该Merkle树根节点的Hash值</li><li><code>Bloom</code>：用于索引与搜索的结构（详见Tips）</li><li><code>Difficult</code>：该区块的难度</li><li><code>Number</code>：所有祖先区块的数量（也就是区块高度）</li><li><code>GasLimit</code>：该区块的gas上限</li><li><code>GasUsed</code>：该区块使用的gas</li><li><code>Time</code>：区块开始打包的时间</li><li><code>Extra</code>：区块相关的附加信息</li><li><code>MixDigest</code>：该哈希值与Nonce值一起能够证明在该区块上已经进行了足够的计算（用于验证该区块挖矿成功与否的Hash值）</li><li><code>Nonce</code>：该哈希值与MixDigest值一起能够证明在该区块上已经进行了足够的计算（用于验证该区块挖矿成功与否的Hash值）</li></ul><blockquote><p>Tips：<br><strong>Bloom的作用</strong><br>以太坊在设计的时候希望能够对Event能够进行快速的检索，并且在区块链上进行存储的成本是很高的，我们还希望不要有太多的重复数据（交易列表、交易产生的记录等）。Bloom就是用来解决这个问题的。在一个区块生成的时候，该区块中包含的所有的合约相关的地址以及所有交易产生的记录的索引都会被记录至Bloom中，以便之后的查找与索引。这些信息会被保存在Header结构中（Bloom字段），不保存在区块的数据段中，这样可以节省空间。当一个应用层的应用程序想要对某个合约中的数据进行检索时，它只需要在区块中的Header信息中进行查找，查看该区块中是否包含该合约相关的记录。</p><p><strong>MixDigest和Nonce是如何进行验证的</strong><br>我们知道以太坊目前采用的挖矿算法是PoW（Proof of Work），简单的来说，这种方法就像是猜数字，比如说在100000个数字中有5个可行解，猜到的就算是挖到了矿，这种算法要求猜到解的难度是可以调整的，一般难度会很大，不那么容易被猜到，但是验证这个解是否正确是很容易的。Nonce值其实就是矿工猜到的解，验证过程如下：经过预处理的Header与Nonce值做一个类似SHA3的运算产生一个128B的Mix（Mix0），这个值用于计算从DAG（以太坊用于挖矿算法的伪随机数据集，目前大小大约为2GB以上）中取出哪一页的数据（大小为128B），取出的DAG的页与Mix会进行一个以太坊特定的mixing方法，会生成下一个Mix（Mix1），这个过程会重复64次，直到得到Mix64。Mix64会被处理成为32B的数据，它被称为Mix Digest。Mix Digest会与一个叫做Target Threshold的值（相当于解集）进行比较，如果Mix Digest的值小于Threshold就认为挖矿成功，如果大于，表示失败。</p></blockquote><h2 id="区块的打包过程"><a href="#区块的打包过程" class="headerlink" title="区块的打包过程"></a>区块的打包过程</h2><p>交易在生成之后会被以太坊节点广播至网络，交易会被放到交易池（txPool）中，由矿工对交易进行验证然后放到正在打包的区块中，当选择好了区块中所要包含的交易之后，矿工就开始了挖矿过程（PoW），当矿工在挖矿竞争中取得胜利之后，该矿工的区块数据就可以被写入到区块链中。</p><p>交易池中有许多交易存在，矿工是如何从交易池中选择交易的呢？其实交易池会对各个交易进行排序，提供的矿工费（gas）高的交易会排在前面。因此，矿工会优先选择奖励高的交易打包至区块。这也就是为什么gas值高的交易会被处理的较快的原因。</p><h2 id="区块的容量"><a href="#区块的容量" class="headerlink" title="区块的容量"></a>区块的容量</h2><p>以太坊的区块大小不同于比特币的区块大小，目前比特币的区块大小是1MB。因此，比特币一个区块中能够包含多少交易是取决于区块的大小以及每个交易的大小，一个区块中所有交易的总和不能超过区块的大小。但是，以太坊并没有固定的区块大小的限制，但是这样的话是如何确定一个区块中能够包含多少交易的呢？</p><p>以太坊的区块中有一个gasLimit，它表示的是该区块中所能包含的交易的gas值的上限。以太坊上的每一笔交易都会消耗gas值，一个区块中所包含的所有交易的gas总和不能超过区块的gasLimit。因此，通过这种方式我们就能够控制一个区块中的交易数量。</p><p>如果交易池中没有待处理的交易，那么矿工会直接进入挖矿过程，依旧会得到挖矿奖励（5 Ether），区块依旧会被打包和广播，只不过该区块中不会包含交易。</p><h2 id="区块时间"><a href="#区块时间" class="headerlink" title="区块时间"></a>区块时间</h2><p>在比特币中，大约10分钟会产生一个区块。根据以太坊白皮书所写，以太坊大约12秒回产生一个区块。这个时间就是区块时间。区块时间是和挖矿难度相关的，比特币的难度调整是有对应算法的，算法会把区块时间维持在10分钟左右。以太坊也有对应的难度调整算法。</p><p>我们可以在以太坊的源码中找到计算难度的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalcDifficulty is the difficulty adjustment algorithm. It returns</span></span><br><span class="line"><span class="comment">// the difficulty that a new block should have when created at time</span></span><br><span class="line"><span class="comment">// given the parent block's time and difficulty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalcDifficulty</span><span class="params">(config *params.ChainConfig, time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">next := <span class="built_in">new</span>(big.Int).Add(parent.Number, big1)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> config.IsByzantium(next):</span><br><span class="line"><span class="keyword">return</span> calcDifficultyByzantium(time, parent)</span><br><span class="line"><span class="keyword">case</span> config.IsHomestead(next):</span><br><span class="line"><span class="keyword">return</span> calcDifficultyHomestead(time, parent)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> calcDifficultyFrontier(time, parent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到有三个版本的代码，分别应用于不同版本的以太坊，我们先来看一下Homestead版本中的代码：<br>我们可以看到有三个版本的代码，分别应用于不同版本的以太坊，我们先来看一下Homestead版本中的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcDifficultyHomestead</span><span class="params">(time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">bigTime := <span class="built_in">new</span>(big.Int).SetUint64(time)</span><br><span class="line">bigParentTime := <span class="built_in">new</span>(big.Int).Set(parent.Time)</span><br><span class="line"></span><br><span class="line">x := <span class="built_in">new</span>(big.Int)</span><br><span class="line">y := <span class="built_in">new</span>(big.Int)</span><br><span class="line"></span><br><span class="line">x.Sub(bigTime, bigParentTime)</span><br><span class="line">x.Div(x, big10)</span><br><span class="line">x.Sub(big1, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x.Cmp(bigMinus99) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(bigMinus99)</span><br><span class="line">&#125;</span><br><span class="line">y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span><br><span class="line">x.Mul(y, x)</span><br><span class="line">x.Add(parent.Difficulty, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x.Cmp(params.MinimumDifficulty) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(params.MinimumDifficulty)</span><br><span class="line">&#125;</span><br><span class="line">periodCount := <span class="built_in">new</span>(big.Int).Add(parent.Number, big1)</span><br><span class="line">periodCount.Div(periodCount, expDiffPeriod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> periodCount.Cmp(big1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">y.Sub(periodCount, big2)</span><br><span class="line">y.Exp(big2, y, <span class="literal">nil</span>)</span><br><span class="line">x.Add(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，以太坊的难度值是基于当前区块的出块时间，对之后的难度值进行调整的。</p><p>具体公式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff = (parent_diff +(parent_diff / <span class="number">2048</span> * max(<span class="number">1</span> - (block_timestamp - parent_timestamp) <span class="comment">// 10, -99))) + 2^(periodCount - 2)</span></span><br></pre></td></tr></table></figure><p>其中<code>2^(periodCount - 2)</code>又称”难度炸弹“，计算公式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^(periodCount - <span class="number">2</span>) = <span class="number">2</span>**((block_number <span class="comment">// expDiffPeriod) - 2)</span></span><br></pre></td></tr></table></figure><p>目前最新的难度调整算法为Byzantium算法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcDifficultyByzantium</span><span class="params">(time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">bigTime := <span class="built_in">new</span>(big.Int).SetUint64(time)</span><br><span class="line">bigParentTime := <span class="built_in">new</span>(big.Int).Set(parent.Time)</span><br><span class="line"></span><br><span class="line">x := <span class="built_in">new</span>(big.Int)</span><br><span class="line">y := <span class="built_in">new</span>(big.Int)</span><br><span class="line"></span><br><span class="line">x.Sub(bigTime, bigParentTime)</span><br><span class="line">x.Div(x, big9)</span><br><span class="line"><span class="keyword">if</span> parent.UncleHash == types.EmptyUncleHash &#123;</span><br><span class="line">x.Sub(big1, x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x.Sub(big2, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x.Cmp(bigMinus99) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(bigMinus99)</span><br><span class="line">&#125;</span><br><span class="line">y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span><br><span class="line">x.Mul(y, x)</span><br><span class="line">x.Add(parent.Difficulty, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x.Cmp(params.MinimumDifficulty) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(params.MinimumDifficulty)</span><br><span class="line">&#125;</span><br><span class="line">fakeBlockNumber := <span class="built_in">new</span>(big.Int)</span><br><span class="line"><span class="keyword">if</span> parent.Number.Cmp(big2999999) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) <span class="comment">// Note, parent is 1 less than the actual block number</span></span><br><span class="line">&#125;</span><br><span class="line">periodCount := fakeBlockNumber</span><br><span class="line">periodCount.Div(periodCount, expDiffPeriod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> periodCount.Cmp(big1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">y.Sub(periodCount, big2)</span><br><span class="line">y.Exp(big2, y, <span class="literal">nil</span>)</span><br><span class="line">x.Add(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff = (parent_diff + (parent_diff / <span class="number">2048</span> * max((<span class="number">2</span> <span class="keyword">if</span> <span class="built_in">len</span>(parent.uncles) <span class="keyword">else</span> <span class="number">1</span>) - ((timestamp - parent.timestamp) <span class="comment">// 9), -99))) + 2^(periodCount - 2)</span></span><br></pre></td></tr></table></figure><p>以太坊中定义了一个难度的最小值<code>MinimumDifficulty</code>，定义于<code>protocol_params.go</code>源文件中，值为<code>131072</code>，这个值是以太坊中难度的最小值，也是创世块的难度值。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/05/02/eth-basis-block-concepts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础】：交易的生命周期</title>
      <link>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-life-cycle/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-life-cycle/</guid>
      <pubDate>Fri, 20 Apr 2018 03:29:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;大体上说，一个交易的生命周期要经历以下几个过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造一笔交易（这里的交易要包含交易双方的地址、以太币数量、时间戳、签名等信息，它是不含任何私密信息的合法交易数据）&lt;/li&gt;
&lt;li&gt;将消息广播到网络（几乎网络中的所有节点都会收到这笔交易数据）&lt;/li&gt;
&lt;li&gt;验证交易的合法性（生成交易的节点要首先进行验证，其它节点也要进行验证，没有经过验证的交易是不能进入到区块链网络的）&lt;/li&gt;
&lt;li&gt;将交易写入区块链&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>大体上说，一个交易的生命周期要经历以下几个过程：</p><ul><li>构造一笔交易（这里的交易要包含交易双方的地址、以太币数量、时间戳、签名等信息，它是不含任何私密信息的合法交易数据）</li><li>将消息广播到网络（几乎网络中的所有节点都会收到这笔交易数据）</li><li>验证交易的合法性（生成交易的节点要首先进行验证，其它节点也要进行验证，没有经过验证的交易是不能进入到区块链网络的）</li><li>将交易写入区块链</li></ul><a id="more"></a><h2 id="构造一笔交易"><a href="#构造一笔交易" class="headerlink" title="构造一笔交易"></a>构造一笔交易</h2><p>我们先用一个简单的合约作为例子来谈论一笔交易的构造过程，这个合约的作用是在区块链上存储一个数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">uint storedData;</span><br><span class="line"></span><br><span class="line">function set(uint x) public &#123;</span><br><span class="line">storedData = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get() public constant returns (uint) &#123;</span><br><span class="line"><span class="keyword">return</span> storedData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要构造一笔交易，该交易的内容是调用合约中的函数<code>set(uint x)</code>，并且传入参数<code>1</code>。</p><p>首先我们知道，构造一笔交易需要以下字段（具体参照《交易与消息》一文）：</p><ul><li>nonce：交易发送者的交易序列号</li><li>gasPrice：gas价格</li><li>gasLimit：消耗的gas上限</li><li>to：交易接收者的地址</li><li>value：要发送的以太币（以wei为单位）</li><li>data：可选的数据域（在该例子中是必须的字段）</li></ul><p><strong>获取nonce</strong><br>通过geth控制台我们能获取到nonce值，例如：<br>    eth.getTransactionCount(eth.account[0])</p><p><strong>gasPrice</strong><br>我们能够自己随意设置gas的价格，但是有可能由于gas的价格过低，导致交易没有矿工进行处理导致失效。我们可以从这个<a href="https://ethgasstation.info/" target="_blank" rel="noopener">网站</a>来获取推荐的gas价格。</p><p><strong>gasLimit</strong><br>设置你能接受的该交易能够消耗的gas的最大数量。</p><p><strong>to</strong><br>在该例子中，接收者的地址应该是该合约的地址</p><p><strong>value</strong><br>在该例子中，不需要发送以太币，值为0</p><p><strong>data</strong><br>我们需要构造该交易的数据域。</p><p>首先，我们要调用的函数是合约中的<code>set(uint x)</code>，根据Solidity文档<a href="Solidity_ABI_Specification：[https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding](https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding)">^1</a>，我们将该函数<code>set(uint)</code>做Keccak-256哈希<a href="Keccak-256_Hash_Online_Tool：[https://emn178.github.io/online-tools/keccak\_256.html](https://emn178.github.io/online-tools/keccak_256.html)">^2</a>，结果为：</p><pre><code>cccdda2cf2895862749f1c69aa9f55cf481ea82500e4eabb4e2578b36636979b</code></pre><p>我们取其前4字节：<code>0xcccdda2c</code></p><p>然后我们所传入的函数的参数是1，填充为32字节：</p><p><code>0000000000000000000000000000000000000000000000000000000000000001</code></p><p>将这两部分连接起来：</p><p><code>0xcccdda2c0000000000000000000000000000000000000000000000000000000000000001</code></p><p>这就是数据域的内容，共计36字节。</p><p>最终我们构造好的交易是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">txnCount = web3.eth.getTransactionCount(web3.eth.accounts[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">var</span> rawTxn = &#123;</span><br><span class="line">nonce: web3.toHex(txnCount),</span><br><span class="line">gasPrice: web3.toHex(<span class="number">800000000000</span>),</span><br><span class="line">gasLimit: web3.toHex(<span class="number">160000</span>),</span><br><span class="line">to: <span class="string">'0xa55fe56f2a183f795fdaae3529d58b58e57ef5ed'</span>,</span><br><span class="line">value: web3.toHex(<span class="number">0</span>),</span><br><span class="line">data: <span class="string">'0xcccdda2c0000000000000000000000000000000000000000000000000000000000000001'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对交易进行签名"><a href="#对交易进行签名" class="headerlink" title="对交易进行签名"></a>对交易进行签名</h2><p>接下来我们需要使用交易发送者账号的私钥对交易进行签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKey = Buffer.from(<span class="string">'你的账户私钥'</span>, <span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">const</span> txn = <span class="keyword">new</span> EthereumTx(rawTxn)</span><br><span class="line">txn.sign(privateKey)</span><br><span class="line"><span class="keyword">const</span> serializedTxn = txn.serialize()</span><br></pre></td></tr></table></figure><h2 id="本地对交易进行验证"><a href="#本地对交易进行验证" class="headerlink" title="本地对交易进行验证"></a>本地对交易进行验证</h2><p>签名后的交易会首先提交至你的本地以太坊的节点，你的本地节点会首先对该笔交易进行验证，它会验证签名是否有效。</p><h2 id="把交易广播至区块链网络"><a href="#把交易广播至区块链网络" class="headerlink" title="把交易广播至区块链网络"></a>把交易广播至区块链网络</h2><p>之后，你的本地以太坊节点会将交易广播至整个网络，在广播之后会返回一个交易id，你可以通过该id查看和追踪该交易的状态和相关信息。几乎以太坊网络上的所有节点都会收到这笔交易。有一些节点会设置一个最低的gas价格，它们会忽略低于该gasPrice值的交易。</p><h2 id="矿工节点接收到交易"><a href="#矿工节点接收到交易" class="headerlink" title="矿工节点接收到交易"></a>矿工节点接收到交易</h2><p>生成的交易需要被区块链网络中的矿工打包到区块，才能写入到区块链中。矿工会有一个待处理的交易列表，其中的交易是按交易的gasPrice进行排序的，交易的gasPrice越高，处理的优先级就越高。如果交易的gasPrice过低，有可能一直得不到矿工的处理，从而被忽略。</p><h2 id="矿工将交易打包至区块并广播至网络"><a href="#矿工将交易打包至区块并广播至网络" class="headerlink" title="矿工将交易打包至区块并广播至网络"></a>矿工将交易打包至区块并广播至网络</h2><p>矿工会取若干交易然后打包至一个区块中，一个区块中能够包含多少条交易是和区块的gasLimit有关的，所有交易的gasLimit总和不能超过区块的gasLimit。当矿工选择好要打包的交易之后，就开始了PoW（Proof of Work）挖矿过程，最先发现新的区块的矿工能够将交易打包至区块，并且获取到相应的奖励。</p><h2 id="其它节点同步新的区块数据"><a href="#其它节点同步新的区块数据" class="headerlink" title="其它节点同步新的区块数据"></a>其它节点同步新的区块数据</h2><p>由于新的区块已经产生，所有的节点都需要对区块进行同步，你的交易会随着区块的同步被同步至所有节点上。</p><p>至此，一笔交易的生命周期彻底结束，它被永远的写入到了区块链中。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-life-cycle/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础】：交易和消息</title>
      <link>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-and-message/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-and-message/</guid>
      <pubDate>Fri, 20 Apr 2018 02:14:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;交易和消息是以太坊系统中很关键的两个概念，同时也是两个非常类似的概念，它们在形式上近乎相同，但是本质上却又完全不同。这篇博客会将交易（Transaction）、消息（Message）和调用（Message Call）进行介绍和区分。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>交易和消息是以太坊系统中很关键的两个概念，同时也是两个非常类似的概念，它们在形式上近乎相同，但是本质上却又完全不同。这篇博客会将交易（Transaction）、消息（Message）和调用（Message Call）进行介绍和区分。</p><a id="more"></a><h2 id="交易（Transaction）是什么？"><a href="#交易（Transaction）是什么？" class="headerlink" title="交易（Transaction）是什么？"></a>交易（Transaction）是什么？</h2><p>交易存储了发送者要发送至以太坊网络的经过签名的信息，它其中包含了从一个账户要传递给另一个账户（或者合约）的信息。在以太坊中，有两种类型的交易：一种是能够产生消息调用的交易，另一种是能够生成新账户的交易（比如说生成合约）。</p><p>笼统的来说，一个完整有效的以太坊交易包含以下几个部分：</p><ul><li>交易接收者</li><li>签名（用以核实交易发送者身份）</li><li>value值（发送的以太币数量，以wei为单位）</li><li>可选数据域</li><li>STARTGAS值</li><li>GASPRICE值</li></ul><h2 id="交易中的字段"><a href="#交易中的字段" class="headerlink" title="交易中的字段"></a>交易中的字段</h2><p>根据以太坊黄皮书<a href="Ethereum_Yellow_Paper：[https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)">^1</a>，我们知道一个交易中有以下字段：</p><ul><li>nonce：该字段表示的是交易发送者的交易序列号，它是账号的一个交易计数器，这个字段能够防止重放攻击（replay attack）。</li><li>gasPrice：gas的价格，用于计算交易费用</li><li>gasLimit：执行这笔交易所花费的gas的上限</li><li>to：交易接收者的地址或者合约的地址</li><li>value：要发送的以太币数量，以wei为单位</li><li>v, s, r：签名相关的参数，通过这三个参数可以得到发送者的公钥和地址（更详细的内容参见以太坊黄皮书附录F）</li></ul><p>如果该交易是一个创建合约的交易，还可能包括以下字段：</p><ul><li>init：用于初始化交易的EVM（以太坊虚拟机）操作码</li><li>data：数据域（理论上数据域的大小是不受限制的）</li></ul><h2 id="消息（Message）是什么？"><a href="#消息（Message）是什么？" class="headerlink" title="消息（Message）是什么？"></a>消息（Message）是什么？</h2><p>信息在以太坊中是一个“虚拟”的事物，它永远不会被记录到区块链中，它是由合约发出的。从形式上看，消息很“像”交易，但是它与交易有着本质上的区别，一笔成功的交易会被永久的记录到区块链中。在以太坊中，我们可以把消息看做在EVM中的函数调用。</p><p>一般来说，一条消息会包含以下几个部分：</p><ul><li>消息的发送者</li><li>消息的接收者</li><li>以太币的数量（以wei为单位）</li><li>可选数据域</li><li>STARTGAS</li><li>GASPRICE</li></ul><h2 id="交易、消息与调用（Message-Call）的区别"><a href="#交易、消息与调用（Message-Call）的区别" class="headerlink" title="交易、消息与调用（Message Call）的区别"></a>交易、消息与调用（Message Call）的区别</h2><p>以太坊黄皮书中对交易的描述为：</p><blockquote><p>A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.<br>由外部参与者签名后的一段数据。它代表了一条信息或者一个新创建的自治对象(合约)。交易会被记录至区块链的区块中。</p></blockquote><p>对消息的描述为：</p><blockquote><p>Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.<br>在两个账户之间传输的数据（一组字节）和值（以太币的数量），形式是合约的确定性操作或者经过加密安全签名的交易。</p></blockquote><p>对调用的描述为：</p><blockquote><p>The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.<br>从一个账户发送至另一个账户的消息的行为。如果目标账户关联着非空的EVM操作码，VM就会按照该操作码的状态进行启动。如果消息的发送者是一个自治对象，那么该调用将会传递所有返回自VM操作的数据。</p></blockquote><p>具体来说，调用是对合约的本地调用，它是只读的操作并且不会消耗以太币。它能够模拟交易的行为，但是在调用结束以后，它会返回至之前的状态。交易是会被广播至整个网络的，被矿工处理验证之后会被记录至区块链的区块中。</p><h2 id="合约中函数的调用创建的是调用还是交易？"><a href="#合约中函数的调用创建的是调用还是交易？" class="headerlink" title="合约中函数的调用创建的是调用还是交易？"></a>合约中函数的调用创建的是调用还是交易？</h2><p>考虑一下这四种情况：</p><ul><li>使用调用（call）直接对合约函数进行调用</li><li>使用sendTransaction直接对合约函数进行调用</li><li>使用调用（call）通过合约对合约函数进行调用</li><li>使用sendTransaction通过合约对合约函数进行调用</li></ul><p>第一种情况与第三种情况是很明显的调用，第二种情况由于使用的是sendTransaction方法，因此它创建了一笔交易。比较特殊的是第四种情况，它看似是生成了一笔交易，但是由于以太坊黄皮书中对交易的定义中提到，交易是需要外部参与者（External Actor）进行签名的消息，所以第四种情况没有生成交易。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-and-message/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础实践】：以太坊测试私链的搭建</title>
      <link>http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/</guid>
      <pubDate>Wed, 18 Apr 2018 01:07:41 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;以太坊测试私链的搭建&quot;&gt;&lt;a href=&quot;#以太坊测试私链的搭建&quot; class=&quot;headerlink&quot; title=&quot;以太坊测试私链的搭建&quot;&gt;&lt;/a&gt;以太坊测试私链的搭建&lt;/h1&gt;&lt;p&gt;这篇文档通过使用Geth来搭建Ethereum（以太坊）私有测试链。&lt;br&gt;本文档两个节点的系统环境为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OS：Ubuntu
Memory：8G
CPU：Intel Xeon E5-2620
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="以太坊测试私链的搭建"><a href="#以太坊测试私链的搭建" class="headerlink" title="以太坊测试私链的搭建"></a>以太坊测试私链的搭建</h1><p>这篇文档通过使用Geth来搭建Ethereum（以太坊）私有测试链。<br>本文档两个节点的系统环境为：</p><pre><code>OS：UbuntuMemory：8GCPU：Intel Xeon E5-2620</code></pre><a id="more"></a><h2 id="安装Geth"><a href="#安装Geth" class="headerlink" title="安装Geth"></a>安装Geth</h2><p>Geth是通过Go语言实现的一款Ethereum客户端，通过Geth我们可以搭建Ethereum的测试私链。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum</span><br></pre></td></tr></table></figure><h2 id="搭建私有测试链"><a href="#搭建私有测试链" class="headerlink" title="搭建私有测试链"></a>搭建私有测试链</h2><p>通过搭建私有测试链，可以预分配以太币或者调低挖矿的难度来高效的获取以太币，可以便于对以太坊的测试。</p><p><strong>搭建私有测试链需要做的主要有下列这些事项：</strong></p><ul><li><strong>自定义创世块（Genesis Block）</strong></li><li><strong>自定义数据存放位置</strong></li><li><strong>自定义网络ID</strong></li><li><strong>关闭节点发现（Node Discovery）（推荐）</strong></li></ul><h3 id="自定义创世块（Genesis-Block）"><a href="#自定义创世块（Genesis-Block）" class="headerlink" title="自定义创世块（Genesis Block）"></a>自定义创世块（Genesis Block）</h3><ul><li>CustomGenesis.json</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"config"</span>: &#123;</span><br><span class="line"><span class="attr">"chainId"</span>: <span class="number">3131</span>,</span><br><span class="line"><span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"difficulty"</span>: <span class="string">"200000000"</span>,</span><br><span class="line"><span class="attr">"gasLimit"</span>: <span class="string">"2100000"</span>,</span><br><span class="line"><span class="attr">"alloc"</span>: &#123;</span><br><span class="line"><span class="attr">"7df9a875a174b3bc565e6424a0050ebc1b2d1d82"</span>: &#123; <span class="attr">"balance"</span>: <span class="string">"300"</span> &#125;,</span><br><span class="line"><span class="attr">"f41c74c9ae680c1aa78f42e5647a62f353b7bdde"</span>: &#123; <span class="attr">"balance"</span>: <span class="string">"400"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创世块是区块链中的第一个初始区块，我们通过定义<code>CustomGenesis.json</code>文件来对其进行自定义。</p><p>在创世块的配置文件<a href="Config配置参数：[https://github.com/ethereum/go-ethereum/blob/feeccdf4ec1084b38dac112ff4f86809efd7c0e5/params/config.go#L71](https://github.com/ethereum/go-ethereum/blob/feeccdf4ec1084b38dac112ff4f86809efd7c0e5/params/config.go#L71)">^1</a>中，有四个参数是必须要指定的：</p><ul><li>config：区块链的相关参数<ul><li>chainId：防止重放攻击（replay attack，简单来说就是未经授权的用户来假扮交易的发送者）</li><li>homesteadBlock：Homestead<a href="Ethereum_Homestead：[http://www.ethdocs.org/en/latest/](http://www.ethdocs.org/en/latest/)">^2</a>是以太坊的第二个发行版本（Frontier<a href="Ethereum_Frontier：[https://ethereum.gitbooks.io/frontier-guide/](https://ethereum.gitbooks.io/frontier-guide/)">^3</a>是第一个发行版本），值为0表示的使用的是该版本的以太坊</li></ul></li><li>difficult：初始挖矿难度</li><li>gasLimit：每一个区块所消耗的gas上限</li><li>alloc：可以往地址中预先分配以太币</li></ul><h3 id="生成创世块"><a href="#生成创世块" class="headerlink" title="生成创世块"></a>生成创世块</h3><p>使用下列命令来初始化创世块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir /path/to/data init /path/to/CustomGenesis.json</span><br></pre></td></tr></table></figure><ul><li><code>--datadir</code>：指定区块链的数据目录（默认为<code>~/.ethereum</code>）</li><li><code>init</code>：创世块初始化JSON文件的目录</li></ul><h3 id="启动以太坊私有测试链"><a href="#启动以太坊私有测试链" class="headerlink" title="启动以太坊私有测试链"></a>启动以太坊私有测试链</h3><p><strong>相关启动参数</strong></p><p>启动geth有如下主要参数（可以使用<code>geth --help</code>进行查看）：</p><ul><li><code>--nodiscover</code>：关闭节点的可发现性，可以防止使用了相同network id和创世块的节点连接到你的区块链网络中（只能通过手动来添加节点）</li><li><code>--maxpeers 0</code>：指定网络中的最多节点数</li><li><code>--rpc</code>：启用RPC服务</li><li><code>--rpcapi &quot;db,eth,net,web3&quot;</code>：指定启用的RPC API</li><li><code>--rpcport &quot;8080&quot;</code>：指定RPC的端口</li><li><code>--rpccorsdomain</code>：指定哪些URL可以连接到你的节点</li><li><code>--datadir</code>：以太坊区块链的数据目录</li><li><code>--port</code>：连接到其它节点的网络监听端口</li><li><code>--identity &quot;FirstNode&quot;</code>：指定节点名称</li><li><code>console</code>：启动geth控制台程序</li></ul><p><strong>启动geth</strong></p><p>使用以下命令来启动geth：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --identity "ETH-MainNode" --rpc --rpcport "6060" --rpccorsdomain "*" --datadir "/home/lyh/privatechain-eth/data" --port "30303" --nodiscover --maxpeers 5 --rpcapi "admin,db,eth,debug,miner,net,shh,txpool,personal,web3" --networkid 3131 console</span><br></pre></td></tr></table></figure><p>使用相同的配置对两个节点进行配置并启动。</p><h3 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h3><p>在其中一个节点的geth控制台中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin.nodeInfo</span></span><br></pre></td></tr></table></figure><p>我们得到该节点的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin.nodeInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  enode: "enode://09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7@[::]:30303",</span><br><span class="line">  id: "09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7",</span><br><span class="line">  ip: "::",</span><br><span class="line">  listenAddr: "[::]:30303",</span><br><span class="line">  name: "Geth/ETH-MainNode/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4",</span><br><span class="line">  ports: &#123;</span><br><span class="line">    discovery: 30303,</span><br><span class="line">    listener: 30303</span><br><span class="line">  &#125;,</span><br><span class="line">  protocols: &#123;</span><br><span class="line">    eth: &#123;</span><br><span class="line">      config: &#123;</span><br><span class="line">        chainId: 3131,</span><br><span class="line">        eip150Hash: "0x0000000000000000000000000000000000000000000000000000000000000000",</span><br><span class="line">        eip155Block: 0,</span><br><span class="line">        eip158Block: 0,</span><br><span class="line">        homesteadBlock: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      difficulty: 92699744128,</span><br><span class="line">      genesis: "0x54fd3f9117e7d8c5b130af59fed07ddc9eef0826016d4d5b9c07db8db1dfac23",</span><br><span class="line">      head: "0xd67ba0763b4fc50741b33205e486d0113aa182d310ee0225332459d104ed5b58",</span><br><span class="line">      network: 3131</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到enode信息：<br>    enode://09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7@[::]:30303</p><p>我们需要在另一台节点上添加上该节点，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin.addPeer(<span class="string">"09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7@[::]:30303"</span>)</span></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>我们需要将上述enode信息中的<code>[::]</code>更换为该节点的IP地址。</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> net.peerCount</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>我们看到已经添加了一个节点。</p><h2 id="测试以太坊私有链"><a href="#测试以太坊私有链" class="headerlink" title="测试以太坊私有链"></a>测试以太坊私有链</h2><p>我们可以通过在两个节点分别创建账号构造一笔转账交易来验证多节点的私链是否搭建成功。</p><p><strong>分别在两个节点中创建账号：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> personal.newAccount()</span></span><br></pre></td></tr></table></figure><p>设置密码后，得到地址：</p><p>节点一：<br>    &gt; “0xa9436991e002986f58d948d79e737df190c4f26b”</p><p>节点二：<br>    &gt; “0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec”</p><p><strong>开始挖矿：</strong></p><p>由于新创建的账号中是没有以太币的，因此我们需要启用矿工进行挖矿：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.setEtherbase(<span class="string">"0xa9436991e002986f58d948d79e737df190c4f26b"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.start(1)</span></span><br></pre></td></tr></table></figure><p>另一个节点同样开启挖矿：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.setEtherbase(<span class="string">"0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.start(1)</span></span><br></pre></td></tr></table></figure><p><strong>构造一笔交易：</strong></p><p>在进行转账之前，我们需要对钱包进行解锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> personal.unlockAccount(<span class="string">"0xa9436991e002986f58d948d79e737df190c4f26b"</span>)</span></span><br></pre></td></tr></table></figure><p>输入密码对钱包进行解锁后，构造一笔转账交易：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> eth.sendTransaction(&#123;from: <span class="string">"0xa9436991e002986f58d948d79e737df190c4f26b"</span>, to: <span class="string">"0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec"</span>, value: web3.toWei(10, <span class="string">"ether"</span>)&#125;)</span></span><br></pre></td></tr></table></figure><p>在交易被矿工进行验证与打包至区块之后，我们可以查询一下钱包的余额来验证交易是否完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> eth.getBalance(<span class="string">"0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec"</span>)</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础】：账户、地址、私钥和公钥</title>
      <link>http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/</guid>
      <pubDate>Tue, 17 Apr 2018 01:33:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;在以太坊中，账户、地址、私钥（Private Key）和公钥（Public Key）是非常重要的概念。账户扮演着以太坊的中心角色，地址是我们与以太坊系统进行交互的标识，它是以太坊账户与外界进行交互的名字，而私钥与公钥是保护我们账户安全的重要屏障。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在以太坊中，账户、地址、私钥（Private Key）和公钥（Public Key）是非常重要的概念。账户扮演着以太坊的中心角色，地址是我们与以太坊系统进行交互的标识，它是以太坊账户与外界进行交互的名字，而私钥与公钥是保护我们账户安全的重要屏障。</p><a id="more"></a><h2 id="什么是账户（Accounts）？"><a href="#什么是账户（Accounts）？" class="headerlink" title="什么是账户（Accounts）？"></a>什么是账户（Accounts）？</h2><p>账户在以太坊中扮演者十分重要的角色，它是以太坊的中心概念。在以太坊中，有两种类型的账户<a href="Ethereum_Accounts：[http://ethdocs.org/en/latest/account-management.html#accounts](http://ethdocs.org/en/latest/account-management.html#accounts)">^1</a>：一种是外部账户（EOAs，Externally Owned Accounts），另一种是合约账户（Contracts Accounts）。当我们提到账户这个术语的时候，我们通常指的是外部账户（EOA），当提到合约账户的时候我们通常称其为“合约”。</p><p>不论是外部账户还是合约账户，它们在以太坊中所维护的都是一系列叫做状态对象（state objects）的实体。这些实体中都拥有状态信息：外部账户存储的是账户的余额（balance），合约账户存储的是余额和合约中的内容。它们存储的这些状态会通过以太坊网络进行更新以及保证数据的一致性。账户是用户在以太坊区块链上创建交易必不可少的一部分。</p><p>账户标识了以太坊网络中每一个参与者的身份，每一笔交易都需要通过账户使用公钥加密进行签名才能够正常进行，这样的话，EVM（以太坊虚拟机）才能够对交易发送者进行验证来确保交易的真实可靠。</p><h2 id="什么是以太坊地址（Address）？"><a href="#什么是以太坊地址（Address）？" class="headerlink" title="什么是以太坊地址（Address）？"></a>什么是以太坊地址（Address）？</h2><p>一个以太坊地址就代表着一个以太坊账户，地址是账户的标识。对于外部账户来说，地址表示的是该账户公钥的后20字节（通常会以0x开头，例如，<code>0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826</code>，该地址使用的是16进制表示法<a href="Hexadecimal_Format：[http://ethdocs.org/en/latest/glossary.html#hexadecimal](http://ethdocs.org/en/latest/glossary.html#hexadecimal)">^2</a>）。上述示例中的地址中的字母全部是小写。在EIP55<a href="EIP55：[https://github.com/ethereum/EIPs/issues/55](https://github.com/ethereum/EIPs/issues/55)">^3</a>中引入了一种大小写混用的地址表示方法，通过这种表示方法进行表示的地址隐含了一个校验和（checksum）能够验证该地址的有效性。</p><h2 id="什么是私钥和公钥？"><a href="#什么是私钥和公钥？" class="headerlink" title="什么是私钥和公钥？"></a>什么是私钥和公钥？</h2><p>每个账户都由一对钥匙定义，一个私钥（Private Key）和一个公钥（Public Key）。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥/地址都编码在一个钥匙文件里。该文件是JSON格式的，下面我们将会查看一个私钥文件示例（Keystore）。</p><p>以太坊的私钥是一串64位16进制字符（32字节）。它是账户安全最重要的部分，需要妥善保管，如果丢失了私钥也就意味着你的账户丢失了。</p><h2 id="查看一个Keystore文件"><a href="#查看一个Keystore文件" class="headerlink" title="查看一个Keystore文件"></a>查看一个Keystore文件</h2><p>Keystore文件通常保存在以太坊数据目录的<code>keystore</code>文件夹下，它是JSON格式的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="attr">"address"</span>:<span class="string">"358f94366124d9f2817b09c84921d2a653f5ac0c"</span>,</span><br><span class="line">   <span class="attr">"crypto"</span>:&#123;  </span><br><span class="line">      <span class="attr">"cipher"</span>:<span class="string">"aes-128-ctr"</span>,</span><br><span class="line">      <span class="attr">"ciphertext"</span>:<span class="string">"41c14f88ec8f35c9fe57cd39121a76c2dadbd82ea8fec59866468bc0d7371f2e"</span>,</span><br><span class="line">      <span class="attr">"cipherparams"</span>:&#123;  </span><br><span class="line">         <span class="attr">"iv"</span>:<span class="string">"43443bf394e8f6ebcc687e13bc0effb9"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"kdf"</span>:<span class="string">"scrypt"</span>,</span><br><span class="line">      <span class="attr">"kdfparams"</span>:&#123;  </span><br><span class="line">         <span class="attr">"dklen"</span>:<span class="number">32</span>,</span><br><span class="line">         <span class="attr">"n"</span>:<span class="number">262144</span>,</span><br><span class="line">         <span class="attr">"p"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"r"</span>:<span class="number">8</span>,</span><br><span class="line">         <span class="attr">"salt"</span>:<span class="string">"aaef6847d09cb1e9f5ceadaf5865d96a7493df1cae146b24e31092cc0a7844af"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"mac"</span>:<span class="string">"5e9781c587db5795c6d41cb4f001bf086cc3db33b6e7eefcc2ef472145e76821"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"id"</span>:<span class="string">"bcd61a88-283f-4d81-8457-30ec9c11521f"</span>,</span><br><span class="line">   <span class="attr">"version"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过keystore文件中的内容，我们可以看到其中包括了私钥加密的相关信息：</p><ul><li>address：该账户的地址</li><li>cipher：加密方法使用的是AES-128-CTR算法<a href="AES五种加密模式（CBC、ECB、CTR、OCF、CFB）：[https://www.cnblogs.com/starwolf/p/3365834.html](https://www.cnblogs.com/starwolf/p/3365834.html)">^4</a></li><li>ciphertext：加密后的密文</li><li>cipherparams：AES-128-CTR算法加密所需的相关参数</li><li>kdf：秘钥生成函数，用于使用密码对keystore文件进行加密</li><li>kdfparams：kdf算法所需的参数</li><li>mac：用于验证密码的编码</li></ul><h2 id="私钥、公钥和地址是如何生成的？"><a href="#私钥、公钥和地址是如何生成的？" class="headerlink" title="私钥、公钥和地址是如何生成的？"></a>私钥、公钥和地址是如何生成的？</h2><p>大体来说，地址的生成的流程是：私钥 -> 公钥 -> 地址。因此地址的生成需要三步：</p><ol><li>生成一个随机的私钥（32字节）</li><li>通过私钥生成公钥（64字节）</li><li>通过公钥得到地址（20字节）</li></ol><p><strong>私钥的生成</strong></p><p>私钥是一组64位的16进制字符，通过私钥我们能够访问一个账户。以太坊的私钥生成是通过secp256k1<a href="Secp256k1：[https://en.bitcoin.it/wiki/Secp256k1](https://en.bitcoin.it/wiki/Secp256k1)">^5</a>曲线生成的，secp256k1是一个椭圆曲线算法，比特币使用的也是相同的曲线算法。</p><p>通过OpenSSL<a href="OpenSSL：[https://github.com/openssl/openssl](https://github.com/openssl/openssl)">^6</a>我们可以生成一个椭圆曲线私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ openssl ecparam -name secp256k1 -genkey -noout                                                                                                                                                                                                                    </span><br><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MHQCAQEEICGlTPPQInj0R/jaa7+bjF1twiR3RDLdOChSq98L5FmWoAcGBSuBBAAK</span><br><span class="line">oUQDQgAERynScthXq2n4Ahkfp08s/QNogZEtVCfQE/XTvpjsnIeQEZGJIOb+Liyl</span><br><span class="line">uF8PIerBE1CjvCs5LLU+fZz+B31+Bg==</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p><strong>公钥的生成</strong></p><p>其实，通过OpenSSL我们可以同时得到私钥和公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> openssl ecparam -name secp256k1 -genkey -noout | openssl ec -text -noout                                                                                                                                                                                          </span></span><br><span class="line">read EC key</span><br><span class="line">Private-Key: (256 bit)</span><br><span class="line">priv:</span><br><span class="line">    3f:64:bb:20:0a:b5:82:e9:73:03:8a:8b:79:68:62:</span><br><span class="line">    41:8b:98:a7:10:00:fb:50:de:c4:4d:0d:06:3d:a2:</span><br><span class="line">    ed:cd</span><br><span class="line">pub:</span><br><span class="line">    04:4a:18:c2:c7:40:f4:9a:77:b2:89:e9:27:0c:39:</span><br><span class="line">    94:8b:94:10:a1:b0:c9:81:d9:af:06:8c:06:23:93:</span><br><span class="line">    63:d7:26:82:fd:b0:22:fe:f6:7f:4f:8a:69:58:2f:</span><br><span class="line">    98:3a:b3:94:ab:5f:06:85:4c:25:f3:3d:8e:f1:35:</span><br><span class="line">    2f:e7:fe:50:4d</span><br><span class="line">ASN1 OID: secp256k1</span><br></pre></td></tr></table></figure><p><strong>地址的生成</strong></p><p>地址是通过对上述的公钥做Keccak-256哈希<a href="Keccak-256_Online：[https://emn178.github.io/online-tools/keccak\_256.html](https://emn178.github.io/online-tools/keccak_256.html)">^7</a>，然后取最后的40位16进制字符得到的。我们对上述的公钥做哈希后并取后40位的结果是：<code>0x24602722816b6cad0e143ce9fabf31f6026ec622</code>。得到的该结果就是一个有效的以太坊地址。</p><h2 id="如何验证地址的有效性"><a href="#如何验证地址的有效性" class="headerlink" title="如何验证地址的有效性"></a>如何验证地址的有效性</h2><p><strong>Geth Web3进行验证：</strong></p><p>通过以太坊客户端Geth的Web3接口可以对以太坊地址进行有效性验证：</p><pre><code>&gt; web3.utils.isAddress(&apos;0xc1912fee45d61c87cc5ea59dae31190fffff232d&apos;);&gt; true</code></pre><p><strong>通过第三方JS库进行验证：</strong></p><p>wallet-address-validator<a href="wallet-address-validator：[https://github.com/ognus/wallet-address-validator](https://github.com/ognus/wallet-address-validator)">^8</a>是一个JavaScript库能够对多种加密货币的地址进行验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WAValidator = <span class="built_in">require</span>(<span class="string">'wallet-address-validator'</span>);</span><br><span class="line"><span class="keyword">var</span> valid1 = WAValidator.validate(<span class="string">'0x24602722816b6cad0e143ce9fabf31f6026ec622'</span>, <span class="string">'ETH'</span>);</span><br><span class="line"><span class="keyword">if</span>(valid1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'This is a valid address'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Address INVALID'</span>);</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/#disqus_thread</comments>
    </item>
    
    <item>
      <title>多节点FastCoin山寨币的搭建</title>
      <link>http://blog.luoyuanhang.com/2018/04/08/fastcoin-multinodes/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/08/fastcoin-multinodes/</guid>
      <pubDate>Sun, 08 Apr 2018 14:10:28 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章给出了Fastcoin多节点环境的搭建文档，FastCoin是一个由&lt;a href=&quot;https://github.com/imharrywu/fastcoin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@harrywu&lt;/a&gt;修改&lt;a href=&quot;https://github.com/bitcoin/bitcoin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BitCoin源代码&lt;/a&gt;产生的一个简单的山寨币。该山寨币在原有BitCoin源码基础上，对BitCoin相关网络参数、创世块信息、工作量机制等进行了修改，从而构建出了一个简单的山寨币系统，该系统加快了原有的挖矿速度，能够更方便的进行区块链开发的相关测试。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章给出了Fastcoin多节点环境的搭建文档，FastCoin是一个由<a href="https://github.com/imharrywu/fastcoin" target="_blank" rel="noopener">@harrywu</a>修改<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">BitCoin源代码</a>产生的一个简单的山寨币。该山寨币在原有BitCoin源码基础上，对BitCoin相关网络参数、创世块信息、工作量机制等进行了修改，从而构建出了一个简单的山寨币系统，该系统加快了原有的挖矿速度，能够更方便的进行区块链开发的相关测试。</p></blockquote><a id="more"></a><h1 id="1-FastCoin简介"><a href="#1-FastCoin简介" class="headerlink" title="1 FastCoin简介"></a>1 FastCoin简介</h1><p>FastCoin是一个由<a href="https://github.com/imharrywu/fastcoin" target="_blank" rel="noopener">@harrywu</a>修改<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">BitCoin源代码</a>产生的一个简单的<a href="https://blog.csdn.net/hacode/article/details/40422535" target="_blank" rel="noopener">山寨币</a>。该山寨币在原有BitCoin源码基础上，对BitCoin相关网络参数、创世块信息、工作量机制等进行了修改，从而构建出了一个简单的山寨币系统，该系统加快了原有的挖矿速度，能够更方便的进行区块链开发的相关测试。</p><h1 id="2-系统环境"><a href="#2-系统环境" class="headerlink" title="2 系统环境"></a>2 系统环境</h1><p>该文档的采用了两个节点进行测试，两个节点的系统环境如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS: Ubuntu</span><br><span class="line">Linux Kernel: Linux 4.4.0</span><br><span class="line">Memory: 1G</span><br><span class="line">gcc Version: 5.4.0</span><br><span class="line">g++ Version: 5.4.0</span><br></pre></td></tr></table></figure><h1 id="3-安装准备"><a href="#3-安装准备" class="headerlink" title="3 安装准备"></a>3 安装准备</h1><p>该文档采用两个节点对FastCoin山寨币进行搭建，两个节点做同样的配置。</p><h2 id="3-1-获取FastCoin源码"><a href="#3-1-获取FastCoin源码" class="headerlink" title="3.1 获取FastCoin源码"></a>3.1 获取FastCoin源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/imharrywu/fastcoin.git</span><br></pre></td></tr></table></figure><h2 id="3-2-安装项目构建依赖"><a href="#3-2-安装项目构建依赖" class="headerlink" title="3.2 安装项目构建依赖"></a>3.2 安装项目构建依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libtool autotools-dev autoconf pkg-config libssl-dev</span><br></pre></td></tr></table></figure><h2 id="3-3-安装Berkeley-DB-4-8"><a href="#3-3-安装Berkeley-DB-4-8" class="headerlink" title="3.3 安装Berkeley DB 4.8"></a>3.3 安装Berkeley DB 4.8</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fastcoin/</span><br><span class="line">BITCOIN_ROOT=$(<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 Berkeley DB安装路径，此处为fastcoin子目录下</span></span><br><span class="line">BDB_PREFIX=<span class="string">"<span class="variable">$&#123;BITCOIN_ROOT&#125;</span>/db4"</span></span><br><span class="line">mkdir -p <span class="variable">$BDB_PREFIX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">wget <span class="string">'http://download.oracle.com/berkeley-db/db-4.8.30.NC.tar.gz'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'12edc0df75bf9abd7f82f821795bcee50f42cb2e5f76a6a281b85732798364ef  db-4.8.30.NC.tar.gz'</span> | sha256sum -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结应该为： -&gt; db-4.8.30.NC.tar.gz: OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xzvf db-4.8.30.NC.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建安装</span></span><br><span class="line"><span class="built_in">cd</span> db-4.8.30.NC/build_unix/</span><br><span class="line">../dist/configure --<span class="built_in">enable</span>-cxx --<span class="built_in">disable</span>-shared --with-pic --prefix=<span class="variable">$BDB_PREFIX</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="3-4-安装Boost"><a href="#3-4-安装Boost" class="headerlink" title="3.4 安装Boost"></a>3.4 安装Boost</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libboost-all-dev</span><br></pre></td></tr></table></figure><h2 id="3-5-安装miniupnp"><a href="#3-5-安装miniupnp" class="headerlink" title="3.5 安装miniupnp"></a>3.5 安装miniupnp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://miniupnp.tuxfamily.org/files/download.php?file=miniupnpc-1.6.20120410.tar.gz</span><br><span class="line">tar -xzvf miniupnpc-1.6.20120410.tar.gz</span><br><span class="line"><span class="built_in">cd</span> miniupnpc-1.6</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>也可以使用Ubuntu源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libminiupnpc-dev</span><br></pre></td></tr></table></figure><h1 id="4-搭建过程"><a href="#4-搭建过程" class="headerlink" title="4 搭建过程"></a>4 搭建过程</h1><h2 id="4-1-编译源码"><a href="#4-1-编译源码" class="headerlink" title="4.1 编译源码"></a>4.1 编译源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure --with-miniupnpc --without-gui --<span class="built_in">enable</span>-upnp-default LDFLAGS=<span class="string">"-L<span class="variable">$&#123;BDB_PREFIX&#125;</span>/lib/"</span> CPPFLAGS=<span class="string">"-I<span class="variable">$&#123;BDB_PREFIX&#125;</span>/include/"</span> --<span class="built_in">enable</span>-wallet</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译安装之后，在<code>src</code>目录下会生成相应的二进制文件，主要用到的二进制文件有：</p><ul><li>bitcoind：fastcoin主程序</li><li>bitcoin-cli：fastcoin RPC控制台程序</li></ul><p><em>如果在编译过程中遭遇如下报错信息，详见【6.1 Boost依赖库引起的报错】：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/boost/variant/get.hpp:178:5: error: invalid application of <span class="string">'sizeof'</span> to incomplete <span class="built_in">type</span> <span class="string">'boost::STATIC_ASSERTION_FAILURE&lt;false&gt;'</span></span><br><span class="line">     BOOST_STATIC_ASSERT_MSG(</span><br><span class="line">     ^</span><br><span class="line">Makefile:3654: recipe <span class="keyword">for</span> target <span class="string">'libbitcoin_server_a-rpcrawtransaction.o'</span> failed</span><br><span class="line">make[2]: *** [libbitcoin_server_a-rpcrawtransaction.o] Error 1</span><br></pre></td></tr></table></figure><h2 id="4-2-相关configuration参数"><a href="#4-2-相关configuration参数" class="headerlink" title="4.2 相关configuration参数"></a>4.2 相关configuration参数</h2><ul><li><code>--without-gui</code>：不使用GUI，如果需要图形化界面，详见【6.6 图形化界面钱包的构建】</li><li><code>--enable-wallet:</code>启用钱包（不启用钱包<code>--disable-wallet</code>也可以进行挖矿，如果不启用钱包，则无需安装Berkeley DB）</li><li><code>--enable-debug:</code>启用debug模式</li><li><code>--enable-tests:</code>对测试程序进行编译</li><li><code>CPPFLAGS</code>、<code>LDFLAGS</code>：指定Berkeley DB的路径</li></ul><h1 id="5-FastCoin测试"><a href="#5-FastCoin测试" class="headerlink" title="5 FastCoin测试"></a>5 FastCoin测试</h1><h2 id="5-1-FastCoin配置文件"><a href="#5-1-FastCoin配置文件" class="headerlink" title="5.1 FastCoin配置文件"></a>5.1 FastCoin配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.fastcoin/fastcoin.conf</span><br></pre></td></tr></table></figure><p>在<code>fastcoin.conf</code>文件中添加如下配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">rpcuser=user</span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">rpcpassword=password</span><br><span class="line"></span><br><span class="line">daemon=1</span><br><span class="line">txindex=1</span><br><span class="line">server=1</span><br></pre></td></tr></table></figure><h2 id="5-2-启动bitcoind"><a href="#5-2-启动bitcoind" class="headerlink" title="5.2 启动bitcoind"></a>5.2 启动bitcoind</h2><p>在其中一个节点中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fastcoin/src</span><br><span class="line">./bincoind -gen=1 -reindex -checkpoints=0</span><br></pre></td></tr></table></figure><p>另一个节点执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bincoind -gen=1 -reindex -checkpoints=0 -addnode=<span class="string">"另一个节点的IP，例：192.169.1.233"</span></span><br></pre></td></tr></table></figure><h2 id="5-3-bitcoind相关启动参数"><a href="#5-3-bitcoind相关启动参数" class="headerlink" title="5.3 bitcoind相关启动参数"></a>5.3 bitcoind相关启动参数</h2><ul><li><code>-rpcuser=</code>：指定用户名</li><li><code>-rpcpassword=</code>：指定密码</li><li><code>-daemon=</code>：bitcoind作为daemon进程在后台运行</li><li><code>-gen=</code>：生成山寨币（挖矿）</li><li><code>-addnode=</code>：添加节点</li><li><code>-reindex</code>：bitcoind启动时从当前<code>blk000??.dat</code>文件中的index重建区块链</li><li><code>-server</code>：启用RPC服务器</li></ul><h2 id="5-4-bitcoin-cli"><a href="#5-4-bitcoin-cli" class="headerlink" title="5.4 bitcoin-cli"></a>5.4 bitcoin-cli</h2><p>使用<code>./bitcoin-cli &lt;parameters&gt;</code>可以查看当前区块链、网络、钱包等信息。</p><p>相关参数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">== Blockchain ==</span><br><span class="line">getbestblockhash</span><br><span class="line">getblock &quot;hash&quot; ( verbose )</span><br><span class="line">getblockchaininfo</span><br><span class="line">getblockcount</span><br><span class="line">getblockhash index</span><br><span class="line">getchaintips</span><br><span class="line">getdifficulty</span><br><span class="line">getmempoolinfo</span><br><span class="line">getrawmempool ( verbose )</span><br><span class="line">gettxout &quot;txid&quot; n ( includemempool )</span><br><span class="line">gettxoutsetinfo</span><br><span class="line">verifychain ( checklevel numblocks )</span><br><span class="line"></span><br><span class="line">== Control ==</span><br><span class="line">getinfo</span><br><span class="line">help ( &quot;command&quot; )</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">== Generating ==</span><br><span class="line">getgenerate</span><br><span class="line">setgenerate generate ( genproclimit )</span><br><span class="line"></span><br><span class="line">== Mining ==</span><br><span class="line">getblocktemplate ( &quot;jsonrequestobject&quot; )</span><br><span class="line">getmininginfo</span><br><span class="line">getnetworkhashps ( blocks height )</span><br><span class="line">prioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;</span><br><span class="line">submitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )</span><br><span class="line"></span><br><span class="line">== Network ==</span><br><span class="line">addnode &quot;node&quot; &quot;add|remove|onetry&quot;</span><br><span class="line">getaddednodeinfo dns ( &quot;node&quot; )</span><br><span class="line">getconnectioncount</span><br><span class="line">getnettotals</span><br><span class="line">getnetworkinfo</span><br><span class="line">getpeerinfo</span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line">== Rawtransactions ==</span><br><span class="line">createrawtransaction [&#123;&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n&#125;,...] &#123;&quot;address&quot;:amount,...&#125;</span><br><span class="line">decoderawtransaction &quot;hexstring&quot;</span><br><span class="line">decodescript &quot;hex&quot;</span><br><span class="line">getrawtransaction &quot;txid&quot; ( verbose )</span><br><span class="line">sendrawtransaction &quot;hexstring&quot; ( allowhighfees )</span><br><span class="line">signrawtransaction &quot;hexstring&quot; ( [&#123;&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;&#125;,...] [&quot;privatekey1&quot;,...] sighashtype )</span><br><span class="line"></span><br><span class="line">== Util ==</span><br><span class="line">createmultisig nrequired [&quot;key&quot;,...]</span><br><span class="line">estimatefee nblocks</span><br><span class="line">estimatepriority nblocks</span><br><span class="line">validateaddress &quot;fastcoinaddress&quot;</span><br><span class="line">verifymessage &quot;fastcoinaddress&quot; &quot;signature&quot; &quot;message&quot;</span><br><span class="line"></span><br><span class="line">== Wallet ==</span><br><span class="line">addmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )</span><br><span class="line">backupwallet &quot;destination&quot;</span><br><span class="line">dumpprivkey &quot;fastcoinaddress&quot;</span><br><span class="line">dumpwallet &quot;filename&quot;</span><br><span class="line">encryptwallet &quot;passphrase&quot;</span><br><span class="line">getaccount &quot;fastcoinaddress&quot;</span><br><span class="line">getaccountaddress &quot;account&quot;</span><br><span class="line">getaddressesbyaccount &quot;account&quot;</span><br><span class="line">getbalance ( &quot;account&quot; minconf includeWatchonly )</span><br><span class="line">getnewaddress ( &quot;account&quot; )</span><br><span class="line">getrawchangeaddress</span><br><span class="line">getreceivedbyaccount &quot;account&quot; ( minconf )</span><br><span class="line">getreceivedbyaddress &quot;fastcoinaddress&quot; ( minconf )</span><br><span class="line">gettransaction &quot;txid&quot; ( includeWatchonly )</span><br><span class="line">getunconfirmedbalance</span><br><span class="line">getwalletinfo</span><br><span class="line">importaddress &quot;address&quot; ( &quot;label&quot; rescan )</span><br><span class="line">importprivkey &quot;fastcoinprivkey&quot; ( &quot;label&quot; rescan )</span><br><span class="line">importwallet &quot;filename&quot;</span><br><span class="line">keypoolrefill ( newsize )</span><br><span class="line">listaccounts ( minconf includeWatchonly)</span><br><span class="line">listaddressgroupings</span><br><span class="line">listlockunspent</span><br><span class="line">listreceivedbyaccount ( minconf includeempty includeWatchonly)</span><br><span class="line">listreceivedbyaddress ( minconf includeempty includeWatchonly)</span><br><span class="line">listsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)</span><br><span class="line">listtransactions ( &quot;account&quot; count from includeWatchonly)</span><br><span class="line">listunspent ( minconf maxconf  [&quot;address&quot;,...] )</span><br><span class="line">lockunspent unlock [&#123;&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n&#125;,...]</span><br><span class="line">move &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )</span><br><span class="line">sendfrom &quot;fromaccount&quot; &quot;tofastcoinaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )</span><br><span class="line">sendmany &quot;fromaccount&quot; &#123;&quot;address&quot;:amount,...&#125; ( minconf &quot;comment&quot; )</span><br><span class="line">sendtoaddress &quot;fastcoinaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; )</span><br><span class="line">setaccount &quot;fastcoinaddress&quot; &quot;account&quot;</span><br><span class="line">settxfee amount</span><br><span class="line">signmessage &quot;fastcoinaddress&quot; &quot;message&quot;</span><br></pre></td></tr></table></figure><p>具体的RPC调用可以参考<a href="http://chainquery.com/bitcoin-api" target="_blank" rel="noopener">BitCoin RPC API文档</a>。</p><h1 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6 注意事项"></a>6 注意事项</h1><h2 id="6-1-Boost依赖库引起的报错"><a href="#6-1-Boost依赖库引起的报错" class="headerlink" title="6.1 Boost依赖库引起的报错"></a>6.1 Boost依赖库引起的报错</h2><p>如果在编译FastCoin源码过程中遭遇如下报错信息，则需要我们对FastCoin源码进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/boost/variant/get.hpp:178:5: error: invalid application of <span class="string">'sizeof'</span> to incomplete <span class="built_in">type</span> <span class="string">'boost::STATIC_ASSERTION_FAILURE&lt;false&gt;'</span></span><br><span class="line">     BOOST_STATIC_ASSERT_MSG(</span><br><span class="line">     ^</span><br><span class="line">Makefile:3654: recipe <span class="keyword">for</span> target <span class="string">'libbitcoin_server_a-rpcrawtransaction.o'</span> failed</span><br><span class="line">make[2]: *** [libbitcoin_server_a-rpcrawtransaction.o] Error 1</span><br></pre></td></tr></table></figure><p>将<code>src/rpcrawtransaction.c</code>文件中的第288行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CScriptID&amp; hash = boost::get&lt;<span class="keyword">const</span> CScriptID&amp;&gt;(address);</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CScriptID&amp; hash = boost::get&lt;CScriptID&gt;(address);</span><br></pre></td></tr></table></figure><h2 id="6-2-Berkeley-DB安装问题"><a href="#6-2-Berkeley-DB安装问题" class="headerlink" title="6.2 Berkeley DB安装问题"></a>6.2 Berkeley DB安装问题</h2><p>如果不想对Berkeley DB的源码进行编译安装，还可以直接采用Debian源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:bitcoin/bitcoin</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libdb4.8-dev libdb4.8++-dev</span><br></pre></td></tr></table></figure><h2 id="6-3-nTXConfirmTarget参数"><a href="#6-3-nTXConfirmTarget参数" class="headerlink" title="6.3 nTXConfirmTarget参数"></a>6.3 nTXConfirmTarget参数</h2><p>该参数是确认目标值，用于计算矿工费用，默认值为1，适用于双节点的系统，如需对该参数进行修改。可以在执行<code>./bitcoind</code>时添加参数<code>-txconfirmtarget=number</code>进行配置。</p><h2 id="6-4-txindex参数问题"><a href="#6-4-txindex参数问题" class="headerlink" title="6.4 txindex参数问题"></a>6.4 txindex参数问题</h2><p>如果在<code>~/.fastcoin/fastcoin.conf</code>配置文件中添加了<code>txindex</code>参数，则需要在启动<code>bitcoind</code>时添加启动参数<code>—reindex</code>。</p><h2 id="6-5-图形化界面钱包的构建"><a href="#6-5-图形化界面钱包的构建" class="headerlink" title="6.5 图形化界面钱包的构建"></a>6.5 图形化界面钱包的构建</h2><p>如需使用图形化界面的钱包，需要安装QT并且在<code>./congfiguration</code>时不使用<code>--without-gui</code>选项，FastCoin默认使用QT4：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libqt4-dev libprotobuf-dev protobuf-compiler</span><br></pre></td></tr></table></figure><p>如需使用QT5，需要采用<code>--with-gui=qt5</code>选项，并安装QT5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/08/fastcoin-multinodes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>容错虚拟机分布式系统的设计</title>
      <link>http://blog.luoyuanhang.com/2017/05/20/ftvm-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/05/20/ftvm-notes/</guid>
      <pubDate>Sat, 20 May 2017 07:39:57 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章是我阅读论文《&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/vm-ft.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Design of a Practical System for Fault-Tolerant Virtual Machines&lt;/a&gt;》时的笔记，这篇论文是 VMware 发表的论文，使用虚拟机来设计一个分布式容错系统。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章是我阅读论文《<a href="http://nil.csail.mit.edu/6.824/2017/papers/vm-ft.pdf" target="_blank" rel="noopener">The Design of a Practical System for Fault-Tolerant Virtual Machines</a>》时的笔记，这篇论文是 VMware 发表的论文，使用虚拟机来设计一个分布式容错系统。</p></blockquote><a id="more"></a><p>在分布式系统中，容错方法有很多种，常见的传统方法有：主/副服务器方法（当主服务器宕机之后，由副服务器来接管它的工作），这种方法通常需要机器之间的高带宽。</p><p>另外还有确定（deterministic）状态机方法：将另一台服务器初始化为和主服务器一样的状态，然后让它们都接受到同样的输入，这样它们的状态始终保持一致，但是这种方法对于非确定的（non-deterministic）操作并不适用。</p><p>本文中讨论的方法是使用虚拟机作为状态机，它具有以下优点：</p><ul><li>操作全部被虚拟化</li><li>虚拟机本身就支持 non-deterministic 操作</li><li>虚拟机管理程序（Hypervision）能够记录所有在虚拟机上的操作，所以能够记录主服务器（Primary）所有操作，然后在副服务器（Backup）上进行演绎</li></ul><h1 id="基本设计方案"><a href="#基本设计方案" class="headerlink" title="基本设计方案"></a>基本设计方案</h1><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1ffrt85wk4wj20a50bmdh1.jpg" alt=""></p><p>如图就是本文提到的容错系统的架构，一个 Primary，一个 Backup，Primary 和 Backup 之间通过 Logging Channel 进行通信，Primary 和 Backup 基本保持同步，Backup 稍稍落后，它们两个之间会通过 heartbeat 进行 fail 检测，并且它们使用共享磁盘（Shared Disk）。</p><h2 id="确定（deterministic）操作的演绎"><a href="#确定（deterministic）操作的演绎" class="headerlink" title="确定（deterministic）操作的演绎"></a>确定（deterministic）操作的演绎</h2><p>让两台机器初始状态相同，它们接受相同的输入，顺序相同，两台机器执行的任务的结果就会相同。</p><p>但是如果存在非确定的（non-deterministic）操作（比如中断事件、读取CPU时钟计数器的值操作就是非确定的），它会影响状态机的执行。</p><p>难点在于：</p><ul><li>需要捕捉全部的输入和 non-deterministic 操作在保证 Backup 是deterministic 的</li><li>需要准确将全部输入和 non-deterministic 操作应用到 Backup 中</li><li>需要保证系统高效</li></ul><p>设计方案为：将所有的 input 和 non-deterministic 操作写入到 log 中（file），对于 non-deterministic 操作还要记录和它相关的状态信息等，确保 non-deterministic 操作后Backup状态还是和 Primary 一致</p><h2 id="FT（Fault-Tolerance）协议"><a href="#FT（Fault-Tolerance）协议" class="headerlink" title="FT（Fault-Tolerance）协议"></a>FT（Fault-Tolerance）协议</h2><p>FT 协议是应用于 logging channel 的协议，协议的基本要求为：</p><p>如果 Primary 宕机了，Backup 接替它的工作，Backup 之后向外界发出所有的 Output 要和 Primary 原本应当发送的一致。</p><p>为了保证以上的要求，设计如下系统：</p><ul><li>Primary会在所有关于本次Output 的所有信息都发送给 Backup 之后（并且要确保 Backup 收到）才会把 output 发送给外界</li><li>Primary 只是推迟将 output 发送给外界，而不会暂停执行后边的任务</li></ul><p>流程如图所示：</p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1ffru2zo16dj20if09ddgr.jpg" alt=""></p><p>但是这种方法不能保证 output 只发出一次，如果 primary 宕机了，backup 不能判断它是在发送了 output 之前还是之后宕机的，因此 backup 会再发送一次 output。但是这个问题很容易解决，因为：</p><ul><li>output 是通过网络进行发送的，例如 TCP 之类的网络协议能够检测重复的数据包</li><li>即使 output 被发送了2次其实也没关系。如果 output 是一个写操作，它会在同一个位置写入两次，结果不会发生变化；如果 output 是读取操作，读的内容会被放入 bounce buffer（为了消除 DMA 竞争），数据会在 IO 中断之后被送到</li></ul><h2 id="宕机检测"><a href="#宕机检测" class="headerlink" title="宕机检测"></a>宕机检测</h2><p>如何知道有机器宕机，在该系统中是十分重要的。该设计使用的是UDP heartbeat 机制来检测 Primary 与 Backup 之间的通信是否正常。</p><p>但是使用这种方法会存在裂脑问题（split-brain，Primary 和 Backup 同时宕机），该怎么解决呢？</p><p>该设计中使用了共享存储（Shared Storage），对它的操作是原子的，Primary 和 Backup不能同时进行一个操作（提供原子的 test-and-set 操作）</p><p>如果检测出 Primary 宕机，Backup 会成为 Primary，接替之前的工作，然后再寻找一个 Backup。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="启动-重启-Virtual-Machine"><a href="#启动-重启-Virtual-Machine" class="headerlink" title="启动/重启 Virtual Machine"></a>启动/重启 Virtual Machine</h2><p>如何启动一个和 Primary 状态一样的 Backup？</p><p>VMware Vmotion 操作能够将一台 VM 从一个 Server 完整的迁移到另一个 Server（只需要很短的中断），在该设计中的方法对 Vmotion 做了一点修改，不是进行迁移，而是直接克隆。</p><h2 id="管理-Logging-Channel"><a href="#管理-Logging-Channel" class="headerlink" title="管理 Logging Channel"></a>管理 Logging Channel</h2><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1ffruxtx8wzj20ez0chwfd.jpg" alt=""></p><p>如图，该设计使用了一个大的 buffer，来保存 logging entries，Primary 把自己的 entry 存到 buffer 中，由 logging channel 发送给Backup 的 buffer，然后 Backup 从 buffer 读取命令执行。</p><ul><li>如果 Backup 的 buffer 空了，没有命令执行了，Backup 会等待新的 entry</li><li>如果 Primary 的 buffer 满了，Primary 会等待，等 buffer 中有空余空间再继续执行</li></ul><h2 id="Disk-I-O问题"><a href="#Disk-I-O问题" class="headerlink" title="Disk I/O问题"></a>Disk I/O问题</h2><ol><li><p>disk 操作是并行的，同时对 disk 的同一位置进行操作会导致 non-deterministic</p><p>解决方案：检测 IO 竞争，使这些操作串行执行</p></li><li><p>Disk IO 使用 DMA（Direct Memory Access），同时访问内存同一位置的操作会导致 non-deterministic</p><p>解决方案：对 disk 操作的内存设置内存的页保护，但是这种方法代价太高；该设计中使用了 bounce buffer，它的大小和 disk 所操作的内存部分大小是一致的，read 操作直接将内容读入 buffer，当其他操作完成，写入内存，write 操作将写内容写入 buffer，之后再写入磁盘。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vmware 提出的这种 Primary/Backup 方法是分布式容错方法中非常重要的一部分，可以用在许多系统中，不仅仅是分布式存储（GFS 的容错方法），也可以用在分布式计算中，因为它是将所有的操作都记录下来，将它们重新在 Backup 上进行演绎，从而起到了备份的作用，能够做到容错（Fault-Tolerance）。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/05/20/ftvm-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>GFS 阅读笔记</title>
      <link>http://blog.luoyuanhang.com/2017/05/15/gfs-reading-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/05/15/gfs-reading-notes/</guid>
      <pubDate>Mon, 15 May 2017 13:09:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇博客是我阅读著名的 &lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/gfs.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GFS 论文（The Google File System）&lt;/a&gt;所总结的笔记以及自己一些的思考。这篇论文是一篇非常经典的论文，尤其对于想要了解分布式或者刚刚开始研究分布式的人来说，是一篇非常好的读物，它里面提到了许多分布式方向的基本问题，许多分布式的研究都是围绕这些基本问题的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这篇博客是我阅读著名的 <a href="http://nil.csail.mit.edu/6.824/2017/papers/gfs.pdf" target="_blank" rel="noopener">GFS 论文（The Google File System）</a>所总结的笔记以及自己一些的思考。这篇论文是一篇非常经典的论文，尤其对于想要了解分布式或者刚刚开始研究分布式的人来说，是一篇非常好的读物，它里面提到了许多分布式方向的基本问题，许多分布式的研究都是围绕这些基本问题的。</p><a id="more"></a><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>在了解谷歌文件系统（Google File System）之前，我们必须要了解一下有关分布式系统的一些概念。</p><p><strong>Q1：一致性是什么？</strong></p><p>在分布式文件系统中，很重要的一部分就是数据的复制（replica），为了保证分布式文件系统的高可用性，我们常常会把文件在不同的机器上存储多份，一致性的要求就是保证这些不同机器上的复制品（replicas）能够保持一致。</p><p><strong>Q2：如果只有一个应用程序，它对文件系统进行了一次写操作，这个应用程序在这次写操作之后的读操作会观测到什么呢？</strong></p><p>它会正常观测到它刚刚写入的数据。</p><p><strong>Q3：如果另外多个应用程序执行的读操作呢，它们会观测到什么呢？</strong></p><p>对于弱一致性的模型来说，这次读操作有可能会读取到已经过期的数据；</p><p>对于强一致性的模型来说，读操作读到的始终是上一次写入操作进行完成之后的数据。</p><p>强一致性能保证写入操作，但是它会影响性能（强一致性协议复杂）</p><p><strong>Q4：理想化的一致性模型是怎样的？</strong></p><p>分布式文件系统通过在多个机器上复制文件来保证可用性，在理想化的一致性模型中，在文件系统中所进行的各种操作都要像是在一台机器上进行的操作。实现理想化一致性模型的难点在于处理高并发问题、如何处理分布式集群中的机器崩溃以及达到网络的高效利用，理想化的一致性模型还会出现裂脑问题（split-brain，如果两个存储着相同文件的机器 A，B同时崩溃，其他的机器并不知道是哪一个先崩溃的，所以就不知道该用 A 恢复 B还是用 B 恢复 A）。总之，使用理想化一致性算法会影响性能，并且它的实现非常复杂（例如：Paxos）</p><p>GFS 不是采用的理想化一致性模型，但是它解决了机器崩溃恢复的问题以及能够应对高并发操作同时又能相对高效地利用网络。</p><h1 id="GFS-是什么？"><a href="#GFS-是什么？" class="headerlink" title="GFS 是什么？"></a>GFS 是什么？</h1><p>GFS（Google File System ）是一个大规模分布式文件系统，具有容错的特性（机器崩溃后的处理），并且具有较高性能，能够响应众多的客户端。</p><h2 id="GFS-设计背景"><a href="#GFS-设计背景" class="headerlink" title="GFS 设计背景"></a>GFS 设计背景</h2><ul><li>经常会有机器崩溃（因为机器众多，难免会有机器崩溃）</li><li>有些存储的文件比较大</li><li>append 操作更常见（在文件后追加，而不是 overwrite 覆盖）</li><li>主要包括两种读取 （read）操作：一种是大的顺序读取（单个文件读取几百 KB 甚至是几 MB）；另一种是小的随机读取（在随机位置读取几 KB）</li><li>需要支持并发（例如，多个客户端同时进行 append 操作）</li></ul><h2 id="GFS-所需提供操作"><a href="#GFS-所需提供操作" class="headerlink" title="GFS 所需提供操作"></a>GFS 所需提供操作</h2><p>create（文件创建）、delete（文件删除）、open（打开文件）、close（关闭文件）、read（读取文件）、write（写入文件）、record append（追加文件）、snapshot（快照）。</p><h1 id="GFS-架构"><a href="#GFS-架构" class="headerlink" title="GFS 架构"></a>GFS 架构</h1><p>GFS 的架构由一台 master 服务器和许多台文件服务器（chunkserver）构成，并且有若干客户端（client）与之交互。</p><h2 id="GFS-特点概述"><a href="#GFS-特点概述" class="headerlink" title="GFS 特点概述"></a>GFS 特点概述</h2><ul><li>文件分块（chunks），每块有一个64位标识符（chunk handle），它是在 chunk 被创建时由 master 分配的，每一个 chunk 会有3个备份，分别在不同的机器上。</li><li>Master 存储所有的 metadata，包括命名空间（namespace）、访问控制信息（access control）、文件与 chunk 的映射关系（mapping）以及 chunk 的存储位置</li><li>Master 管理 chunk 租约（lease）、chunk 迁移（如果 chunkserver 挂掉）、chunkserver 之间的通信（heartbeat，它也会向 chunkserver传达master 的命令，chunkserver 通过 heartbeat 向 master 报告自己的状态）</li><li>Client 会和 master 以及 chunkserver 进行交互，client向 master 请求 metadata，然后向 chunkserver 进行读写操作</li><li>client 与 chunkserver 都不会缓存文件数据，为的是防止数据出现不一致的状况。但是 client 会缓存 metadata 的信息（但是会出现一个问题，如果 metadata 过期怎么办呢？GFS 给出了自己的解决方案，也就是租约 lease）</li></ul><h2 id="单一-Master-架构"><a href="#单一-Master-架构" class="headerlink" title="单一 Master 架构"></a>单一 Master 架构</h2><p>GFS 为了简化设计，在整个系统中只有一个 master 进行管理。Master 不提供读写操作，它只会告诉 client，它所请求操作的文件在哪个 chunkserver 上，然后 client 会根据 master 提供的信息，与对应的 chunkserver 进行通信。</p><p>例如：以 client 要进行读取操作为例</p><ol><li>client 将应用程序请求的文件名、大小转化为 chunk index，然后将文件名和 index 发送给 master</li><li>master 返回文件的 chunk handle 和所有该文件备份的位置</li><li>client 将这两个 master 发送给它的信息缓存起来作为 value，文件名和 chunk index 作为 key</li><li>client 向三个备份之一的 chunkserver 发送读请求（选择最近的机器），请求中包含 chunk index 和它要读取的文件的 Byte 范围</li><li>如果 client 缓存的信息没有过期（如何知道是否过期会在后面的文章进行介绍），client 就不用在与 master 进行通信了，以后可以直接与 chunkserver 进行通信</li></ol><h2 id="chunk-大小"><a href="#chunk-大小" class="headerlink" title="chunk 大小"></a>chunk 大小</h2><p>GFS 中将 chunk 的大小定为 64MB，它比一般的文件系统的块大小要大。</p><p>这样做的优点有：</p><ul><li>减少 client 与 master 的交互</li><li>client 可以在一个块上执行更多的操作，通过 TCP 长连接减少网络压力</li><li>减小 metadata 的大小</li></ul><p>但是这样做也存在缺点：</p><ul><li>一个 chunk 可以存更多的小文件了，这样的话如果有一个块存储了许多小文件，client 和它进行操作的几率大大提高，这个 chunk 的压力会很大（然而在实际中，这个问题影响并不大）</li><li>在批处理系统中存在很大问题（如果在一个 chunk 上有一个可执行文件，同时有许多 client 都要请求执行这个文件，它的压力会很大。解决方案是把该文件在不同的 chunkserver 上多添加几个备份，更长久的方案是应该允许 client 去读取其他 client 的文件）</li></ul><h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>GFS 的 metadata 存储着 3 种类型的信息：</p><ul><li>文件名以及 chunk 的名称</li><li>文件与 chunk 的映射关系</li><li>各个备份（replicas）的位置</li></ul><p>Metadata 通常存储于内存中，前两种信息有时会存于磁盘中，它们有时会作为操作记录（operation log）备份的一部分存储于磁盘，备份于远程机器。</p><p>把 metadata 存储于内存有许多优点，查看 metadata 信息时很方便，速度快，有利于 chunk 的垃圾回收（garbage collection）、再备份（re-replication）以及 chunk 迁移（为的是负载均衡）。</p><p>但是如果如果Metadata都存放于内存的话会不会受限于内存的大小呢？</p><p>实际上不会的，因为每一条 metadata 的大小非常小，namespace 信息也很小，并且使用了前缀压缩（prefix compression）进行存储。并且升级内存的花费实际上也很小。</p><h2 id="chunk-位置"><a href="#chunk-位置" class="headerlink" title="chunk 位置"></a>chunk 位置</h2><p>chunk 的位置信息在 master 中不是一成不变的，master 会通过定期的 heartbeat 进行更新，这样做能够减小开销，这样做就不用 master 与 chunkserver 时刻保持同步通信（包括 chunkserver 的加入、退出、改名、宕机、重启等）。chunkserver 上有一个 final word，它表示了哪个 chunk 在它的磁盘上，哪个 chunk 不在。</p><h2 id="操作记录（operation-log）"><a href="#操作记录（operation-log）" class="headerlink" title="操作记录（operation log）"></a>操作记录（operation log）</h2><p>operation log 中包括了 metadata 变更的历史记录</p><ul><li>它是 metadata 的持久化记录，备份于磁盘上</li><li>它表示了并发操作的时间线</li><li>用于 Master 恢复</li></ul><h1 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h1><p>GFS 采用的一致性模型并不是强一致性模型，这是在考虑了各种问题后权衡的结果。</p><p><strong>GFS 是如何保证一致性的？</strong></p><p>有关文件命名空间的操作都是原子的（由 namespace lock 保证）</p><p>我们先来介绍一下 GFS 保证一致性的前提和一些概念：</p><ul><li>如果所有客户端不论从哪一个备份中读取同一个文件，得到的结果都是相同的，那么我们就说这个文件空间是一致的（consistent）</li><li><strong>defined：</strong>如果一个文件区域在经过一系列操作之后依旧是一致的，并且客户端完全知晓对它所做的所有操作，我们就称它为『defined』</li><li>一个操作如果没有被其他并发的写操作影响，那么这个被操作的文件区域是 defined 的</li><li>成功的并发操作也会导致文件区域 undefined，但是一定是一致的（consistent）（客户端有可能只看到了最终一致的结果，但是它并不知道过程）</li><li>失败的并发操作会导致文件区域 undefined，所以一定也是不一致的（inconsistent）</li><li>GFS 并不需要是因为什么导致的 undefined（不区分是哪种 undefined），它只需要知道这个区域是 undefined 还是 defined 就可以</li></ul><p>造成数据改变的操作可能是写入（write）或者追加（record append）：</p><ul><li>write：往应用程序指定的 offset 进行写入</li><li>record append：往并发操作进行过的 offset 处进行写入，这个 offset 是由 GFS 决定的（至于如何决定的后面会有介绍），这个 offset 会作为 defined 区域的起始位置发送给 client。</li><li>“regular” append：对应于 record append 的一个概念，普通的 append 操作通常 offset 指的是文件的末尾，但是在分布式的环境中，offset 就没有这么简单了</li></ul><p><strong>重要问题</strong></p><ol><li>GFS 通过在所有的备份（replicas）上应用顺序相同的操作来保证一个文件区域的 defined（具体细节后面会讨论）</li><li>GFS 会使用 chunk version（版本号）来检测 replicas 是否过期，过期的 replicas 既不会被读取也不会被写入</li><li>GFS 通过握手（handshakes）来检测已经宕机的 chunkserver</li><li>GFS 会通过校验和（checksuming）来检测文件的完整性</li></ol><h1 id="系统间的交互"><a href="#系统间的交互" class="headerlink" title="系统间的交互"></a>系统间的交互</h1><p>这一部分我们来谈谈系统中各个部分之间的交互（master 和 chunkserver、client 和 master、chunkserver 等），GFS 设计的目标是尽可能地让 master 更少的涉及到各种操作中。</p><h2 id="租约（lease）和修改的顺序（mutation-order）"><a href="#租约（lease）和修改的顺序（mutation-order）" class="headerlink" title="租约（lease）和修改的顺序（mutation order）"></a>租约（lease）和修改的顺序（mutation order）</h2><p> Mutation（修改）：mutation 指的是改变了 chunk 的内容或者 metadata，每一次 mutation 都应该作用于所有的备份</p><p>GFS 使用租约机制（lease）来保障 mutation 的一致性：多个备份中的一个持有 lease，这个备份被称为 primary replica（其余的备份为 secondary replicas），GFS 会把所有的 mutation 都序列化（串行化），让 primary 直行，secondary 也按相同顺序执行，primary 是由 master 选出来的。一个 lease 通常60秒会超时。</p><p>现在我们以写操作的数据流程来说明租约机制是如何进行的：</p><ol><li>client 向 master 请求持有 lease 的 chunk（primary replica）位置和其他 replicas 的位置（如果没有 chunk 持有 lease，那么 master 会授予其中一个 replica 一个 lease）</li><li>master 返回 primary 的信息和其他 replicas 的位置，然后 client 将这些信息缓存起来（只有当 primary 无法通信或者该 primary replica 没有 lease 了，client 才会向 master 再次请求）</li><li>client 会将数据发送到所有的 replicas，每个 chunkserver 会把数据存在 LRU 缓存中</li><li>在所有的 replicas 都收到了数据之后，client 会向 primary 发送写请求。primary 会给它所收到的所有 mutation 分配序列号（这些 mutation 有可能不是来自于同一个 client），它会在自己的机器上按序列号进行操作</li><li>primary 给 secondaries 发送写请求，secondaries 会按相同的序列执行操作</li><li>secondaries 告知 primary 操作执行完毕</li><li>primary 向 client 应答，期间的错误也会发送给 client，client 错误处理程序（error handler）会重试失败的 mutation</li></ol><p>其他问题：</p><ul><li>如果一次写操作要写的数据比较大，可能会跨越多个 chunk，GFS client 会把它分为几次小的操作，GFS 支持的最大的操作大小是 chunk 的1/4的大小</li><li><strong>但是如果像上述这么做会出现 undefined 但是 consistent 的区域，这是为什么呢？</strong>GFS 的 record append 操作仅能保证数据在一个原子单位中被写了一次，并不能保证对所有的 replicas 操作的位置都是相同的，比如每次写入的 offset 相同，但是 chunk 有可能不一样</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>GFS 对其数据流的设计目标如下：</p><ul><li>要充分利用网络带宽</li><li>避免网络瓶颈和高延迟</li><li>减少数据流动延迟</li></ul><p>设计方案如下：</p><ul><li>数据以链（chain）的形式 在 chunkserver 之间线性流动（每个机器都在用自己的全部带宽与另外一个机器通信，而不是同时让多个机器分享带宽）</li><li>每个机器会把数据发送到离自己最近的还没有收到数据的机器（GFS 中可以通过机器 IP 地址进行计算）</li><li>通过 TCP 连接将数据传输流水线化（pipelining），pipelining 之所以能够有效果是因为 GFS 的网络是全双工的交换网络</li></ul><h1 id="Snapshot-快照"><a href="#Snapshot-快照" class="headerlink" title="Snapshot 快照"></a>Snapshot 快照</h1><p>GFS 通过 snapshot 来立即创建一个文件或者目录树的备份，它可以用于备份文件或者创建 checkpoint（用于恢复），同时 GFS 把写时复制技术（copy-on-write）引入到了快照操作中，原理与 Linux 进程中的写时复制基本相同。</p><p>当 master 收到 snapshot 操作请求后：</p><ol><li>废除所有的 lease，准备 snapshot（相当于暂停了所有写操作）</li><li>master 记录所有操作，并且将记录写入磁盘</li><li>master 将源文件和目录树的 metadata 进行复制，这样之前的记录就和当前的内存中所保存的状态对应起来了，新建的 snapshot 和源文件指向的会是同一个 chunk</li></ol><h1 id="Master-职责"><a href="#Master-职责" class="headerlink" title="Master 职责"></a>Master 职责</h1><ul><li>执行所有有关于 namespace 的操作</li><li>管理整个系统的 chunk replicas：<ul><li>做出 chunk replicas 的放置决定</li><li>创建 chunk/replicas</li><li>协调各种操作，保证 chunk 被完全复制</li><li>负载均衡</li><li>回收闲置空间</li></ul></li></ul><h2 id="管理-namespace"><a href="#管理-namespace" class="headerlink" title="管理 namespace"></a>管理 namespace</h2><p>在进行快照操作时，lease 会被废除，无法进行写操作，但是 GFS 希望其他 Master 操作不受影响，GFS 采取的方法是使用<strong>namespace 锁</strong>。</p><p>GFS 的namespace 是一个查找表（lookup table），并且采用了前缀压缩的方式存储在内存中，它是一个树结构，namespace 树中的每一个节点（文件名或者目录名）都有一个读/写锁。</p><p>在 Master 对文件或者目录进行操作之前它首先需要获取一个锁，比如要对 /d1/d2/…/dn/leaf 进行操作，需要获得 /d1, /d1/d2, /d1/d2/…/dn的读锁，需要 /d1/d2/…/dn/leaf 的读锁或者写锁（根据不同的操作，锁也不同）</p><p><strong>例如，当/home/user 被快照备份至/save/user 时，如果此时要创建/home/user/foo 会发生什么呢？</strong></p><p>快照操作获得了/home, /save 的读锁和/home/user, /save/user 的写锁。创建/home/user/foo需要/home, /home/user的读锁和/home/user/foo 的写锁。因为两个操作在 /home/user的锁上产生了冲突，所以操作会依次执行，在完成 snapshot 操作之后，释放了/home/user 的写锁， /home/user/foo才会被创建。</p><h2 id="放置-replicas"><a href="#放置-replicas" class="headerlink" title="放置 replicas"></a>放置 replicas</h2><p>如何安置replicas 的目标是：</p><ul><li>最大化数据可靠性和可用性</li><li>最大化网络带宽的利用</li></ul><p><strong>这里的最大化不仅仅是机器间的问题，还要考虑机架间的问题</strong></p><p>在以下3种情况下，Master 会进行创建 replicas 的操作：</p><ul><li>创建了新的 chunk</li><li>需要重新备份</li><li>负载均衡</li></ul><p><strong>如何选择将 replicas放置到哪台机器上呢？</strong></p><ol><li>优先选择磁盘利用率低的 chunkserver</li><li>GFS 会限制每个 chunkserver『最近』创建的次数。换句话说，如果一个 chunkserver 近期创建 replicas 的操作比较频繁，就不会优先选择它（因为创建就意味着以后会进行读取，为了防止突然间大量的读取出现在同一台机器上）</li><li>保证可用性，尽可能跨机架进行创建操作</li></ol><p>当可用的备份低于要求时（GFS 要求为3份），master 会对 chunk 进行重新备份，在以下情况有可能需要重新备份：</p><ul><li>chunkserver 不可用了</li><li>备份损坏了</li><li>硬盘挂掉了</li><li>所要求的最低备份数量提高了</li></ul><p>当有多个 chunk 需要备份时，GFS 如何决定先备份哪个呢？策略如下：</p><ul><li>优先选择可用备份少的</li><li>优先备份最近没有 delete 文件的</li><li>优先备份阻塞了 client 操作的</li></ul><p>当 master 决定了备份哪个之后，会把当前可用的 chunk 直接克隆到目标位置（遵循replicas 放置规则）</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>文件 delete 之后，GFS 并不会立即对空间进行回收，而是等待垃圾回收机制会空间进行释放。</p><p>当文件被删除之后，Master 会想其他操作一样，把删除操作记录下来，但是不进行空间的回收，而是将这块空间命名为 hidden（并且包含被删除时的时间戳），Master 会定期进行扫描，把隐藏了一定时间的文件空间进行回收（这个时间是可以进行配置的），在此期间可以对这块空间的文件进行恢复（直接通过重命名回原来的名称就可以）。</p><p>除此之外，垃圾回收机制还会扫描孤儿 chunk（所有的文件都没有用到的非空 chunk），然后对这块 chunk 的 metadata 进行清除。具体的做法是，在 master 于 chunkserver 的 heartbeat 信息中会携带关于 chunk 的信息，master 会把 metadata 中不存在的 chunk 发送给 chunkserver，chunkserver 会把它拥有的 chunk 发送给 master。</p><h2 id="过期-replica-检测"><a href="#过期-replica-检测" class="headerlink" title="过期 replica 检测"></a>过期 replica 检测</h2><p>chunkserver 宕机或者是 mutation 的丢失会导致 replica 的过期，GFS 是如何对 replicas 进行检测，判断它们是否是最新的呢？</p><p>GFS 对于每一个 chunk 都会有一个版本号，这个版本号由 master 进行管理，通过版本号可以对过期的 replica 进行甄别。当 master 授予 lease 的时候，会增加版本号并且通知所有未过期的 replicas，master 和 replicas 都会记录下最新的版本号（这些操作需要在客户端进行写入操作之前完成）。如果这时，有一个 replica 不可用了，它的版本号就不会再增加了，在 chunkserver 重启或者重新向 master报告它的版本号时，master 就会知道这个 replica 已经过期了，并且会在垃圾回收时将它进行回收。如果 master 的版本号落后了呢，它会更新自己的版本号。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/05/15/gfs-reading-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MapReduce 阅读笔记</title>
      <link>http://blog.luoyuanhang.com/2017/04/19/mapreduce-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/04/19/mapreduce-notes/</guid>
      <pubDate>Wed, 19 Apr 2017 15:54:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇文章是我阅读 &lt;a href=&quot;https://research.google.com/archive/mapreduce-osdi04.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MapReduce 论文：《MapReduce: Simplified Data Processing on Large Clusters》&lt;/a&gt;的笔记，这篇笔记概述了 MapReduce 是什么，它的工作流程，一些细节问题，以及我的个人理解与思考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这篇文章是我阅读 <a href="https://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">MapReduce 论文：《MapReduce: Simplified Data Processing on Large Clusters》</a>的笔记，这篇笔记概述了 MapReduce 是什么，它的工作流程，一些细节问题，以及我的个人理解与思考。</p><a id="more"></a><h1 id="MapReduce-是什么？"><a href="#MapReduce-是什么？" class="headerlink" title="MapReduce 是什么？"></a>MapReduce 是什么？</h1><p>MapReduce 是 Google设计的一种用于大规模数据集的分布式模型，它具有支持并行计算、容错、易使用等特点。它的设计目标如下：</p><ul><li>支持并行</li><li>用于分布式</li><li>能够进行错误处理（比如机器崩溃）</li><li>易于使用（程序员友好）</li><li>负载均衡</li></ul><h1 id="模型流程"><a href="#模型流程" class="headerlink" title="模型流程"></a>模型流程</h1><p>MapReduce 模型主要分为 2 个部分：<strong>Map</strong> 和 <strong>Reduce</strong>。</p><p>在 Map 过程中，Map 函数会获取输入的数据，产生一个临时中间值，它是一个 K/V 对，然后MapReduce Library 会按 Key 值给键值对（K/V）分组然后传递给 Reduce 函数。而后，Reduce 接收到了这些 K/V 对，会将它们合并。</p><p>以论文中的字数统计程序为例：</p><p>现在我们来考虑，如果我们有许多文档，然后我们想要统计在这些文档中每个字出现的次数，现在用 MapReduce 来解决这个问题。Map 函数所做的工作，就是进行分词，产生一组形如下表的 K/V 键值对：</p><table><thead><tr><th>apple</th><th>1</th></tr></thead><tbody><tr><td>apple</td><td>1</td></tr><tr><td>by</td><td>1</td></tr><tr><td>by</td><td>1</td></tr><tr><td>by</td><td>1</td></tr><tr><td>google</td><td>1</td></tr><tr><td>google</td><td>1</td></tr><tr><td>take</td><td>1</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>然后将这组键值对传递给 Reduce，由 Reduce 进行合并。</p><p><strong>具体流程如下：</strong></p><ol><li>由用户程序中调用的 MapReduce Library 将文件分成 M 块（M 要远大于 Map Worker 的数量，每块大小16MB~64MB），此时，进入 MapReduce 过程；</li><li>由 Master 给空闲的 Worker 分配任务，共有 M 个 Map 任务，R 个 Reduce 任务；</li><li>Map Worker 读取文件，将文件处理为 K/V 键值对，K/V 键值对缓存于内存中（此时存在一个问题，如果断电怎么办？往下看后边有解释）；</li><li>将缓存于内存的 K/V 键值对写入磁盘，分成 R 堆（分堆方法有很多种，论文中提到了使用 Hash 散列函数），然后将结果发送给 Master；</li><li>Master 将这些 K/V 键值对的存储地址告知 Reduce，Reduce Worker 通过 RPC（远程过程调用）进行读取，读取完毕之后会根据 Key 值进行排序（这样，相同 Key 值的就会在一起。但是存在一个问题，如果内存不够大，排序该怎么进行？可以使用外部排序）；</li><li>Reduce Worker 将已经排序的结果进行遍历，将每个 Key 值所对应的一组 Value，所组成的  <code>&lt;key, value[num]&gt;</code>传递给用户所编写的 reduce 函数进行处理；</li><li>所有的 Map，Reduce 任务都完成后，告知用户程序，MapReduce 已经结束，返回用户程序。</li></ol><h1 id="容错处理（Fault-Tolerance）"><a href="#容错处理（Fault-Tolerance）" class="headerlink" title="容错处理（Fault-Tolerance）"></a>容错处理（Fault-Tolerance）</h1><p>MapReduce 中的容错处理是非常重要的，因为MapReduce 是运行于分布式环境中的，在分布式环境中经常会有机器出现错误，我们不能让个别机器的错误影响到整体。</p><h2 id="Worker-崩溃"><a href="#Worker-崩溃" class="headerlink" title="Worker 崩溃"></a>Worker 崩溃</h2><p>Master 通过定期给 Worker 发送心跳（heartbeat）来检测 Worker 是否还在正常工作，如果 Worker 无应答或者是应答有误，我们认定它已经宕机（fail）。如果正在工作的 Worker 宕机了，那么运行在它上面的 map 任务会进行初始化（初始状态为 idle，任务还有其他2种状态，in-progress处理中，completed 已完成），重新被分配到正常的 Worker 上。</p><p>如果说 Map Worker 已经完成了一些工作，我们仍然要对运行在它上面的所有任务重新进行分配，这是为什么呢？这里同时可以解决上面的那个问题。因为 Map Worker 处理后的中间结果存在于内存中，或者是 local disk 中，一旦它宕机，这些数据就获取不到了。</p><p>但是对于 Reduce Worker，它完成的任务不用重做，因为它处理后的结果是保存在全局存储中的。</p><p>如果，在 Map Worker A 宕机之后，它所做的任务被重新分配给了 Map Worker B，后边的 Reduce Worker 会被告知，A 已经宕机，要去 B 去读取数据。</p><h2 id="Master-崩溃"><a href="#Master-崩溃" class="headerlink" title="Master 崩溃"></a>Master 崩溃</h2><p>如果说 MapReduce 的 Master 宕机了，又该如何处理呢？</p><p>MapReduce 中的 Master 会定期进行 checkpoint 备份，如果 Master 宕机，会根据之前的 checkpoint 进行恢复，但是恢复期间，MapReduce 任务会中断。</p><h1 id="一些细节问题"><a href="#一些细节问题" class="headerlink" title="一些细节问题"></a>一些细节问题</h1><p><strong>1. 考虑用户编写的 reduce 函数是确定的（deterministic，对于同样的输入执行的结果是一样的），如果有多个 Reduce Worker 都执行了一个 Reduce 任务该怎么办？</strong></p><p>因为用户的 reduce 函数是 deterministic 的，所以即使有多个 Reduce Worker 都执行了同一个任务，但是它们执行的结果都是一样的，并不影响最后的结果。</p><p><strong>2. 如果用户编写的 reduce 函数是不确定（non-deterministic）的呢？</strong></p><p>正是因为 reduce 函数是 non-deterministic 的，本来每次执行的结果也不确定，所以更不会产生影响。</p><p><strong>3. 我们所需要处理的输入文件是如何保存的？</strong></p><p>Input 文件保存于 GFS 中，GFS 会将它们分块保存（每块16MB~64MB），GFS 会对每个文件有3个备份，备份在不同的机器上。</p><p><strong>4. Master 是如何分配任务的？</strong></p><p>遵循就『近』原则，将任务分配给离任务所保存的位置最『近』的 Worker，这里对『近』的定义是网络层面上的，比如说在同一个交换机下的两个机器就是距离『近』的。</p><p><strong>5. MapReduce 是如何做到负载均衡的？</strong></p><p>一开始将文件分块时，分为 M 块，远大于 Map Worker 的数量就有助于负载均衡。同时，这样做还有一个好处，就是当一个 Worker 宕机的时候，可以将任务迅速分配开来，分到多个 Worker 上去。如果 M 比较小，有可能当一个 Worker 宕机时，它的任务不够分配到剩下的 Worker 中，会有 Worker 闲置。</p><p><strong>6. 如何解决 straggler 问题（其他 Worker 都已经完成了自己的任务，但是有一个异常慢的机器，它还有任务没完成，拖慢了整体的速度）？</strong></p><p>MapReduce 有一种机制应对这种情况：MapReduce 会对未完成的任务（in-progress） 定时执行备份执行操作（即，把这些正在某些 Worker 上执行但未完成的任务再次分配给其他 Worker 去执行），不论这个任务被哪个 Worker 完成都会被标记为已完成。</p><p><strong>7. 如果在 Map 任务中有一个 key 特别多，可能会拖慢整个网络的速度，该怎么办？（例如，在字数统计的例子中，the 这个词的数量特别多）</strong></p><p>MapReduce 给用户提供了一个 Combiner 函数，这个函数可以将结果在发送到网络之前进行合并，例如发送键值对&lt;”by”, 3>。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/04/19/mapreduce-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 79. Word Search</title>
      <link>http://blog.luoyuanhang.com/2017/03/26/leetcode-079/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/26/leetcode-079/</guid>
      <pubDate>Sun, 26 Mar 2017 07:54:39 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;https://leetcode.com/problems/word-search/#/description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 79. Word Search.md&lt;/a&gt; 的分析与解法。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章是 <a href="https://leetcode.com/problems/word-search/#/description" target="_blank" rel="noopener">LeetCode 79. Word Search.md</a> 的分析与解法。</p></blockquote><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>For example,</p><p>Given <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>word = <code>ABCCED</code>, -&gt; returns <code>true</code>,</p><p>word = <code>SEE</code>, -&gt; returns <code>true</code>,</p><p>word = <code>ABCB</code>, -&gt; returns <code>false</code>.</p><p>这道题的意思就是在给定的字母板上寻找给定的单词，规则是从一个字母开始垂直或者水平方向上开始寻找，同一个位置的字母只能在路径上经过一次。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>这个问题首先能想到的方法就是暴力搜索，从字母板的(0, 0)位置开始搜索，到(n, n)位置结束。如果在搜索的过程中找到了给定的单词就直接返回。</p><p>以下图为例，假设我们要搜索的单词是『BED』，搜索顺序为『上下左右』：</p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fe095o469sj204q04qglg.jpg" alt=""></p><p>搜索过程如下：</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1fe0afna8e6j20ck0a2jrq.jpg" alt=""></p><ol><li>从(0, 0)位置的 A 开始搜索，A 与给定单词的[0]位置的字母不匹配，到(1, 0)位置；</li><li>(1, 0)位置的 B 与给定单词的[0]位置的字母相同，按照 B 的上下左右的方向依次搜索，已经经过的位置不再搜索；</li><li>搜索至(1,1)位置的 E，与给定单词的[1]的字母相同，按照 E 的上下左右的方向依次搜索，已经经过的位置不再搜索；</li><li>直到搜索到 D，完成 BED 的搜索，返回。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == <span class="number">0</span> || word.length() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || y &gt;= board[x].size() || x &gt;= board.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] != word[pos])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[x][y];</span><br><span class="line">        board[x][y] = <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> result = search(board, word, x<span class="number">-1</span>, y, pos+<span class="number">1</span>)</span><br><span class="line">        || search(board, word, x+<span class="number">1</span>, y, pos+<span class="number">1</span>)</span><br><span class="line">        || search(board, word, x, y+<span class="number">1</span>, pos+<span class="number">1</span>)</span><br><span class="line">        || search(board, word, x, y<span class="number">-1</span>, pos+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        board[x][y] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本文的完整代码详见<a href="https://github.com/luoyhang003/leetcode" target="_blank" rel="noopener">我的 GitHub</a></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/26/leetcode-079/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 131. Palindrome Partitioning</title>
      <link>http://blog.luoyuanhang.com/2017/03/24/leetcode-131/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/24/leetcode-131/</guid>
      <pubDate>Fri, 24 Mar 2017 08:08:47 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;https://leetcode.com/problems/palindrome-partitioning/#/description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 131. Palindrome Partitioning&lt;/a&gt; 的分析与解法。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章是 <a href="https://leetcode.com/problems/palindrome-partitioning/#/description" target="_blank" rel="noopener">LeetCode 131. Palindrome Partitioning</a> 的分析与解法。</p></blockquote><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>, Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这道题的意思就是将给定的字符串分成回文串的组合，就像例子中所说，<code>aab</code>有两种回文串组合：<code>aa</code>,<code>b</code>和<code>a</code>,<code>a</code>,<code>b</code>.</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>对于这个问题，我们很简单的将它分解为两个子问题：</p><ul><li>拆分字符串</li><li>判断一个字符串是否是回文串</li></ul><h2 id="Step-1-判断回文字符串"><a href="#Step-1-判断回文字符串" class="headerlink" title="Step 1 判断回文字符串"></a>Step 1 判断回文字符串</h2><p>如果一个字符串正读和反读结果都一样，我们就说它是一个回文字符串。判断一个字符串是不是回文的有很多种方法，我想起来 3 种方法，都会在接下来的文章中进行介绍，并给出源码（文中的代码皆为 C++）。</p><h3 id="反转字符串法"><a href="#反转字符串法" class="headerlink" title="反转字符串法"></a>反转字符串法</h3><p>这个方法是最容易理解的，将字符串反转，如果和原来的字符串一样，那么它就是回文的，这个方法在编码上也是最简单的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome_reverse</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> r = s;</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    <span class="keyword">if</span>(s.compare(r)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法是通过两个指针，一个指向字符串首，另一个指向字符串尾，如果两个指针指向的字符相同，则两个指针向中间移动，继续判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome_doublepoints</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归法和双指针法很类似，当前字符串是否回文取决于首尾字符是否相同，然后递归的判断除去首尾的剩余字符串是否回文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome_recursion</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome_recursion(s, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-2-拆分字符串"><a href="#Step-2-拆分字符串" class="headerlink" title="Step 2 拆分字符串"></a>Step 2 拆分字符串</h2><p>这一步是这个问题的关键，解决拆分字符串的方案也有 2 种：<strong>暴力回溯法</strong> 和 <strong>递归法</strong>。</p><h3 id="暴力回溯法"><a href="#暴力回溯法" class="headerlink" title="暴力回溯法"></a>暴力回溯法</h3><p>暴力回溯法比较好理解，它使用的是回溯法的思想，我们穷举出来字符串的所有子串组合，然后判断其中的子串是不是回文的，去掉不符合要求的组合，剩余的就是我们要的结果。</p><p>在进行穷举的时候，如果遇到不是回文的子串，我们就进行回溯。</p><p>以题目中的<code>aab</code>为例：</p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1fdxz57h7m7j20pk0c6my6.jpg" alt=""></p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;vec, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;temp, <span class="built_in">string</span> s, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        vec.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">                temp.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                backtrace(vec, temp, s, i+<span class="number">1</span>);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>递归法的思路是把一个字符串分为 A+B，如果 A 为回文则递归的求 B 的回文组合，然后将 A 和 B 的回文串组合做笛卡尔积。</p><p>以字符串 aabb 为例：</p><ol><li>将aabb 分为 a+abb，然后求 abb 的回文组合为[a, b, b], [a, bb]，所以做笛卡尔积后为：[a, a, b,b ], [a, a, bb]</li><li>将字符串分为 aa+bb，然后求 bb 的回文组合为[b, b], [bb],结果为[aa, b, b], [aa, bb]</li><li>将字符串分为 aab+b，aab 不回文</li><li>aabb 回文，结果为[aabb]</li><li>最终结果为：[a, a, b,b ], [a, a, bb], [aa, b, b], [aa, bb], [aabb]</li></ol><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition_recursion(<span class="built_in">string</span> s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isPalindrome_recursion(s, <span class="number">0</span>, s.length()<span class="number">-1</span>))&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        temp.push_back(s);</span><br><span class="line">        vec.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> left = s.substr(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(left, <span class="number">0</span>, left.length()<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="built_in">string</span> right = s.substr(i, s.length()-i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; rightVec = partition_recursion(right);</span><br><span class="line">            <span class="keyword">if</span>(rightVec.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rightVec.size(); j++)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">                    temp.push_back(left);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; rightVec[j].size(); x++)&#123;</span><br><span class="line">                        temp.push_back(rightVec[j][x]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    vec.push_back(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h1><p>将几种方法组合后的测试结果如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">反转字符串法</th><th style="text-align:center">双指针法</th><th style="text-align:center">递归法</th></tr></thead><tbody><tr><td style="text-align:center">暴力回溯法</td><td style="text-align:center">16 ms</td><td style="text-align:center"><strong>13 ms</strong></td><td style="text-align:center"><strong>13 ms</strong></td></tr><tr><td style="text-align:center">递归法</td><td style="text-align:center">89 ms</td><td style="text-align:center">76 ms</td><td style="text-align:center">76 ms</td></tr></tbody></table><p>我们看到回溯法要明显优于递归的方法。</p><p>本文的完整代码详见<a href="https://github.com/luoyhang003/leetcode" target="_blank" rel="noopener">我的 GitHub</a></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/24/leetcode-131/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【从0到1学习Java线程池】一个Java线程池的简单实现</title>
      <link>http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/</guid>
      <pubDate>Wed, 15 Mar 2017 12:08:21 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这是【从0到1学习Java线程池】系列文章的第 叁 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章实现了一个简单的 Java 线程池。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这是【从0到1学习Java线程池】系列文章的第 叁 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章实现了一个简单的 Java 线程池。</p></blockquote><a id="more"></a><p>【从0到1学习Java线程池】系列文章共有3篇，目录如下：</p><ul><li><a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a></li><li><a href="http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/">【从0到1学习Java线程池】Java线程池原理</a></li><li><a href="http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/">【从0到1学习Java线程池】一个Java线程池的简单实现</a></li></ul><p>从上两篇文章中，我们已经知道了线程池的基本原理，这篇文章我们就来具体实现一个简单的 Java 线程池。</p><h1 id="设计先行"><a href="#设计先行" class="headerlink" title="设计先行"></a>设计先行</h1><p>想要实现一个线程池，我们首先要来进行设计，考虑它需要有哪些功能，如何设计和安排这些功能是至关重要的。</p><p>在我们所要实现的 Java 线程池需要有：</p><ul><li>任务队列：它能够添加或者删除任务，并且它还需要支持原子操作，不能同时有多个线程从中取出任务。</li><li>通知机制：如果任务队列为空，工作线程将会阻塞在获取任务这一操作上；如果这时任务队列中有了新的任务，需要通知工作线程从中获取任务来执行。</li><li>线程类：线程类的例程是用来获取任务和执行任务的。</li><li>任务类：用于被线程抓取和执行的任务。</li><li>线程管理类：能够创建一定数量的线程，并且提供对任务队列进行操作的方法（获取任务、添加任务等）。</li></ul><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="系统配置类"><a href="#系统配置类" class="headerlink" title="系统配置类"></a>系统配置类</h2><p>其中的参数主要是该线程池所支持的最大线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemConfig</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_POOL_MAX_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadDefalutSize</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> THREAD_POOL_MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程管理类"><a href="#线程管理类" class="headerlink" title="线程管理类"></a>线程管理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolManager</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isThreadPoolValid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sizeOfPoolThread = SystemConfig.getThreadDefalutSize();</span><br><span class="line"></span><br><span class="line">List&lt;Task&gt; taskList= <span class="keyword">new</span> LinkedList&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolManager</span><span class="params">(String threadpoolname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(threadpoolname);</span><br><span class="line">setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sizeOfPoolThread == <span class="number">0</span> || isThreadPoolValid != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception exception)&#123;</span><br><span class="line">exception.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeOfPoolThread; i++)&#123;</span><br><span class="line"><span class="keyword">new</span> WorkThread(i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isThreadPoolValid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stopThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sizeOfPoolThread == <span class="number">0</span> || isThreadPoolValid != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception exception)&#123;</span><br><span class="line">exception.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskList.clear();</span><br><span class="line">sizeOfPoolThread = <span class="number">0</span>;</span><br><span class="line">isThreadPoolValid = <span class="number">0</span>;</span><br><span class="line">interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Task newTask)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskList.add(newTask);</span><br><span class="line"></span><br><span class="line">notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Task <span class="title">getTask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(taskList.size() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> taskList.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(<span class="keyword">int</span> threadID)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(ThreadPoolManager.<span class="keyword">this</span>, <span class="string">""</span>+threadID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">Task runTask = getTask();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(runTask == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">runTask.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><strong>测试任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.i = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Task "</span> + i + <span class="string">" is RUNNING."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPoolManager manager = <span class="keyword">new</span> ThreadPoolManager(<span class="string">"SimplePool"</span>);</span><br><span class="line">manager.startThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">Task task = <span class="keyword">new</span> TestTask(i);</span><br><span class="line">manager.addTask(task);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task 3 is RUNNING.</span><br><span class="line">Task 4 is RUNNING.</span><br><span class="line">Task 1 is RUNNING.</span><br><span class="line">Task 0 is RUNNING.</span><br><span class="line">Task 2 is RUNNING.</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《创新的洞见》短评&amp;书摘</title>
      <link>http://blog.luoyuanhang.com/2017/03/13/insight-in-innovation/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/13/insight-in-innovation/</guid>
      <pubDate>Mon, 13 Mar 2017 15:16:20 GMT</pubDate>
      <description>
      
        《创新的洞见》这本书是2016年年初出版的，其中写的好多是2015年互联网世界发生的事情，而我却是在2017年年初才看完的这本书，有些内容不免有些过时，因为在近几年中我国互联网世界的发展速度令人叹为观止，这个世界的变化天翻地覆。但是此书中的不少内容不失为经典，在书中的一些报告中，有许多创业者等等对当时未来的发展做出了预测，有些在两年后的今天看来十分准确，有些就显得有比较大的偏差了。但是，不论如何这些都是对创业者们十分有益、宝贵的阅读资料。当然了，由于书中选择了众多领域的不同人的文章或是报告，其中内容良莠不齐。
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h1><p>《创新的洞见》这本书是2016年年初出版的，其中写的好多是2015年互联网世界发生的事情，而我却是在2017年年初才看完的这本书，有些内容不免有些过时，因为在近几年中我国互联网世界的发展速度令人叹为观止，这个世界的变化天翻地覆。但是此书中的不少内容不失为经典，在书中的一些报告中，有许多创业者等等对当时未来的发展做出了预测，有些在两年后的今天看来十分准确，有些就显得有比较大的偏差了。但是，不论如何这些都是对创业者们十分有益、宝贵的阅读资料。当然了，由于书中选择了众多领域的不同人的文章或是报告，其中内容良莠不齐。</p><h1 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h1><ul><li>实际上以利润换市场无异于饮鸩止渴，最终会陷入不烧钱数据下降，烧钱又难以为继的两难，甚至不得不为了烧钱而损害未来的利益。</li></ul><ul><li>仓廪实而知礼节，衣食足而知荣辱，如果一个成年人日日为填饱肚子忙活，那就不要指望未来能有多大的空间。企业也是一样，当受制于资金支持随时可能断炊时，企业唯一能做的只有活下来，而不是过更好。</li><li>在特定时期VC可以让企业催熟、早产，甚至也不排除考虑杀鸡取卵。</li><li>BAT投资无外乎四种：<ol><li>现有业务互补；</li><li>新兴业务布局；</li><li>财务投资；</li><li>抹杀创新，消除竞争。</li></ol></li><li>最基本创业的初始点还是满足用户的需求，但是这样一个简简单单的一句话包含了三层意思，就是什么是用户的需求，谁是你的用户，以及怎么满足。除此之外，也是结合爱乐活的经验，有三点：<ul><li>第一点，团队极其重要。</li><li>第二点，时机。</li><li>第三点，产品是最重要的。</li></ul></li><li>我们犯的错误都是来自于对你内心里面相信的东西，是否有足够的坚定、坚持以及决心，还是说会过于犹豫，会迫于压力和利益，最后选择了妥协。</li><li>这个世界从不在乎你输入了什么，而在乎你输出了什么。</li><li>移动互联网和我们可以预见的可穿戴设备像一只吸血鬼，它让每个人都可以消费有价值的内容，而从不产生任何有价值的内容。</li><li>白花花的银子背后是钢铁般的团队，钢铁般的团队背后是老大金子般的人品。</li><li>黑塞说：“对于每个人而言，真正的职责只有一个：找到自我，然后在心中坚守其一生，全心全意，永不停息。所有其他的路都是不完整的，是人的逃避方式，是对大众期望的懦弱回归，是随波逐流，是对内心的恐惧。”你最怕的人，其实是你自己。</li><li>元数据是描述数据属性的集合，是对数据的说明,比如，数据的类型、名称、字段等。</li><li>数据与元数据可以这样来区别，前者是内容，后者是背景。背景常常比内容显示更多的信息，尤其是把元数据集合起来的时候。</li><li>互联网的流量变现的三个途径：<strong>广告、游戏和电子商务</strong>。</li><li>一对多是追求效率的提升，追求规模的最大化才能赚到钱。而一对一是追求个性化的匹配，因为打败极致效率的唯一方法就是个性化。</li><li>一鱼多吃，就是拿入口向产业链的上下游的延伸；一鱼三吃，就是锁定同样的人群，满足他们不同的跨行业的需求，表面跨行业，但是相对顺理成章。</li></ul><ul><li>理想的组织永远在跟着组织目标走，如果需要颗粒度更密集，那就把组织单位更加细小；如果发生阶段性变化，那适度弹性的组织更能胜任。其中，快速沟通和响应机制是必须的，尤其在瞬息万变的互联网行业。既然目标很难量化，那招合适的人适度放权就是一个必须的选择。</li><li>巨头试图通过扶植代理人的形式扩大制定游戏规则的边界，而那些倍受期许的独立势力正在左右逢源争取更高的收编价码。</li></ul><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/13/insight-in-innovation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【从0到1学习Java线程池】Java线程池原理</title>
      <link>http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/</guid>
      <pubDate>Mon, 27 Feb 2017 12:16:45 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这是【从0到1学习Java线程池】系列文章的第 贰 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章介绍了 Java 线程池的原理。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这是【从0到1学习Java线程池】系列文章的第 贰 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章介绍了 Java 线程池的原理。</p></blockquote><a id="more"></a><p>【从0到1学习Java线程池】系列文章共有3篇，目录如下：</p><ul><li><a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a></li><li><a href="http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/">【从0到1学习Java线程池】Java线程池原理</a></li><li><a href="http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/">【从0到1学习Java线程池】一个Java线程池的简单实现</a></li></ul><p>在上一篇文章中（<a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a>），我们总结了线程池的3个优点：</p><ul><li>线程复用</li><li>控制最大并发数</li><li>管理线程</li></ul><p>这篇文章会分别从这三个方面，结合具体的代码实现来剖析 Java 线程池的原理以及它的具体实现。</p><h1 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h1><p>我们知道线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用。这个功能就是线程复用。想要了解 Java 线程池是如何进行线程复用的，我们首先需要了解线程的生命周期。</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>下图描述了线程完整的生命周期：</p><p><img src="http://ww2.sinaimg.cn/mw690/4858d6a8jw1eu8b93kem2j20pb0dndl8.jpg" alt=""></p><p>在一个线程完整的生命周期中，它可能经历五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、终止（Zombie）。</p><p>在 Java中，Thread 通过new来新建一个线程，这个过程是是初始化一些线程信息，如线程名、id、线程所属group等，可以认为只是个普通的对象。调用Thread的<code>start()</code>后Java虚拟机会为其创建方法调用栈和程序计数器，同时将<code>hasBeenStarted</code>为true，之后如果再次调用<code>start()</code>方法就会有异常。</p><p>处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于 JVM 里线程调度器的调度。当线程获取CPU后，<code>run()</code>方法会被调用。不要自己去调用Thread的<code>run()</code>方法。之后根据CPU的调度，线程就会在<strong>就绪—运行—阻塞</strong>间切换，直到<code>run()</code>方法结束或其他方式停止线程，进入终止状态。</p><p>因此，如果要实现线程的复用，我们必须要保证线程池中的线程保持存活状态（就绪、运行、阻塞）。接下来，我们就来看看<code>ThreadPoolExecutor</code>是如何实现线程复用的。</p><h2 id="Worker-类"><a href="#Worker-类" class="headerlink" title="Worker 类"></a>Worker 类</h2><p><code>ThreadPoolExecutor</code>主要是通过一个类来控制线程复用的：Worker 类。</p><p>我们来看一下简化后的 Worker 类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">Runnable firstTask;</span><br><span class="line"></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line"><span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line"><span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">Runnable task = w.firstTask;</span><br><span class="line">w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">task.run();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以看到 Worker 实现了 Runnable 接口，并且它还有一个 Thread成员变量 thread，这个 thread 就是要开启运行的线程。我们看到 Worker 的构造方法中传递了一个 Runnable 参数，同时它把自己作为参数传入 <code>newThread()</code>，这样的话，当 Thread 的<code>start()</code>方法得到调用时，执行的其实是 Worker 的<code>run()</code>方法，即<code>runWorker()</code>方法。</p><p><code>runWorker()</code>方法之中有一个 while 循环，使用 <code>getTask()</code>来获取任务，并执行。接下来，我们将会看到<code>getTask()</code>是如何获取到 Runnable 对象的。</p><h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h2><p>我们来看一下简化后的<code>getTask()</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(一些特殊情况) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Runnable r = workQueue.take();</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到任务是从 workQueue中获取的，这个 workQueue 就是我们初始化 ThreadPoolExecutor 时存放任务的 BlockingQueue队列，这个队列里的存放的都是将要执行的 Runnable任务。因为 BlockingQueue 是个阻塞队列，<code>BlockingQueue.take()</code>返回的是空，则进入等待状态直到 BlockingQueue 有新的对象被加入时唤醒阻塞的线程。所以一般情况下，Thread的run()方法不会结束，而是不断执行workQueue里的Runnable任务，这就达到了线程复用的目的了。</p><h1 id="控制最大并发数"><a href="#控制最大并发数" class="headerlink" title="控制最大并发数"></a>控制最大并发数</h1><p>我们现在已经知道了 Java 线程池是如何做到线程复用的了，但是Runnable 是什么时候被放入 workQueue 队列中的呢，Worker里的Thread的又是什么时候调用<code>start()</code>开启新线程来执行Worker的run()方法的呢？从上面的分析中我们可以看出Worker里的<code>runWorker()</code>执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？它又是如何做到控制最大并发数的呢？</p><h2 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h2><p>通过查看 <code>execute()</code>就能解答上述的一些问题，同样是简化后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">// 当前线程数 &lt; corePoolSize</span></span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">// 直接启动新的线程。</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 活动线程数 &gt;= corePoolSize</span></span><br><span class="line">  <span class="comment">// runState为RUNNING &amp;&amp; 队列未满</span></span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="comment">// 再次检验是否为RUNNING状态</span></span><br><span class="line">    <span class="comment">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">      reject(command);</span><br><span class="line">    <span class="comment">// 采用线程池指定的策略拒绝任务</span></span><br><span class="line">    <span class="comment">// 两种情况：</span></span><br><span class="line">    <span class="comment">// 1.非RUNNING状态拒绝新的任务</span></span><br><span class="line">    <span class="comment">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker()"></a>addWorker()</h2><p>我们再来看一下<code>addWorker()</code>的简化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">  <span class="keyword">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">  <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">  t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，线程池工作过程中是如何添加任务的就很清晰了：</p><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException</li></ul><p>如果通过<code>addWorker()</code>成功创建新的线程，则通过<code>start()</code>开启新线程，同时将firstTask作为这个Worker里的<code>run()</code>中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以可以根据corePoolSize和maximumPoolSize来控制最大并发数。</p><p>过程如下图所示：</p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fd5ahj8k2sj20nu0dl0tu.jpg" alt=""></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>如果是做 Android 开发的，并且对 Handler 原理比较熟悉，你可能会觉得这个图挺熟悉，其中的一些过程和Handler，Looper，Meaasge使用中，很相似。<code>Handler.send(Message)</code>相当于<code>execute(Runnuble)</code>，Looper中维护的Meaasge队列相当于BlockingQueue，只不过需要自己通过同步来维护这个队列，Looper中的<code>loop()</code>函数循环从Meaasge队列取Meaasge和Worker中的<code>runWork()</code>不断从BlockingQueue取Runnable是同样的道理。</p><h1 id="管理线程"><a href="#管理线程" class="headerlink" title="管理线程"></a>管理线程</h1><p>上边的文章已经讲了，通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程，而线程的管理过程已经穿插在其中了，也很好理解。</p><p>在 ThreadPoolExecutor 有个AtomicInteger变量 ctl，这一个变量保存了两个内容：</p><ul><li>所有线程的数量</li><li>每个线程所处的状态</li></ul><p>其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到线程的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Worker的的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程是否在运行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &lt; SHUTDOWN; &#125;</span><br></pre></td></tr></table></figure><p>这里主要通过shutdown和shutdownNow()来分析线程池的关闭过程。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：</p><ul><li><strong>RUNNING状态：</strong>线程池正常运行，可以接受新的任务并处理队列中的任务；</li><li><strong>SHUTDOWN状态：</strong>不再接受新的任务，但是会执行队列中的任务；</li><li><strong>STOP状态：</strong>不再接受新任务，不处理队列中的任务</li></ul><p><code>shutdown()</code>这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务人会被执行；<code>shutdownNow()</code>方法将runState置为STOP。和<code>shutdown()</code>方法的区别是，这个方法会终止所有的线程，所以队列中的任务也不会被执行了。</p><p><strong>参考资料：</strong><a href="http://www.kuqin.com/shuoit/20160829/352799.html" target="_blank" rel="noopener">http://www.kuqin.com/shuoit/20160829/352799.html</a></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【从0到1学习Java线程池】Java线程池的简介以及使用</title>
      <link>http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/</guid>
      <pubDate>Sun, 26 Feb 2017 13:39:50 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这是【从0到1学习Java线程池】系列文章的第 壹 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章主要介绍了 Java 线程池以及它的使用。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这是【从0到1学习Java线程池】系列文章的第 壹 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章主要介绍了 Java 线程池以及它的使用。</p></blockquote><a id="more"></a><p>【从0到1学习Java线程池】系列文章共有3篇，目录如下：</p><ul><li><a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a></li><li><a href="http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/">【从0到1学习Java线程池】Java线程池原理</a></li><li><a href="http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/">【从0到1学习Java线程池】一个Java线程池的简单实现</a></li></ul><h1 id="线程池是什么？"><a href="#线程池是什么？" class="headerlink" title="线程池是什么？"></a>线程池是什么？</h1><p>线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><h2 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h2><p>在面向对象的编程过程中，创建对象和销毁对象是非常消耗时间和资源的。因此想要最小化这种消耗的一种思想就是『池化资源』。线程池就是这样的一种思想。我们通过重用线程池中的资源来减少创建和销毁线程所需要耗费的时间和资源。</p><p>线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用；另一个作用是可根据系统情况调整执行的线程数量，防止消耗过多内存。另外，通过线程池，能有效的控制线程的最大并发数，提高系统资源利用率，同时避免过多的资源竞争，避免堵塞。</p><p><strong>线程池的优点总结如下几个方面：</strong></p><ul><li>线程复用</li><li>控制最大并发数</li><li>管理线程</li></ul><h2 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h2><p>一般的线程池主要分为以下4个组成部分：</p><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><h2 id="线程池的常见应用场景"><a href="#线程池的常见应用场景" class="headerlink" title="线程池的常见应用场景"></a>线程池的常见应用场景</h2><p>许多服务器应用常常需要处理大量而短小的请求（例如，Web 服务器，数据库服务器等等），通常它们收到的请求数量很大，一个简单的模型是，当服务器收到来自远程的请求时，为每一个请求开启一个线程，在请求完毕之后再对线程进行销毁。这样处理带来的问题是，创建和销毁线程所消耗的时间往往比任务本身所需消耗的资源要大得多。那么应该怎么办呢？</p><p>线程池为线程生命周期开销问题和资源不足问题提供了解决方案。我们可以通过线程池做到线程复用，不需要频繁的创建和销毁线程，让线程池中的线程一直存在于线程池中，然后线程从任务队列中取得任务来执行。而且这样做的另一个好处有，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。</p><h1 id="Java线程池的简介"><a href="#Java线程池的简介" class="headerlink" title="Java线程池的简介"></a>Java线程池的简介</h1><p>Java中提供了实现线程池的框架Executor，并且提供了许多种类的线程池，接下来的文章中将会做详细介绍。</p><h2 id="Java线程池框架"><a href="#Java线程池框架" class="headerlink" title="Java线程池框架"></a>Java线程池框架</h2><p>Java中的线程池是通过Executor框架实现的，该框架中用到了<code>Executor</code>，<code>Executors</code>，<code>ExecutorService</code>，<code>ThreadPoolExecutor</code> ，<code>Callable</code>和<code>Future</code>、<code>FutureTask</code>这几个类。</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1fd45pk52lqj20ru0hvjtt.jpg" alt=""></p><ul><li>Executor：所有线程池的接口，只有一个方法</li><li>Executors：Executor 的工厂类，提供了创建各种不同线程池的方法，返回的线程池都实现了ExecutorService 接口</li><li>ThreadPoolExecutor：线程池的具体实现类，一般所有的线程池都是基于这个类实现的</li></ul><p>其中<code>ThreadPoolExecutor</code>的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>corePoolSize：线程池的核心线程数，线程池中运行的线程数也永远不会超过 corePoolSize 个，默认情况下会永远存活</li><li>maximumPoolSize：线程池中允许的最大线程数</li><li>keepAliveTime：空闲线程结束的超时时间</li><li>unit：是一个枚举，它表示的是 keepAliveTime 的单位</li><li>workQueue：工作队列，用于任务的存放</li></ul><h2 id="Java线程池的工作过程"><a href="#Java线程池的工作过程" class="headerlink" title="Java线程池的工作过程"></a>Java线程池的工作过程</h2><p>Java线程池的工作过程如下：</p><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ol><h2 id="常见的Java线程池"><a href="#常见的Java线程池" class="headerlink" title="常见的Java线程池"></a>常见的Java线程池</h2><p>生成线程池使用的是Executors的工厂方法，以下是常见的 Java 线程池：</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor是单个线程的线程池，即线程池中每次只有一个线程在运行，单线程串行执行任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,</span><br><span class="line">  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool是固定数量的线程池，只有核心线程，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列，直到前面的任务完成才继续执行。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是可缓存线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。其中，SynchronousQueue是一个是缓冲区为1的阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,</span><br><span class="line">  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>ScheduledThreadPool是核心线程池固定，大小无限制的线程池，支持定时和周期性的执行线程。创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在<code>DEFAULT_KEEPALIVEMILLIS</code>时间内回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPool(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">   DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">   <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-线程池的创建和使用"><a href="#Java-线程池的创建和使用" class="headerlink" title="Java 线程池的创建和使用"></a>Java 线程池的创建和使用</h1><p>我们可以通过Executors的工厂方法来创建一个线程池。但是我们该如何让线程池执行任务呢？</p><p>线程池最常用的提交任务的方法有两种：</p><ul><li><p>execute：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService.execute(Runnable runable)；</span><br></pre></td></tr></table></figure></li><li><p>submit：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask task = ExecutorService.submit(Runnable runnable);</span><br><span class="line">FutureTask&lt;T&gt; task = ExecutorService.submit(Runnable runnable,T Result);</span><br><span class="line">FutureTask&lt;T&gt; task = ExecutorService.submit(Callable&lt;T&gt; callable);</span><br></pre></td></tr></table></figure></li></ul><p>可以看出<code>submit</code>开启的是有返回结果的任务，会返回一个<code>FutureTask</code>对象，这样就能通过<code>get()</code>方法得到结果。<code>submit</code>最终调用的也是<code>execute(Runnable runable)</code>，<code>submit</code>只是将<code>Callable</code>对象或<code>Runnable</code>封装成一个<code>FutureTask</code>对象，因为<code>FutureTask</code>是个<code>Runnable</code>，所以可以在<code>execute</code>中执行。</p><p>下面的示例代码演示了如何创建一个线程池，并且使用它管理线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" is running."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleThreadExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//创建实现了Runnable接口对象</span></span><br><span class="line">        Thread tt1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt5 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//将线程放入池中并执行</span></span><br><span class="line">        pool.execute(tt1);</span><br><span class="line">        pool.execute(tt2);</span><br><span class="line">        pool.execute(tt3);</span><br><span class="line">        pool.execute(tt4);</span><br><span class="line">        pool.execute(tt5);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 is running.</span><br><span class="line">pool-1-thread-2 is running.</span><br><span class="line">pool-1-thread-1 is running.</span><br><span class="line">pool-1-thread-2 is running.</span><br><span class="line">pool-1-thread-1 is running.</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://www.luoyuanhang.com" target="_blank" rel="noopener">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>山东大学人工智能课程复习提要（2017）</title>
      <link>http://blog.luoyuanhang.com/2017/02/03/AI-sdu-2016-summary/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/03/AI-sdu-2016-summary/</guid>
      <pubDate>Fri, 03 Feb 2017 06:40:14 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;本篇博客为山东大学人工智能课程（2016-2017）的复习提要，希望对大家的考试复习有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本篇博客为山东大学人工智能课程（2016-2017）的复习提要，希望对大家的考试复习有所帮助。</p></blockquote><a id="more"></a><h2 id="填空部分"><a href="#填空部分" class="headerlink" title="填空部分"></a>填空部分</h2><ol><li>构成产生式系统的基本元素有<u>综合数据库</u>、<u>规则库</u>、<u>控制系统</u>，控制策略按执行规则的方式分类，分为<u>正向</u>、<u>逆向</u>、<u>双向</u>三类。</li><li>归结过程中控制策略的作用是给出控制策略，以使仅对选择合适的子句间方可做归结，避免<u>多余的、不必要的归结式出现</u>。常见的控制策略有<u>线性归结策略</u>、<u>支持集策略</u>、<u>单元归结策略</u>、<u>输入归结</u>策略。</li><li>公式 G 和公式的子句集并不等值，但他们在<u>不可满足</u>的意义下是一致的。</li><li>与或图的启发式搜索算法 <u>AO*算法</u>的两个过程分别是<u>分解（将复杂的大问题分解为一组简单的小问题）</u>和<u>变换（将较难问题变换为较容易的等价的或等效的问题）</u></li><li>人工智能的研究途径主要有两种不同的观点，一种观点称为<u>符号主义</u>，认为人类智能基本单元是<u>符号</u>。另一种观点称为<u>连接主义</u>，认为职能的基本单元是<u>神经元</u>。</li><li>集合{P(a, x, f(g(y)), P(z, f(z), f(u)))} 的 mgu（最一般合一置换）为 <u>{z/a, f(x)/x, u/g(y)}</u>。</li><li>语义网络是对知识的<u>有向图</u>表示方法，一个最简单的语义网络是一个形如<u>节点</u>、<u>弧</u>、<u>节点</u>的三元组，语义网络可以描述事物间多种复杂的语义关系，常用 ISA、AKO 弧表示节点间具有<u>类属</u>的分类关系。语义网络下的推理是通过<u>匹配、继承</u>实现的。</li><li>当前人工智能研究的热点之一就是机器学习。常见的机器学习方法课分为<u>决策树学习</u>、<u>神经网络</u>、<u>蚁群算法</u>、<u>粒子群算法</u>和<u>遗传算法</u>等。一个机器学习系统应该有<u>环境</u>、<u>知识库</u>、<u>学习环节</u>和<u>执行环节</u>四个基本部分组成。</li><li>常用的知识表示法有<u>逻辑表示法</u>、<u>语义网络</u>、<u>框架理论</u>、<u>过程表示</u>、<u>脚本表示</u>等。</li><li>有两个算法 A*算法 A1 和 A2，若 A1比 A2有较多的启发信息，则 h1(n) <u>大于</u> h2(n)</li><li>关于 A 算法与 A*算法，若规定 h(n)&gt;=0,并且定义启发函数：f*(n) = g*(n)+h*(n) 表示初始状态 S0 经点 n 到目标状态 Sg最优路径的费用。其中 g*(n) 为 S0 到 n 的最小费用，h*(n) 为到 Sg 的实际最小费用。若另 <u>h(n)==0</u> ，则 A算法相当于<u>宽度优先搜索</u>。若另 <u>g(n)==h(n)==0</u> ，则相当于<u>随机算法</u>。若另 <u>g(n)==0</u> ，则相当于<u>最佳优先算法</u>。特别是当要求 <u>h(n)&lt;=h*(n)</u>，就称这种 A 算法为 A* 算法。</li><li>群智能是指无智能或简单智能的主题通过任何形式的聚集协同二表现出智能行为的特点。群智能潜在的两大特点是<u>并行性</u>和<u>分布式</u>。其典型算法有<u>蚁群算法</u>和<u>粒子群算法</u>。已知的群智能理论的研究和应用证明群智能算法是一种能够有效解决大<u>多数优化问题</u>的新方法。</li><li>蚁群算法是模拟自然界中蚂蚁寻找从巢穴到食物的最佳路径的行为而设计的，蚂蚁在遇到食物返回的路上会分泌<u>信息素</u>，信息素会随着时间慢慢挥发，且关键路径上的信息素相对浓度<u>高</u>，蚁群算法已被广泛应用于许多优化问题中，其中有<u>聚类问题</u>、<u>路由算法设计</u>、<u>图着色</u>、<u>车辆调度</u>、<u>机器人路径规划</u>。</li><li>粒子群优化算法是模拟<u>鸟群</u>或<u>蜂群</u>或<u>个体之间的协作和信息共享</u>的觅食行为而设计的，其基本思想是通过群体中<u>广泛应用于各类优化问题上</u>和在<u>军事领域中的应用</u>来寻找最优解。粒子群优化算法的应用领域有<u>对巡航导弹的飞行高度进行优化</u>、<u>车辆路径问题的应用</u>、<u>邮政投递</u>、<u>火车及汽车的调度</u>、<u>港口装卸集装箱</u>。</li><li>遗传算法是以达尔文的自然选择学说为基础发展起来的。遗传算法的三种基本操作是<u>复制、交叉、变异</u>；在遗传算法中，衡量个体优劣的尺度是<u>适应度</u>，它决定某些个体是繁殖或是消亡，同时也是驱动遗传算法的动力。</li><li>蚁群算法是模拟自然界中蚂蚁寻找从巢穴到食物的最佳路径的行为而设计的，依据蚁群算法的基本原理，蚁群算法中的行为因子有<u>觅食规则</u>、<u>移动规则</u>、<u>避障规则</u>、<u>信息素规则</u>、<u>范围</u>、<u>环境</u>等。</li><li>近年有学者提出的人工鱼群算法（Artificial Fish Swarm Algorith - AFSA）是模仿自然界中鱼群的行为而提出来的解决问题的算法，从模拟鱼群的<u>聚集行为</u>、<u>觅食行为</u>、<u>跟随行为</u>和<u>移动行为</u>等方面来模拟自然界中的鱼群行为。</li><li>遗传算法将『优胜劣汰，适者生存』的<u>生物进化原理</u>引入优化参数形成的编码串群体中，按所选择的<u>适应度函数</u>并通过遗传中的<u>复制</u>、<u>交叉</u>以及<u>变异</u>对个体进行<u>筛选</u>，<u>适应度高</u>的个体被保留下来，组成新的群体，新的群体既继承了上一代的信息，又优于上一代。</li><li>决策树是一种知识概念表示方法，能表示与或规则；是一种<u>图形表示的监督学习方法</u>。而人工神经网络（ANNs）是<u>非图形符号表示法</u>，又是一种函数表示法；即从大量的数据中<u>学习值为实数、离散值或向量的函数</u>。人工神经网络对于训练数据中『错误』数据的<u>错误健壮性很好</u>。人工神经网络的训练学习过程中有一个称为『学习速率 n』的常数，n取值过大会<u>引起漂移</u>，n 取值过小会<u>收敛速度太慢，学习效率不高</u>。大量的数据中抽取规则函数，错误健壮性很好。</li><li>多层神经网络的学习过程中有一种是反向传播算法（Back Propagation-BP）， 其基本思想是利用<u>输出单元的误差再计算上一层单元的误差，以次向上传播</u>以次向上传播，俗称反向传播。又称<u>逆推学习算法</u>。</li><li>归纳学习需要的预先假定，称为归纳偏置，归纳学习算法隐含了归纳偏置， 候选消除算法的归纳偏置是<u>目标概念可以在假设空间中找到</u>，所以又称<u>限定偏置</u>。ID3是一种典型的决策树学习方法，ID3的归纳偏置有两点，分别是<u>搜索完整的假设空间</u>，<u>优先选择较小的树</u>。Find-S 算法<u>寻找极大特殊假设</u>使用一般到特殊序，在偏序结构的一个分支上 执行<u>一般到特殊搜索</u>搜索，寻找一个与样例一致的<u>最特殊</u>假设。</li><li>自然语言处理是研究用机器处理人类语言的理论和技术,又叫<u>自然语言理解</u>, 它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法, 自然语言处理研究面临的两大困难是<u>歧义病构</u>和<u>音歧义</u>,其中歧义分为<u>分词歧义</u>、<u>短语歧义</u>、<u>词义歧义</u>、 <u>语用歧义</u>四个方面。</li><li>在证据理论(Evident Theory)中引入了信任函数(BeL)，它满足了<u>概率论弱公理</u>。在概率论中，当先验概率很难获得，但又要被迫给出时，用证据理论能区分<u>不确定性</u>和<u>不知道</u>的差别。因而它比概率论更 适合于<u>专家系统推理方法</u>。概率论是证据理论的一个特例，有时也称<u>证据理论</u>为广义概率论。</li><li>贝叶斯网是一个在弧的连接关系上加入<u>连接强度</u> 的因果关系网络。由两个部分组成，其一是 DAG，即 <u>有向无环图</u>  ;其二是 CPT， 即 <u>概率分配表</u> 。贝叶斯网络通常使用三种推理是 <u>因果推理</u> 、 <u>诊断推理</u> 、  <u>辩解推理</u>  。</li><li>在确定性推理模型中的可信度因子 CF(H,E) <u>证据 e 得到的假设 h 的确定性因子</u>  的取值范围为<u>[-1,+1]</u>  ;主观 Bayes 方法中规定规 则的静态强度 LS,LN 的值应 <u>[0,∞)</u>。</li></ol><h2 id="简答部分"><a href="#简答部分" class="headerlink" title="简答部分"></a>简答部分</h2><ol><li><p>人工智能方法与传统程序的不同有哪些？</p><p>答：<strong>传统方法解决问题利用已有知识 , 问题可以方便的结构化数据结构 , 数学形式表达， 数学公式、算法。利用知识特别是依赖人类经验的启发知识是人工智能方法与传统数学方法的根本不同之处，基于此，人工智能可以解决众多的难以数学表达的非结构化 的实际问题 , 人工智能首先研究的是以符号表示的知识 , 而不是数值为研究对象 , 其次采用的是启发式推理的方法而不是常规的算法 , 控制结构和领域知识是分离的，同时还允许出现相对正确的答案。</strong></p></li><li><p>在与或图的问题求解过程中，哪几类节点称为能解节点?</p><p>答：<strong>终节点是能解节点；若非终节点有”或”子节点时，当且仅当其子节点至少有一能解时，该非终节点才能解；若非终节点有”与”子节点时，当且仅当其子节点均能解时，该非终节点才能解。</strong></p></li><li><p>宽度优先搜索和深度优先搜索有何不同?在何种情况下宽度优先搜索优于深度优先搜索?在何种情况下深度优先搜索优于宽度优先搜索?两种搜索策略是否都是完备的?</p><p>答：<strong>宽度优先搜索就是逐层穷举搜索。深度优先搜索就是分支优先搜索待搜索问题的解存在且关键路径较短时宽 度优先搜索优于深度优先搜索;待搜索问题的解存在且关键路径较长，而深度优先搜索过程中优先发展的正好是解所在的路径时深度优先搜索优于宽度优先搜索。宽度优先搜索是完备的 。</strong></p></li><li><p>举例解释语义网络(Semantic Network)与知识图谱(Knowledge graph)的区别与联系。</p><p>答：<strong>知识图谱是通过将数学、图形学、可视化技术、信息科学等的理论与方法与计量学的引文分析、共现分析等方法结合，并利用可视化的图谱形象地展示知识体系的方法。 它把复杂的知识领域通过数据挖掘、信息处理、知识计量和图形绘制而显示出来，揭示知识领域的动态发展规律， 为学科研究供切实的、有价值的参考。 据不完全统计，Google 知识图谱到目前为止包含了 5 亿个实体和 35 亿条事实(形如实体-关系-实体， 和实体-属性值)。</strong></p><p><strong>语义网络 特点 (1) 结构性好: 语义网络是一种结构化的知识表示方法，它能够把事物的属性和事物间的各种语义关系显示地表示出来; (2)联想性: 语义网络作为人类联想记忆模型提出来，强调的就是事物之间的语义关系。 (3)自然性: 语义网络实际上是一个带有标示的有向图，可直观的把事物的属性及事物间的语义联系表示出来，便于理解。 利用语义网络表示知识的问题有:自然语言理解，问答系统， 专家系统等。 缺点:推理规则不十分明显，表达范围有限，一旦结点个数太多，网络结构复杂。</strong></p></li><li><p>举例说明大型应用软件系统开发过程中采用的软件技术(体系)架构是如何体现框架理论知识表示思想的。</p><p>答：<strong>软件开发过程中框架理论的使用软件框架(架构)特点: 为某一特定目的实现一个基本的、可执行的 构架 ；包含了应用程序从启动到运行的主要流程；流程中那些无法确定的步骤留给用户来实现；程序运行时框架系统自动调用用户实现的功能组件；系统的行为是主动的。</strong></p><p><strong>软件开发过程中框架理论的使用：人们将相同类型问题的解决途径进行抽象， 抽取成一个应用框架 Framework；提供了一套明确机制；让开发人员很容易的扩展和控制整个 Framework 开发上的结构。</strong></p><p><strong>软件开发过程中框架理论的使用：</strong></p><p><strong>系统级框架： MFC 框架、 .NET 中的应用框架、 JavaAWT</strong></p><p><strong>中间件框架： Spring 框架、 Struts 框架、 Hibernate 框架、 EXTjs 框架</strong></p><p><strong>企业应用框架为不同行业的应用开发专用的企业级框架系统 ：JBOSS, eBOSS, websphere等</strong></p><p><strong>软件开发过程中框架理论的使用：</strong></p><p><strong>Struts 框架: Struts 对 Model，View 和 Controller 都提供了对应的组件;</strong></p><p><strong>Mode 槽:ActionForm 和 JavaBean 组成;</strong></p><p><strong>View 槽: JSP(或 HTML、PHP……)实现;</strong></p><p><strong>Controller 槽:核心控制器，业务逻辑控制器。</strong></p></li><li><p>简要说明粒子群优化算法与遗传算法的共性和差异。</p><p><strong>共性：( 1 )都属于仿生算法;( 2 )都属于全局优化方法;( 3 )都属于随机搜索算法;( 4 )都隐含并行性;( 5 )根据个体的适配信息进行搜索，因此不受函数约束条件的限制， 如连续性、可导性等;( 6 )对高维复杂问题，往往会遇到早熟收敛和收敛性能差的缺点，都无法保证收敛到最优点。</strong></p><p><strong>差异：(1) PSO 有记忆，所有粒子都保存较优解的知识，而 GA ，以前的知识随着种群的改变被改变; (2) PSO 中的粒子是一种单向共享信息机制。而 GA 中的染色体之间相互共享信息，使得整个种群都向最优区域移动; (3) GA 需要编码和遗传操作，而 PSO 没有交叉和变异操作，粒子只是通过内部速度进行更新，因此原理更简单、参数更少、实现更容易。</strong></p></li><li><p>影响算法 A 启发能力的重要因素有哪些。</p><p><strong>( 1 )路径的耗散值; ( 2 )求解路径时所扩展的节点数; ( 3 )计算 h 所需的工作量。</strong></p><p><strong>因此选择 h 函数时，应综合考虑这些因素以便使启发能力最大</strong></p></li><li><p>决策树学习法与神经网络学习法的区别。</p><p><strong>决策树是知识一种图形符号表示，能表示与或规则;形象直观地图形符号</strong></p><p><strong>神经网络学习是非图形符号表示法，是一种函数表示法;从大量的数据中抽取规则函数</strong></p></li><li><p>为什么说遗传算法是一种“智能式搜索”，又是一种“渐进式优化搜索”。</p><p><strong>遗传算法的搜索策略，既不是盲目式的乱搜索，也不是穷举式的全面搜索， 它是有指导的搜索。指导遗传算法执行搜索的依据是适应度，也就是它的目标函数。利用适应度，使遗传算法逐步逼近目标值。</strong></p><p><strong>渐进式优化 : 遗传算法利用复制、交换、突变等操作，使新一代的结果优越于旧一代，通过不断迭代，逐渐得出最优的结果，它是一种反复迭代的过程</strong></p></li><li><p>简述α-β过程的剪枝规则。</p><p><strong>后辈节点的值≤祖先节点的值时，α剪枝</strong></p><p><strong>后辈节点的值≥祖先节点的值时，β剪枝</strong></p></li><li><p>简述关于群智能理论(算法)研究存在那些问题。</p><p><strong>数学理论基础相对薄弱，涉及的各种参数设置没有确切的理论依据带有随机性，每次的求解不一定一样，当处理突发事件时，系统的反映可能是不可预测的，这在一定程度上增加了其应用风险。</strong></p></li></ol><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/03/AI-sdu-2016-summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Raspberry3 上搭建 Go 环境</title>
      <link>http://blog.luoyuanhang.com/2017/02/02/run-go-on-raspberry-3/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/02/run-go-on-raspberry-3/</guid>
      <pubDate>Thu, 02 Feb 2017 14:29:53 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇博客讲的是如何在 Raspberry3（树莓派3）上搭建 Go 语言环境，所使用的 Go 语言的版本是1.7.4&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇博客讲的是如何在 Raspberry3（树莓派3）上搭建 Go 语言环境，所使用的 Go 语言的版本是1.7.4</p></blockquote><a id="more"></a><h2 id="搭建Go环境"><a href="#搭建Go环境" class="headerlink" title="搭建Go环境"></a>搭建Go环境</h2><ul><li><p>ssh 登录树莓派</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@YOUR_RASPBERRY_IP</span><br></pre></td></tr></table></figure></li><li><p>下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.7.4.linux-armv6l.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local/ -xzf go/go1.7.4.linux-armv6l.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/profile</span><br></pre></td></tr></table></figure><p>在文件中加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>在控制台输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.7.4 linux/arm</span><br></pre></td></tr></table></figure><p>即为安装成功。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/02/run-go-on-raspberry-3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
