<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>远航</title>
    <link>http://blog.luoyuanhang.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Aim high.</description>
    <pubDate>Tue, 10 Jul 2018 13:47:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>以太坊智能合约开发 - 环境搭建</title>
      <link>http://blog.luoyuanhang.com/2018/07/10/starting-on-ethereum-smart-contract-env/</link>
      <guid>http://blog.luoyuanhang.com/2018/07/10/starting-on-ethereum-smart-contract-env/</guid>
      <pubDate>Tue, 10 Jul 2018 13:44:57 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;在区块链的世界中，比特币被称为区块链1.0，以太坊进化为区块链2.0，这一跨越的实现缘于以太坊对智能合约的实现。智能合约在以太坊网络中扮演着至关重要的角色，目前ERC20代币的发行、多重签名乃至DApp的开发等都需要通过智能合约来进行实现等，因此学习智能合约的开发是很重要的。这篇文章会详细阐述该如何进行以太坊合约开发环境的搭建，以及编写第一个以太坊上的智能合约。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>在区块链的世界中，比特币被称为区块链1.0，以太坊进化为区块链2.0，这一跨越的实现缘于以太坊对智能合约的实现。智能合约在以太坊网络中扮演着至关重要的角色，目前ERC20代币的发行、多重签名乃至DApp的开发等都需要通过智能合约来进行实现等，因此学习智能合约的开发是很重要的。这篇文章会详细阐述该如何进行以太坊合约开发环境的搭建，以及编写第一个以太坊上的智能合约。</p></blockquote><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>进行以太坊智能合约的开发需要我们有一个以太坊网络的环境，我建议使用自己搭建的私链进行测试，在自己的私链上，以太币的获取比较容易，对于以太坊私链的的搭建可以参考我的另一篇博文<a href="http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/">《【Ethereum基础实践】：以太坊测试私链的搭建》</a>。</p><h1 id="Remix的使用"><a href="#Remix的使用" class="headerlink" title="Remix的使用"></a>Remix的使用</h1><p>Remix是以太坊官方推荐使用的IDE，在Remix上我们可以进行合约的编写，并且还可以对以太坊环境进行集成，进行智能合约的部署与调试。</p><p>Remix有Web版本和Electron APP两个版本：</p><ul><li>Web：<a href="http://remix.ethereum.org/" target="_blank" rel="noopener">http://remix.ethereum.org/</a></li><li>Electron APP：<a href="https://github.com/horizon-games/remix-app" target="_blank" rel="noopener">https://github.com/horizon-games/remix-app</a></li></ul><p>你可以选择Web版或者Electron版本，它们的功能没有任何差别。</p><p><img src="http://wx2.sinaimg.cn/large/4858d6a8gy1ft4rcqp1zhj21hc0u0doq.jpg" alt=""></p><h2 id="安装Remixd服务"><a href="#安装Remixd服务" class="headerlink" title="安装Remixd服务"></a>安装Remixd服务</h2><p>由于Remix提供的是一个在线的Web环境，因此在本地不会存储你所编写的智能合约源文件，如果你希望文件能一直保存在本地，你可以安装Remixd服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g remixd</span><br></pre></td></tr></table></figure><p>启动remixd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用绝对路径</span></span><br><span class="line">remixd -s /Users/username/path_you_store_contracts</span><br></pre></td></tr></table></figure><p>点击Remix IDE左上方按钮连接至remixd服务：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4ri7sob7j205e03ha9z.jpg" alt=""></p><p>这样就可以在本地编写智能合约了：</p><p><img src="http://wx2.sinaimg.cn/large/4858d6a8gy1ft4rsnerayj205v04xt8q.jpg" alt=""></p><h2 id="连接到以太坊节点"><a href="#连接到以太坊节点" class="headerlink" title="连接到以太坊节点"></a>连接到以太坊节点</h2><p>在Remix IDE中，我们可以连接我们自己的以太坊节点进行测试，在控制面板的<code>Run</code>页面中可以配置自定义的以太坊节点，在<code>Environment</code>中选择<code>Web3 Provider</code>:</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4t29qttbj20aw0da0tt.jpg" alt=""></p><p>输入节点对应的IP地址和RPC端口即可进行连接：</p><p><img src="http://wx1.sinaimg.cn/large/4858d6a8gy1ft4t3wel8tj20qq043q30.jpg" alt=""></p><p>在连接节点之后，我们可以看到私链中的各个账户的余额等信息：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4thr2vetj20ak04j74k.jpg" alt=""></p><p>这样我们就可以使用自己的以太坊私链进行智能合约的部署与测试了。</p><h1 id="一个简单的智能合约"><a href="#一个简单的智能合约" class="headerlink" title="一个简单的智能合约"></a>一个简单的智能合约</h1><p>接下来我们会编写和部署一个简单的智能合约来演示一下整个流程。</p><p>先来看一下合约的源文件代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Demo &#123;</span><br><span class="line">    uint256 public number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">uint8 _initial</span>) </span>&#123;</span><br><span class="line">        number = _initial;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        number = number +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约的功能是在合约中存储了一个数字<code>number</code>，并且提供了一个对该数字进行+1的方法<code>add()</code>.</p><p>我们先对源代码进行编译：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4tl0v372j20b706rjrz.jpg" alt=""></p><p>之后在<code>Run</code>面板点击<code>Create</code>进行部署：</p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8gy1ft4unsg1irj20ao0cf3zd.jpg" alt=""></p><p>由于该合约的构造方法中需要一个参数，来对<code>number</code>进行初始化，这里我填的是<code>10</code>，另外，在<code>Account</code>中需要选择部署该合约的账户（需要消耗gas），并且输入对应的密码对账户进行解锁：</p><p><img src="http://wx2.sinaimg.cn/large/4858d6a8gy1ft4unnccb3j20qm043dg1.jpg" alt=""></p><p>待创建合约的交易广播至矿工节点并且被打包至区块中之后，我们就可以在面板中看到相关的合约信息了：</p><p><img src="http://wx1.sinaimg.cn/large/4858d6a8gy1ft4unil8f0j20ac03y3yi.jpg" alt=""></p><p>点击<code>number</code>可以查看当前的值：</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8gy1ft4uu5cqj9j20ad03xjrf.jpg" alt=""></p><p>点击<code>add</code>可以触发对应方法（该操作是一个transaction，需要消耗gas），<code>number</code>的值会进行+1：</p><p><img src="http://wx3.sinaimg.cn/large/4858d6a8gy1ft4uuapmdmj20ac040gln.jpg" alt=""></p><p>我们在控制台中可以看到该交易的详细信息：</p><p><img src="http://wx4.sinaimg.cn/large/4858d6a8gy1ft4unck0pdj210108ft9x.jpg" alt=""></p><p>至此，我们就完成了一个简单的智能合约的部署。</p><h1 id="部署一个ERC20的合约"><a href="#部署一个ERC20的合约" class="headerlink" title="部署一个ERC20的合约"></a>部署一个ERC20的合约</h1><p>在这部分，我们会以以太坊上的EOS代币合约为例，进行ERC20代币的合约部署与测试。</p><p>首先，我们要获取EOS智能合约的源代码，可以在etherscan上获取对应源码：</p><p><a href="https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code" target="_blank" rel="noopener">https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line">contract DSNote &#123;</span><br><span class="line">    event LogNote(</span><br><span class="line">        bytes4   indexed  sig,</span><br><span class="line">        address  indexed  guy,</span><br><span class="line">        bytes32  indexed  foo,</span><br><span class="line">        bytes32  indexed  bar,</span><br><span class="line">uint   wad,</span><br><span class="line">        bytes             fax</span><br><span class="line">    ) anonymous;</span><br><span class="line"></span><br><span class="line">    modifier note &#123;</span><br><span class="line">        bytes32 foo;</span><br><span class="line">        bytes32 bar;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            foo := calldataload(<span class="number">4</span>)</span><br><span class="line">            bar := calldataload(<span class="number">36</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);</span><br><span class="line"></span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSAuthority &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">canCall</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address src, address dst, bytes4 sig</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">DSAuthEvents</span> </span>&#123;</span><br><span class="line">    event LogSetAuthority (address indexed authority);</span><br><span class="line">    event LogSetOwner     (address indexed owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSAuth is DSAuthEvents &#123;</span><br><span class="line">    DSAuthority  public  authority;</span><br><span class="line">    address      public  owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DSAuth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        LogSetOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setOwner</span>(<span class="params">address owner_</span>)</span></span><br><span class="line"><span class="function">        <span class="title">auth</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        owner = owner_;</span><br><span class="line">        LogSetOwner(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAuthority</span>(<span class="params">DSAuthority authority_</span>)</span></span><br><span class="line"><span class="function">        <span class="title">auth</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        authority = authority_;</span><br><span class="line">        LogSetAuthority(authority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier auth &#123;</span><br><span class="line">        assert(isAuthorized(msg.sender, msg.sig));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier authorized(bytes4 sig) &#123;</span><br><span class="line">        assert(isAuthorized(msg.sender, sig));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isAuthorized</span>(<span class="params">address src, bytes4 sig</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (src == address(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src == owner) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (authority == DSAuthority(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> authority.canCall(src, <span class="keyword">this</span>, sig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">bool x</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSStop is DSAuth, DSNote &#123;</span><br><span class="line"></span><br><span class="line">    bool public stopped;</span><br><span class="line"></span><br><span class="line">    modifier stoppable &#123;</span><br><span class="line">        assert (!stopped);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params"></span>) <span class="title">auth</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        stopped = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) <span class="title">auth</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        stopped = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSMath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    standard uint256 functions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x + y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x - y) &lt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x * y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        z = x / y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">uint256 x, uint256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    uint128 functions (h is for half)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hadd</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x + y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hsub</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x - y) &lt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hmul</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = x * y) &gt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hdiv</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = x / y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hmin</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hmax</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int256 functions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">imin</span>(<span class="params">int256 x, int256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">int256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">imax</span>(<span class="params">int256 x, int256 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">int256 z</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    WAD math</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    uint128 constant WAD = <span class="number">10</span> ** <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wadd</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hadd(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wsub</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hsub(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wmul</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * y + WAD / <span class="number">2</span>) / WAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wdiv</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * WAD + y / <span class="number">2</span>) / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wmin</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmin(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wmax</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmax(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RAY math</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    uint128 constant RAY = <span class="number">10</span> ** <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">radd</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hadd(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rsub</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hsub(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rmul</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * y + RAY / <span class="number">2</span>) / RAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rdiv</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        z = cast((uint256(x) * RAY + y / <span class="number">2</span>) / y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rpow</span>(<span class="params">uint128 x, uint64 n</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This famous algorithm is called "exponentiation by squaring"</span></span><br><span class="line">        <span class="comment">// and calculates x^n with x as fixed-point and n as regular unsigned.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// It's O(log n), instead of O(n) for naive repeated multiplication.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// These facts are why it works:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  If n is even, then x^n = (x^2)^(n/2).</span></span><br><span class="line">        <span class="comment">//  If n is odd,  then x^n = x * x^(n-1),</span></span><br><span class="line">        <span class="comment">//   and applying the equation for even x gives</span></span><br><span class="line">        <span class="comment">//    x^n = x * (x^2)^((n-1) / 2).</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  Also, EVM division is flooring and</span></span><br><span class="line">        <span class="comment">//    floor[(n-1) / 2] = floor[n / 2].</span></span><br><span class="line"></span><br><span class="line">        z = n % <span class="number">2</span> != <span class="number">0</span> ? x : RAY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (n /= <span class="number">2</span>; n != <span class="number">0</span>; n /= <span class="number">2</span>) &#123;</span><br><span class="line">            x = rmul(x, x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                z = rmul(z, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rmin</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmin(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rmax</span>(<span class="params">uint128 x, uint128 y</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmax(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cast</span>(<span class="params">uint256 x</span>) <span class="title">constant</span> <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint128 z</span>) </span>&#123;</span><br><span class="line">        assert((z = uint128(x)) == x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint supply</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">balanceOf</span>(<span class="params"> address who </span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint value</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">allowance</span>(<span class="params"> address owner, address spender </span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint _allowance</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transfer</span>(<span class="params"> address to, uint value</span>) <span class="title">returns</span> (<span class="params">bool ok</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params"> address from, address to, uint value</span>) <span class="title">returns</span> (<span class="params">bool ok</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params"> address spender, uint value </span>) <span class="title">returns</span> (<span class="params">bool ok</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Transfer</span>(<span class="params"> address indexed from, address indexed to, uint value</span>);</span></span><br><span class="line"><span class="function">    <span class="title">event</span> <span class="title">Approval</span>(<span class="params"> address indexed owner, address indexed spender, uint value</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">DSTokenBase</span> <span class="title">is</span> <span class="title">ERC20</span>, <span class="title">DSMath</span> </span>&#123;</span><br><span class="line">    uint256                                            _supply;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)                       _balances;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256))  _approvals;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DSTokenBase</span>(<span class="params">uint256 supply</span>) </span>&#123;</span><br><span class="line">        _balances[msg.sender] = supply;</span><br><span class="line">        _supply = supply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _supply;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address src</span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _balances[src];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params">address src, address guy</span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _approvals[src][guy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address dst, uint wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        assert(_balances[msg.sender] &gt;= wad);</span><br><span class="line">        </span><br><span class="line">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class="line">        _balances[dst] = add(_balances[dst], wad);</span><br><span class="line">        </span><br><span class="line">        Transfer(msg.sender, dst, wad);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address src, address dst, uint wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        assert(_balances[src] &gt;= wad);</span><br><span class="line">        assert(_approvals[src][msg.sender] &gt;= wad);</span><br><span class="line">        </span><br><span class="line">        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);</span><br><span class="line">        _balances[src] = sub(_balances[src], wad);</span><br><span class="line">        _balances[dst] = add(_balances[dst], wad);</span><br><span class="line">        </span><br><span class="line">        Transfer(src, dst, wad);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address guy, uint256 wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        _approvals[msg.sender][guy] = wad;</span><br><span class="line">        </span><br><span class="line">        Approval(msg.sender, guy, wad);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DSToken is DSTokenBase(<span class="number">0</span>), DSStop &#123;</span><br><span class="line"></span><br><span class="line">    bytes32  public  symbol;</span><br><span class="line">    uint256  public  decimals = <span class="number">18</span>; <span class="comment">// standard token precision. override to customize</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DSToken</span>(<span class="params">bytes32 symbol_</span>) </span>&#123;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address dst, uint wad</span>) <span class="title">stoppable</span> <span class="title">note</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.transfer(dst, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address src, address dst, uint wad</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">stoppable</span> <span class="title">note</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.transferFrom(src, dst, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address guy, uint wad</span>) <span class="title">stoppable</span> <span class="title">note</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.approve(guy, wad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">address dst, uint128 wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transfer(dst, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pull</span>(<span class="params">address src, uint128 wad</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transferFrom(src, msg.sender, wad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">uint128 wad</span>) <span class="title">auth</span> <span class="title">stoppable</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        _balances[msg.sender] = add(_balances[msg.sender], wad);</span><br><span class="line">        _supply = add(_supply, wad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint128 wad</span>) <span class="title">auth</span> <span class="title">stoppable</span> <span class="title">note</span> </span>&#123;</span><br><span class="line">        _balances[msg.sender] = sub(_balances[msg.sender], wad);</span><br><span class="line">        _supply = sub(_supply, wad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional token name</span></span><br><span class="line"></span><br><span class="line">    bytes32   public  name = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">bytes32 name_</span>) <span class="title">auth</span> </span>&#123;</span><br><span class="line">        name = name_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述相同的部署方法，我们就可以看到EOS合约中提供的相关方法，并且开始测试了：</p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8gy1ft4v6h504aj20ad0ko75d.jpg" alt=""></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/07/10/starting-on-ethereum-smart-contract-env/#disqus_thread</comments>
    </item>
    
    <item>
      <title>以太坊区块的生成</title>
      <link>http://blog.luoyuanhang.com/2018/05/02/eth-basis-block-concepts/</link>
      <guid>http://blog.luoyuanhang.com/2018/05/02/eth-basis-block-concepts/</guid>
      <pubDate>Wed, 02 May 2018 03:57:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;从名称上来看，区块（Block）也是区块链系统中的核心概念，区块链简单来说就是将区块联结成链，区块中保存的是打包成的各种区块信息。在以太坊中，区块中保存的是各种交易信息。一个区块中可以包含若干个交易，也可以不包含任何交易。这篇文章主要会阐释以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区块是什么？包含了哪些信息？&lt;/li&gt;
&lt;li&gt;区块是如何被打包的，写入到区块链的？&lt;/li&gt;
&lt;li&gt;一个区块的大小是多少？可以包含多少交易？&lt;/li&gt;
&lt;li&gt;多长时间可以产生一个区块？&lt;/li&gt;
&lt;li&gt;为什么有的区块中没有交易？&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>从名称上来看，区块（Block）也是区块链系统中的核心概念，区块链简单来说就是将区块联结成链，区块中保存的是打包成的各种区块信息。在以太坊中，区块中保存的是各种交易信息。一个区块中可以包含若干个交易，也可以不包含任何交易。这篇文章主要会阐释以下问题：</p><ul><li>区块是什么？包含了哪些信息？</li><li>区块是如何被打包的，写入到区块链的？</li><li>一个区块的大小是多少？可以包含多少交易？</li><li>多长时间可以产生一个区块？</li><li>为什么有的区块中没有交易？</li></ul><a id="more"></a><h2 id="以太坊区块"><a href="#以太坊区块" class="headerlink" title="以太坊区块"></a>以太坊区块</h2><p>以太坊的区块中保存了许多信息，最主要的有该区块的区块信息以及该区块中所包含的交易的信息。<br>我们可以在<a href="https://github.com/ethereum/go-ethereum/blob/63687f04e441c97cbb39d6b0ebea346b154d2e73/core/types/block.go" target="_blank" rel="noopener">go-ethereum中的源码</a>看到区块的结构体定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents an entire block in the Ethereum blockchain.</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">header       *Header</span><br><span class="line">uncles       []*Header</span><br><span class="line">transactions Transactions</span><br><span class="line"></span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line"></span><br><span class="line"><span class="comment">// Td is used by package core to store the total difficulty</span></span><br><span class="line"><span class="comment">// of the chain up to and including the block.</span></span><br><span class="line">td *big.Int</span><br><span class="line"></span><br><span class="line"><span class="comment">// These fields are used by package eth to track</span></span><br><span class="line"><span class="comment">// inter-peer block relay.</span></span><br><span class="line">ReceivedAt   time.Time</span><br><span class="line">ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有下列主要属性：</p><ul><li><code>header</code>：存储的是该区块的信息（结构体为Header）</li><li><code>uncles</code>：存储的是该区块所包含的叔块（uncle block）的信息，关于叔块的相关内容将会在之后的文章中进行讨论</li></ul><p>其中Header结构体中是一个区块中所包含的信息，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header represents a block header in the Ethereum blockchain.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">ParentHash  common.Hash    <span class="string">`json:"parentHash"       gencodec:"required"`</span></span><br><span class="line">UncleHash   common.Hash    <span class="string">`json:"sha3Uncles"       gencodec:"required"`</span></span><br><span class="line">Coinbase    common.Address <span class="string">`json:"miner"            gencodec:"required"`</span></span><br><span class="line">Root        common.Hash    <span class="string">`json:"stateRoot"        gencodec:"required"`</span></span><br><span class="line">TxHash      common.Hash    <span class="string">`json:"transactionsRoot" gencodec:"required"`</span></span><br><span class="line">ReceiptHash common.Hash    <span class="string">`json:"receiptsRoot"     gencodec:"required"`</span></span><br><span class="line">Bloom       Bloom          <span class="string">`json:"logsBloom"        gencodec:"required"`</span></span><br><span class="line">Difficulty  *big.Int       <span class="string">`json:"difficulty"       gencodec:"required"`</span></span><br><span class="line">Number      *big.Int       <span class="string">`json:"number"           gencodec:"required"`</span></span><br><span class="line">GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:"gasLimit"         gencodec:"required"`</span></span><br><span class="line">GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:"gasUsed"          gencodec:"required"`</span></span><br><span class="line">Time        *big.Int       <span class="string">`json:"timestamp"        gencodec:"required"`</span></span><br><span class="line">Extra       []<span class="keyword">byte</span>         <span class="string">`json:"extraData"        gencodec:"required"`</span></span><br><span class="line">MixDigest   common.Hash    <span class="string">`json:"mixHash"          gencodec:"required"`</span></span><br><span class="line">Nonce       BlockNonce     <span class="string">`json:"nonce"            gencodec:"required"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到一个区块中包含了如下信息：</p><ul><li><code>ParentHash</code>：该区块的父区块的Hash值</li><li><code>UncleHash</code>：该区块的叔区块的Hash值</li><li><code>Coinbase</code>：打包该区块矿工的地址，矿工费和发现区块的奖励会被发送到该地址</li><li><code>Root</code>：Merkle树根节点的Hash，以太坊中的交易状态信息是以Merkle状态树的形式进行存储的，Root是该状态树的根节点的Hash值</li><li><code>TxHash</code>：保存该区块中交易Merkle树的根节点的Hash值</li><li><code>ReceiptHash</code>：一个区块中所包含的交易中的接收者也是以Merkle树的形式进行存储的，该值是该Merkle树根节点的Hash值</li><li><code>Bloom</code>：用于索引与搜索的结构（详见Tips）</li><li><code>Difficult</code>：该区块的难度</li><li><code>Number</code>：所有祖先区块的数量（也就是区块高度）</li><li><code>GasLimit</code>：该区块的gas上限</li><li><code>GasUsed</code>：该区块使用的gas</li><li><code>Time</code>：区块开始打包的时间</li><li><code>Extra</code>：区块相关的附加信息</li><li><code>MixDigest</code>：该哈希值与Nonce值一起能够证明在该区块上已经进行了足够的计算（用于验证该区块挖矿成功与否的Hash值）</li><li><code>Nonce</code>：该哈希值与MixDigest值一起能够证明在该区块上已经进行了足够的计算（用于验证该区块挖矿成功与否的Hash值）</li></ul><blockquote><p>Tips：<br><strong>Bloom的作用</strong><br>以太坊在设计的时候希望能够对Event能够进行快速的检索，并且在区块链上进行存储的成本是很高的，我们还希望不要有太多的重复数据（交易列表、交易产生的记录等）。Bloom就是用来解决这个问题的。在一个区块生成的时候，该区块中包含的所有的合约相关的地址以及所有交易产生的记录的索引都会被记录至Bloom中，以便之后的查找与索引。这些信息会被保存在Header结构中（Bloom字段），不保存在区块的数据段中，这样可以节省空间。当一个应用层的应用程序想要对某个合约中的数据进行检索时，它只需要在区块中的Header信息中进行查找，查看该区块中是否包含该合约相关的记录。</p><p><strong>MixDigest和Nonce是如何进行验证的</strong><br>我们知道以太坊目前采用的挖矿算法是PoW（Proof of Work），简单的来说，这种方法就像是猜数字，比如说在100000个数字中有5个可行解，猜到的就算是挖到了矿，这种算法要求猜到解的难度是可以调整的，一般难度会很大，不那么容易被猜到，但是验证这个解是否正确是很容易的。Nonce值其实就是矿工猜到的解，验证过程如下：经过预处理的Header与Nonce值做一个类似SHA3的运算产生一个128B的Mix（Mix0），这个值用于计算从DAG（以太坊用于挖矿算法的伪随机数据集，目前大小大约为2GB以上）中取出哪一页的数据（大小为128B），取出的DAG的页与Mix会进行一个以太坊特定的mixing方法，会生成下一个Mix（Mix1），这个过程会重复64次，直到得到Mix64。Mix64会被处理成为32B的数据，它被称为Mix Digest。Mix Digest会与一个叫做Target Threshold的值（相当于解集）进行比较，如果Mix Digest的值小于Threshold就认为挖矿成功，如果大于，表示失败。</p></blockquote><h2 id="区块的打包过程"><a href="#区块的打包过程" class="headerlink" title="区块的打包过程"></a>区块的打包过程</h2><p>交易在生成之后会被以太坊节点广播至网络，交易会被放到交易池（txPool）中，由矿工对交易进行验证然后放到正在打包的区块中，当选择好了区块中所要包含的交易之后，矿工就开始了挖矿过程（PoW），当矿工在挖矿竞争中取得胜利之后，该矿工的区块数据就可以被写入到区块链中。</p><p>交易池中有许多交易存在，矿工是如何从交易池中选择交易的呢？其实交易池会对各个交易进行排序，提供的矿工费（gas）高的交易会排在前面。因此，矿工会优先选择奖励高的交易打包至区块。这也就是为什么gas值高的交易会被处理的较快的原因。</p><h2 id="区块的容量"><a href="#区块的容量" class="headerlink" title="区块的容量"></a>区块的容量</h2><p>以太坊的区块大小不同于比特币的区块大小，目前比特币的区块大小是1MB。因此，比特币一个区块中能够包含多少交易是取决于区块的大小以及每个交易的大小，一个区块中所有交易的总和不能超过区块的大小。但是，以太坊并没有固定的区块大小的限制，但是这样的话是如何确定一个区块中能够包含多少交易的呢？</p><p>以太坊的区块中有一个gasLimit，它表示的是该区块中所能包含的交易的gas值的上限。以太坊上的每一笔交易都会消耗gas值，一个区块中所包含的所有交易的gas总和不能超过区块的gasLimit。因此，通过这种方式我们就能够控制一个区块中的交易数量。</p><p>如果交易池中没有待处理的交易，那么矿工会直接进入挖矿过程，依旧会得到挖矿奖励（5 Ether），区块依旧会被打包和广播，只不过该区块中不会包含交易。</p><h2 id="区块时间"><a href="#区块时间" class="headerlink" title="区块时间"></a>区块时间</h2><p>在比特币中，大约10分钟会产生一个区块。根据以太坊白皮书所写，以太坊大约12秒回产生一个区块。这个时间就是区块时间。区块时间是和挖矿难度相关的，比特币的难度调整是有对应算法的，算法会把区块时间维持在10分钟左右。以太坊也有对应的难度调整算法。</p><p>我们可以在以太坊的源码中找到计算难度的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalcDifficulty is the difficulty adjustment algorithm. It returns</span></span><br><span class="line"><span class="comment">// the difficulty that a new block should have when created at time</span></span><br><span class="line"><span class="comment">// given the parent block's time and difficulty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalcDifficulty</span><span class="params">(config *params.ChainConfig, time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">next := <span class="built_in">new</span>(big.Int).Add(parent.Number, big1)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> config.IsByzantium(next):</span><br><span class="line"><span class="keyword">return</span> calcDifficultyByzantium(time, parent)</span><br><span class="line"><span class="keyword">case</span> config.IsHomestead(next):</span><br><span class="line"><span class="keyword">return</span> calcDifficultyHomestead(time, parent)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> calcDifficultyFrontier(time, parent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到有三个版本的代码，分别应用于不同版本的以太坊，我们先来看一下Homestead版本中的代码：<br>我们可以看到有三个版本的代码，分别应用于不同版本的以太坊，我们先来看一下Homestead版本中的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcDifficultyHomestead</span><span class="params">(time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">bigTime := <span class="built_in">new</span>(big.Int).SetUint64(time)</span><br><span class="line">bigParentTime := <span class="built_in">new</span>(big.Int).Set(parent.Time)</span><br><span class="line"></span><br><span class="line">x := <span class="built_in">new</span>(big.Int)</span><br><span class="line">y := <span class="built_in">new</span>(big.Int)</span><br><span class="line"></span><br><span class="line">x.Sub(bigTime, bigParentTime)</span><br><span class="line">x.Div(x, big10)</span><br><span class="line">x.Sub(big1, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x.Cmp(bigMinus99) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(bigMinus99)</span><br><span class="line">&#125;</span><br><span class="line">y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span><br><span class="line">x.Mul(y, x)</span><br><span class="line">x.Add(parent.Difficulty, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x.Cmp(params.MinimumDifficulty) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(params.MinimumDifficulty)</span><br><span class="line">&#125;</span><br><span class="line">periodCount := <span class="built_in">new</span>(big.Int).Add(parent.Number, big1)</span><br><span class="line">periodCount.Div(periodCount, expDiffPeriod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> periodCount.Cmp(big1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">y.Sub(periodCount, big2)</span><br><span class="line">y.Exp(big2, y, <span class="literal">nil</span>)</span><br><span class="line">x.Add(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，以太坊的难度值是基于当前区块的出块时间，对之后的难度值进行调整的。</p><p>具体公式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff = (parent_diff +(parent_diff / <span class="number">2048</span> * max(<span class="number">1</span> - (block_timestamp - parent_timestamp) <span class="comment">// 10, -99))) + 2^(periodCount - 2)</span></span><br></pre></td></tr></table></figure><p>其中<code>2^(periodCount - 2)</code>又称”难度炸弹“，计算公式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^(periodCount - <span class="number">2</span>) = <span class="number">2</span>**((block_number <span class="comment">// expDiffPeriod) - 2)</span></span><br></pre></td></tr></table></figure><p>目前最新的难度调整算法为Byzantium算法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcDifficultyByzantium</span><span class="params">(time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">bigTime := <span class="built_in">new</span>(big.Int).SetUint64(time)</span><br><span class="line">bigParentTime := <span class="built_in">new</span>(big.Int).Set(parent.Time)</span><br><span class="line"></span><br><span class="line">x := <span class="built_in">new</span>(big.Int)</span><br><span class="line">y := <span class="built_in">new</span>(big.Int)</span><br><span class="line"></span><br><span class="line">x.Sub(bigTime, bigParentTime)</span><br><span class="line">x.Div(x, big9)</span><br><span class="line"><span class="keyword">if</span> parent.UncleHash == types.EmptyUncleHash &#123;</span><br><span class="line">x.Sub(big1, x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x.Sub(big2, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x.Cmp(bigMinus99) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(bigMinus99)</span><br><span class="line">&#125;</span><br><span class="line">y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span><br><span class="line">x.Mul(y, x)</span><br><span class="line">x.Add(parent.Difficulty, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x.Cmp(params.MinimumDifficulty) &lt; <span class="number">0</span> &#123;</span><br><span class="line">x.Set(params.MinimumDifficulty)</span><br><span class="line">&#125;</span><br><span class="line">fakeBlockNumber := <span class="built_in">new</span>(big.Int)</span><br><span class="line"><span class="keyword">if</span> parent.Number.Cmp(big2999999) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) <span class="comment">// Note, parent is 1 less than the actual block number</span></span><br><span class="line">&#125;</span><br><span class="line">periodCount := fakeBlockNumber</span><br><span class="line">periodCount.Div(periodCount, expDiffPeriod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> periodCount.Cmp(big1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">y.Sub(periodCount, big2)</span><br><span class="line">y.Exp(big2, y, <span class="literal">nil</span>)</span><br><span class="line">x.Add(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff = (parent_diff + (parent_diff / <span class="number">2048</span> * max((<span class="number">2</span> <span class="keyword">if</span> <span class="built_in">len</span>(parent.uncles) <span class="keyword">else</span> <span class="number">1</span>) - ((timestamp - parent.timestamp) <span class="comment">// 9), -99))) + 2^(periodCount - 2)</span></span><br></pre></td></tr></table></figure><p>以太坊中定义了一个难度的最小值<code>MinimumDifficulty</code>，定义于<code>protocol_params.go</code>源文件中，值为<code>131072</code>，这个值是以太坊中难度的最小值，也是创世块的难度值。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/05/02/eth-basis-block-concepts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础】：交易的生命周期</title>
      <link>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-life-cycle/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-life-cycle/</guid>
      <pubDate>Fri, 20 Apr 2018 03:29:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;大体上说，一个交易的生命周期要经历以下几个过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造一笔交易（这里的交易要包含交易双方的地址、以太币数量、时间戳、签名等信息，它是不含任何私密信息的合法交易数据）&lt;/li&gt;
&lt;li&gt;将消息广播到网络（几乎网络中的所有节点都会收到这笔交易数据）&lt;/li&gt;
&lt;li&gt;验证交易的合法性（生成交易的节点要首先进行验证，其它节点也要进行验证，没有经过验证的交易是不能进入到区块链网络的）&lt;/li&gt;
&lt;li&gt;将交易写入区块链&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>大体上说，一个交易的生命周期要经历以下几个过程：</p><ul><li>构造一笔交易（这里的交易要包含交易双方的地址、以太币数量、时间戳、签名等信息，它是不含任何私密信息的合法交易数据）</li><li>将消息广播到网络（几乎网络中的所有节点都会收到这笔交易数据）</li><li>验证交易的合法性（生成交易的节点要首先进行验证，其它节点也要进行验证，没有经过验证的交易是不能进入到区块链网络的）</li><li>将交易写入区块链</li></ul><a id="more"></a><h2 id="构造一笔交易"><a href="#构造一笔交易" class="headerlink" title="构造一笔交易"></a>构造一笔交易</h2><p>我们先用一个简单的合约作为例子来谈论一笔交易的构造过程，这个合约的作用是在区块链上存储一个数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">uint storedData;</span><br><span class="line"></span><br><span class="line">function set(uint x) public &#123;</span><br><span class="line">storedData = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get() public constant returns (uint) &#123;</span><br><span class="line"><span class="keyword">return</span> storedData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要构造一笔交易，该交易的内容是调用合约中的函数<code>set(uint x)</code>，并且传入参数<code>1</code>。</p><p>首先我们知道，构造一笔交易需要以下字段（具体参照《交易与消息》一文）：</p><ul><li>nonce：交易发送者的交易序列号</li><li>gasPrice：gas价格</li><li>gasLimit：消耗的gas上限</li><li>to：交易接收者的地址</li><li>value：要发送的以太币（以wei为单位）</li><li>data：可选的数据域（在该例子中是必须的字段）</li></ul><p><strong>获取nonce</strong><br>通过geth控制台我们能获取到nonce值，例如：<br>    eth.getTransactionCount(eth.account[0])</p><p><strong>gasPrice</strong><br>我们能够自己随意设置gas的价格，但是有可能由于gas的价格过低，导致交易没有矿工进行处理导致失效。我们可以从这个<a href="https://ethgasstation.info/" target="_blank" rel="noopener">网站</a>来获取推荐的gas价格。</p><p><strong>gasLimit</strong><br>设置你能接受的该交易能够消耗的gas的最大数量。</p><p><strong>to</strong><br>在该例子中，接收者的地址应该是该合约的地址</p><p><strong>value</strong><br>在该例子中，不需要发送以太币，值为0</p><p><strong>data</strong><br>我们需要构造该交易的数据域。</p><p>首先，我们要调用的函数是合约中的<code>set(uint x)</code>，根据Solidity文档<a href="Solidity_ABI_Specification：[https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding](https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding)">^1</a>，我们将该函数<code>set(uint)</code>做Keccak-256哈希<a href="Keccak-256_Hash_Online_Tool：[https://emn178.github.io/online-tools/keccak\_256.html](https://emn178.github.io/online-tools/keccak_256.html)">^2</a>，结果为：</p><pre><code>cccdda2cf2895862749f1c69aa9f55cf481ea82500e4eabb4e2578b36636979b</code></pre><p>我们取其前4字节：<code>0xcccdda2c</code></p><p>然后我们所传入的函数的参数是1，填充为32字节：</p><p><code>0000000000000000000000000000000000000000000000000000000000000001</code></p><p>将这两部分连接起来：</p><p><code>0xcccdda2c0000000000000000000000000000000000000000000000000000000000000001</code></p><p>这就是数据域的内容，共计36字节。</p><p>最终我们构造好的交易是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">txnCount = web3.eth.getTransactionCount(web3.eth.accounts[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">var</span> rawTxn = &#123;</span><br><span class="line">nonce: web3.toHex(txnCount),</span><br><span class="line">gasPrice: web3.toHex(<span class="number">800000000000</span>),</span><br><span class="line">gasLimit: web3.toHex(<span class="number">160000</span>),</span><br><span class="line">to: <span class="string">'0xa55fe56f2a183f795fdaae3529d58b58e57ef5ed'</span>,</span><br><span class="line">value: web3.toHex(<span class="number">0</span>),</span><br><span class="line">data: <span class="string">'0xcccdda2c0000000000000000000000000000000000000000000000000000000000000001'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对交易进行签名"><a href="#对交易进行签名" class="headerlink" title="对交易进行签名"></a>对交易进行签名</h2><p>接下来我们需要使用交易发送者账号的私钥对交易进行签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKey = Buffer.from(<span class="string">'你的账户私钥'</span>, <span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">const</span> txn = <span class="keyword">new</span> EthereumTx(rawTxn)</span><br><span class="line">txn.sign(privateKey)</span><br><span class="line"><span class="keyword">const</span> serializedTxn = txn.serialize()</span><br></pre></td></tr></table></figure><h2 id="本地对交易进行验证"><a href="#本地对交易进行验证" class="headerlink" title="本地对交易进行验证"></a>本地对交易进行验证</h2><p>签名后的交易会首先提交至你的本地以太坊的节点，你的本地节点会首先对该笔交易进行验证，它会验证签名是否有效。</p><h2 id="把交易广播至区块链网络"><a href="#把交易广播至区块链网络" class="headerlink" title="把交易广播至区块链网络"></a>把交易广播至区块链网络</h2><p>之后，你的本地以太坊节点会将交易广播至整个网络，在广播之后会返回一个交易id，你可以通过该id查看和追踪该交易的状态和相关信息。几乎以太坊网络上的所有节点都会收到这笔交易。有一些节点会设置一个最低的gas价格，它们会忽略低于该gasPrice值的交易。</p><h2 id="矿工节点接收到交易"><a href="#矿工节点接收到交易" class="headerlink" title="矿工节点接收到交易"></a>矿工节点接收到交易</h2><p>生成的交易需要被区块链网络中的矿工打包到区块，才能写入到区块链中。矿工会有一个待处理的交易列表，其中的交易是按交易的gasPrice进行排序的，交易的gasPrice越高，处理的优先级就越高。如果交易的gasPrice过低，有可能一直得不到矿工的处理，从而被忽略。</p><h2 id="矿工将交易打包至区块并广播至网络"><a href="#矿工将交易打包至区块并广播至网络" class="headerlink" title="矿工将交易打包至区块并广播至网络"></a>矿工将交易打包至区块并广播至网络</h2><p>矿工会取若干交易然后打包至一个区块中，一个区块中能够包含多少条交易是和区块的gasLimit有关的，所有交易的gasLimit总和不能超过区块的gasLimit。当矿工选择好要打包的交易之后，就开始了PoW（Proof of Work）挖矿过程，最先发现新的区块的矿工能够将交易打包至区块，并且获取到相应的奖励。</p><h2 id="其它节点同步新的区块数据"><a href="#其它节点同步新的区块数据" class="headerlink" title="其它节点同步新的区块数据"></a>其它节点同步新的区块数据</h2><p>由于新的区块已经产生，所有的节点都需要对区块进行同步，你的交易会随着区块的同步被同步至所有节点上。</p><p>至此，一笔交易的生命周期彻底结束，它被永远的写入到了区块链中。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-life-cycle/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础】：交易和消息</title>
      <link>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-and-message/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-and-message/</guid>
      <pubDate>Fri, 20 Apr 2018 02:14:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;交易和消息是以太坊系统中很关键的两个概念，同时也是两个非常类似的概念，它们在形式上近乎相同，但是本质上却又完全不同。这篇博客会将交易（Transaction）、消息（Message）和调用（Message Call）进行介绍和区分。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>交易和消息是以太坊系统中很关键的两个概念，同时也是两个非常类似的概念，它们在形式上近乎相同，但是本质上却又完全不同。这篇博客会将交易（Transaction）、消息（Message）和调用（Message Call）进行介绍和区分。</p><a id="more"></a><h2 id="交易（Transaction）是什么？"><a href="#交易（Transaction）是什么？" class="headerlink" title="交易（Transaction）是什么？"></a>交易（Transaction）是什么？</h2><p>交易存储了发送者要发送至以太坊网络的经过签名的信息，它其中包含了从一个账户要传递给另一个账户（或者合约）的信息。在以太坊中，有两种类型的交易：一种是能够产生消息调用的交易，另一种是能够生成新账户的交易（比如说生成合约）。</p><p>笼统的来说，一个完整有效的以太坊交易包含以下几个部分：</p><ul><li>交易接收者</li><li>签名（用以核实交易发送者身份）</li><li>value值（发送的以太币数量，以wei为单位）</li><li>可选数据域</li><li>STARTGAS值</li><li>GASPRICE值</li></ul><h2 id="交易中的字段"><a href="#交易中的字段" class="headerlink" title="交易中的字段"></a>交易中的字段</h2><p>根据以太坊黄皮书<a href="Ethereum_Yellow_Paper：[https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)">^1</a>，我们知道一个交易中有以下字段：</p><ul><li>nonce：该字段表示的是交易发送者的交易序列号，它是账号的一个交易计数器，这个字段能够防止重放攻击（replay attack）。</li><li>gasPrice：gas的价格，用于计算交易费用</li><li>gasLimit：执行这笔交易所花费的gas的上限</li><li>to：交易接收者的地址或者合约的地址</li><li>value：要发送的以太币数量，以wei为单位</li><li>v, s, r：签名相关的参数，通过这三个参数可以得到发送者的公钥和地址（更详细的内容参见以太坊黄皮书附录F）</li></ul><p>如果该交易是一个创建合约的交易，还可能包括以下字段：</p><ul><li>init：用于初始化交易的EVM（以太坊虚拟机）操作码</li><li>data：数据域（理论上数据域的大小是不受限制的）</li></ul><h2 id="消息（Message）是什么？"><a href="#消息（Message）是什么？" class="headerlink" title="消息（Message）是什么？"></a>消息（Message）是什么？</h2><p>信息在以太坊中是一个“虚拟”的事物，它永远不会被记录到区块链中，它是由合约发出的。从形式上看，消息很“像”交易，但是它与交易有着本质上的区别，一笔成功的交易会被永久的记录到区块链中。在以太坊中，我们可以把消息看做在EVM中的函数调用。</p><p>一般来说，一条消息会包含以下几个部分：</p><ul><li>消息的发送者</li><li>消息的接收者</li><li>以太币的数量（以wei为单位）</li><li>可选数据域</li><li>STARTGAS</li><li>GASPRICE</li></ul><h2 id="交易、消息与调用（Message-Call）的区别"><a href="#交易、消息与调用（Message-Call）的区别" class="headerlink" title="交易、消息与调用（Message Call）的区别"></a>交易、消息与调用（Message Call）的区别</h2><p>以太坊黄皮书中对交易的描述为：</p><blockquote><p>A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.<br>由外部参与者签名后的一段数据。它代表了一条信息或者一个新创建的自治对象(合约)。交易会被记录至区块链的区块中。</p></blockquote><p>对消息的描述为：</p><blockquote><p>Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.<br>在两个账户之间传输的数据（一组字节）和值（以太币的数量），形式是合约的确定性操作或者经过加密安全签名的交易。</p></blockquote><p>对调用的描述为：</p><blockquote><p>The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.<br>从一个账户发送至另一个账户的消息的行为。如果目标账户关联着非空的EVM操作码，VM就会按照该操作码的状态进行启动。如果消息的发送者是一个自治对象，那么该调用将会传递所有返回自VM操作的数据。</p></blockquote><p>具体来说，调用是对合约的本地调用，它是只读的操作并且不会消耗以太币。它能够模拟交易的行为，但是在调用结束以后，它会返回至之前的状态。交易是会被广播至整个网络的，被矿工处理验证之后会被记录至区块链的区块中。</p><h2 id="合约中函数的调用创建的是调用还是交易？"><a href="#合约中函数的调用创建的是调用还是交易？" class="headerlink" title="合约中函数的调用创建的是调用还是交易？"></a>合约中函数的调用创建的是调用还是交易？</h2><p>考虑一下这四种情况：</p><ul><li>使用调用（call）直接对合约函数进行调用</li><li>使用sendTransaction直接对合约函数进行调用</li><li>使用调用（call）通过合约对合约函数进行调用</li><li>使用sendTransaction通过合约对合约函数进行调用</li></ul><p>第一种情况与第三种情况是很明显的调用，第二种情况由于使用的是sendTransaction方法，因此它创建了一笔交易。比较特殊的是第四种情况，它看似是生成了一笔交易，但是由于以太坊黄皮书中对交易的定义中提到，交易是需要外部参与者（External Actor）进行签名的消息，所以第四种情况没有生成交易。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/20/eth-basis-transaction-and-message/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础实践】：以太坊测试私链的搭建</title>
      <link>http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/</guid>
      <pubDate>Wed, 18 Apr 2018 01:07:41 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;以太坊测试私链的搭建&quot;&gt;&lt;a href=&quot;#以太坊测试私链的搭建&quot; class=&quot;headerlink&quot; title=&quot;以太坊测试私链的搭建&quot;&gt;&lt;/a&gt;以太坊测试私链的搭建&lt;/h1&gt;&lt;p&gt;这篇文档通过使用Geth来搭建Ethereum（以太坊）私有测试链。&lt;br&gt;本文档两个节点的系统环境为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OS：Ubuntu
Memory：8G
CPU：Intel Xeon E5-2620
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="以太坊测试私链的搭建"><a href="#以太坊测试私链的搭建" class="headerlink" title="以太坊测试私链的搭建"></a>以太坊测试私链的搭建</h1><p>这篇文档通过使用Geth来搭建Ethereum（以太坊）私有测试链。<br>本文档两个节点的系统环境为：</p><pre><code>OS：UbuntuMemory：8GCPU：Intel Xeon E5-2620</code></pre><a id="more"></a><h2 id="安装Geth"><a href="#安装Geth" class="headerlink" title="安装Geth"></a>安装Geth</h2><p>Geth是通过Go语言实现的一款Ethereum客户端，通过Geth我们可以搭建Ethereum的测试私链。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum</span><br></pre></td></tr></table></figure><h2 id="搭建私有测试链"><a href="#搭建私有测试链" class="headerlink" title="搭建私有测试链"></a>搭建私有测试链</h2><p>通过搭建私有测试链，可以预分配以太币或者调低挖矿的难度来高效的获取以太币，可以便于对以太坊的测试。</p><p><strong>搭建私有测试链需要做的主要有下列这些事项：</strong></p><ul><li><strong>自定义创世块（Genesis Block）</strong></li><li><strong>自定义数据存放位置</strong></li><li><strong>自定义网络ID</strong></li><li><strong>关闭节点发现（Node Discovery）（推荐）</strong></li></ul><h3 id="自定义创世块（Genesis-Block）"><a href="#自定义创世块（Genesis-Block）" class="headerlink" title="自定义创世块（Genesis Block）"></a>自定义创世块（Genesis Block）</h3><ul><li>CustomGenesis.json</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"config"</span>: &#123;</span><br><span class="line"><span class="attr">"chainId"</span>: <span class="number">3131</span>,</span><br><span class="line"><span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"difficulty"</span>: <span class="string">"200000000"</span>,</span><br><span class="line"><span class="attr">"gasLimit"</span>: <span class="string">"2100000"</span>,</span><br><span class="line"><span class="attr">"alloc"</span>: &#123;</span><br><span class="line"><span class="attr">"7df9a875a174b3bc565e6424a0050ebc1b2d1d82"</span>: &#123; <span class="attr">"balance"</span>: <span class="string">"300"</span> &#125;,</span><br><span class="line"><span class="attr">"f41c74c9ae680c1aa78f42e5647a62f353b7bdde"</span>: &#123; <span class="attr">"balance"</span>: <span class="string">"400"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创世块是区块链中的第一个初始区块，我们通过定义<code>CustomGenesis.json</code>文件来对其进行自定义。</p><p>在创世块的配置文件<a href="Config配置参数：[https://github.com/ethereum/go-ethereum/blob/feeccdf4ec1084b38dac112ff4f86809efd7c0e5/params/config.go#L71](https://github.com/ethereum/go-ethereum/blob/feeccdf4ec1084b38dac112ff4f86809efd7c0e5/params/config.go#L71)">^1</a>中，有四个参数是必须要指定的：</p><ul><li>config：区块链的相关参数<ul><li>chainId：防止重放攻击（replay attack，简单来说就是未经授权的用户来假扮交易的发送者）</li><li>homesteadBlock：Homestead<a href="Ethereum_Homestead：[http://www.ethdocs.org/en/latest/](http://www.ethdocs.org/en/latest/)">^2</a>是以太坊的第二个发行版本（Frontier<a href="Ethereum_Frontier：[https://ethereum.gitbooks.io/frontier-guide/](https://ethereum.gitbooks.io/frontier-guide/)">^3</a>是第一个发行版本），值为0表示的使用的是该版本的以太坊</li></ul></li><li>difficult：初始挖矿难度</li><li>gasLimit：每一个区块所消耗的gas上限</li><li>alloc：可以往地址中预先分配以太币</li></ul><h3 id="生成创世块"><a href="#生成创世块" class="headerlink" title="生成创世块"></a>生成创世块</h3><p>使用下列命令来初始化创世块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir /path/to/data init /path/to/CustomGenesis.json</span><br></pre></td></tr></table></figure><ul><li><code>--datadir</code>：指定区块链的数据目录（默认为<code>~/.ethereum</code>）</li><li><code>init</code>：创世块初始化JSON文件的目录</li></ul><h3 id="启动以太坊私有测试链"><a href="#启动以太坊私有测试链" class="headerlink" title="启动以太坊私有测试链"></a>启动以太坊私有测试链</h3><p><strong>相关启动参数</strong></p><p>启动geth有如下主要参数（可以使用<code>geth --help</code>进行查看）：</p><ul><li><code>--nodiscover</code>：关闭节点的可发现性，可以防止使用了相同network id和创世块的节点连接到你的区块链网络中（只能通过手动来添加节点）</li><li><code>--maxpeers 0</code>：指定网络中的最多节点数</li><li><code>--rpc</code>：启用RPC服务</li><li><code>--rpcapi &quot;db,eth,net,web3&quot;</code>：指定启用的RPC API</li><li><code>--rpcport &quot;8080&quot;</code>：指定RPC的端口</li><li><code>--rpccorsdomain</code>：指定哪些URL可以连接到你的节点</li><li><code>--datadir</code>：以太坊区块链的数据目录</li><li><code>--port</code>：连接到其它节点的网络监听端口</li><li><code>--identity &quot;FirstNode&quot;</code>：指定节点名称</li><li><code>console</code>：启动geth控制台程序</li></ul><p><strong>启动geth</strong></p><p>使用以下命令来启动geth：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --identity "ETH-MainNode" --rpc --rpcport "6060" --rpccorsdomain "*" --datadir "/home/lyh/privatechain-eth/data" --port "30303" --nodiscover --maxpeers 5 --rpcapi "admin,db,eth,debug,miner,net,shh,txpool,personal,web3" --networkid 3131 console</span><br></pre></td></tr></table></figure><p>使用相同的配置对两个节点进行配置并启动。</p><h3 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h3><p>在其中一个节点的geth控制台中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin.nodeInfo</span></span><br></pre></td></tr></table></figure><p>我们得到该节点的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin.nodeInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  enode: "enode://09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7@[::]:30303",</span><br><span class="line">  id: "09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7",</span><br><span class="line">  ip: "::",</span><br><span class="line">  listenAddr: "[::]:30303",</span><br><span class="line">  name: "Geth/ETH-MainNode/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4",</span><br><span class="line">  ports: &#123;</span><br><span class="line">    discovery: 30303,</span><br><span class="line">    listener: 30303</span><br><span class="line">  &#125;,</span><br><span class="line">  protocols: &#123;</span><br><span class="line">    eth: &#123;</span><br><span class="line">      config: &#123;</span><br><span class="line">        chainId: 3131,</span><br><span class="line">        eip150Hash: "0x0000000000000000000000000000000000000000000000000000000000000000",</span><br><span class="line">        eip155Block: 0,</span><br><span class="line">        eip158Block: 0,</span><br><span class="line">        homesteadBlock: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      difficulty: 92699744128,</span><br><span class="line">      genesis: "0x54fd3f9117e7d8c5b130af59fed07ddc9eef0826016d4d5b9c07db8db1dfac23",</span><br><span class="line">      head: "0xd67ba0763b4fc50741b33205e486d0113aa182d310ee0225332459d104ed5b58",</span><br><span class="line">      network: 3131</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到enode信息：<br>    enode://09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7@[::]:30303</p><p>我们需要在另一台节点上添加上该节点，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin.addPeer(<span class="string">"09444457dd475ac1a81948c5066602d23abd49407cae33edef929c9d96374396496f97b1a8fb1c22d36d990e90ed16a2a4faf3fd2ae63c08f4f58ee6249bcec7@[::]:30303"</span>)</span></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>我们需要将上述enode信息中的<code>[::]</code>更换为该节点的IP地址。</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> net.peerCount</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>我们看到已经添加了一个节点。</p><h2 id="测试以太坊私有链"><a href="#测试以太坊私有链" class="headerlink" title="测试以太坊私有链"></a>测试以太坊私有链</h2><p>我们可以通过在两个节点分别创建账号构造一笔转账交易来验证多节点的私链是否搭建成功。</p><p><strong>分别在两个节点中创建账号：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> personal.newAccount()</span></span><br></pre></td></tr></table></figure><p>设置密码后，得到地址：</p><p>节点一：<br>    &gt; “0xa9436991e002986f58d948d79e737df190c4f26b”</p><p>节点二：<br>    &gt; “0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec”</p><p><strong>开始挖矿：</strong></p><p>由于新创建的账号中是没有以太币的，因此我们需要启用矿工进行挖矿：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.setEtherbase(<span class="string">"0xa9436991e002986f58d948d79e737df190c4f26b"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.start(1)</span></span><br></pre></td></tr></table></figure><p>另一个节点同样开启挖矿：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.setEtherbase(<span class="string">"0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> miner.start(1)</span></span><br></pre></td></tr></table></figure><p><strong>构造一笔交易：</strong></p><p>在进行转账之前，我们需要对钱包进行解锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> personal.unlockAccount(<span class="string">"0xa9436991e002986f58d948d79e737df190c4f26b"</span>)</span></span><br></pre></td></tr></table></figure><p>输入密码对钱包进行解锁后，构造一笔转账交易：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> eth.sendTransaction(&#123;from: <span class="string">"0xa9436991e002986f58d948d79e737df190c4f26b"</span>, to: <span class="string">"0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec"</span>, value: web3.toWei(10, <span class="string">"ether"</span>)&#125;)</span></span><br></pre></td></tr></table></figure><p>在交易被矿工进行验证与打包至区块之后，我们可以查询一下钱包的余额来验证交易是否完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> eth.getBalance(<span class="string">"0xf7be2382f03cf7dd8ed5e59253a7b9321aac20ec"</span>)</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/18/set-up-eth-private-chain-for-development/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Ethereum基础】：账户、地址、私钥和公钥</title>
      <link>http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/</guid>
      <pubDate>Tue, 17 Apr 2018 01:33:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;在以太坊中，账户、地址、私钥（Private Key）和公钥（Public Key）是非常重要的概念。账户扮演着以太坊的中心角色，地址是我们与以太坊系统进行交互的标识，它是以太坊账户与外界进行交互的名字，而私钥与公钥是保护我们账户安全的重要屏障。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在以太坊中，账户、地址、私钥（Private Key）和公钥（Public Key）是非常重要的概念。账户扮演着以太坊的中心角色，地址是我们与以太坊系统进行交互的标识，它是以太坊账户与外界进行交互的名字，而私钥与公钥是保护我们账户安全的重要屏障。</p><a id="more"></a><h2 id="什么是账户（Accounts）？"><a href="#什么是账户（Accounts）？" class="headerlink" title="什么是账户（Accounts）？"></a>什么是账户（Accounts）？</h2><p>账户在以太坊中扮演者十分重要的角色，它是以太坊的中心概念。在以太坊中，有两种类型的账户<a href="Ethereum_Accounts：[http://ethdocs.org/en/latest/account-management.html#accounts](http://ethdocs.org/en/latest/account-management.html#accounts)">^1</a>：一种是外部账户（EOAs，Externally Owned Accounts），另一种是合约账户（Contracts Accounts）。当我们提到账户这个术语的时候，我们通常指的是外部账户（EOA），当提到合约账户的时候我们通常称其为“合约”。</p><p>不论是外部账户还是合约账户，它们在以太坊中所维护的都是一系列叫做状态对象（state objects）的实体。这些实体中都拥有状态信息：外部账户存储的是账户的余额（balance），合约账户存储的是余额和合约中的内容。它们存储的这些状态会通过以太坊网络进行更新以及保证数据的一致性。账户是用户在以太坊区块链上创建交易必不可少的一部分。</p><p>账户标识了以太坊网络中每一个参与者的身份，每一笔交易都需要通过账户使用公钥加密进行签名才能够正常进行，这样的话，EVM（以太坊虚拟机）才能够对交易发送者进行验证来确保交易的真实可靠。</p><h2 id="什么是以太坊地址（Address）？"><a href="#什么是以太坊地址（Address）？" class="headerlink" title="什么是以太坊地址（Address）？"></a>什么是以太坊地址（Address）？</h2><p>一个以太坊地址就代表着一个以太坊账户，地址是账户的标识。对于外部账户来说，地址表示的是该账户公钥的后20字节（通常会以0x开头，例如，<code>0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826</code>，该地址使用的是16进制表示法<a href="Hexadecimal_Format：[http://ethdocs.org/en/latest/glossary.html#hexadecimal](http://ethdocs.org/en/latest/glossary.html#hexadecimal)">^2</a>）。上述示例中的地址中的字母全部是小写。在EIP55<a href="EIP55：[https://github.com/ethereum/EIPs/issues/55](https://github.com/ethereum/EIPs/issues/55)">^3</a>中引入了一种大小写混用的地址表示方法，通过这种表示方法进行表示的地址隐含了一个校验和（checksum）能够验证该地址的有效性。</p><h2 id="什么是私钥和公钥？"><a href="#什么是私钥和公钥？" class="headerlink" title="什么是私钥和公钥？"></a>什么是私钥和公钥？</h2><p>每个账户都由一对钥匙定义，一个私钥（Private Key）和一个公钥（Public Key）。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥/地址都编码在一个钥匙文件里。该文件是JSON格式的，下面我们将会查看一个私钥文件示例（Keystore）。</p><p>以太坊的私钥是一串64位16进制字符（32字节）。它是账户安全最重要的部分，需要妥善保管，如果丢失了私钥也就意味着你的账户丢失了。</p><h2 id="查看一个Keystore文件"><a href="#查看一个Keystore文件" class="headerlink" title="查看一个Keystore文件"></a>查看一个Keystore文件</h2><p>Keystore文件通常保存在以太坊数据目录的<code>keystore</code>文件夹下，它是JSON格式的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="attr">"address"</span>:<span class="string">"358f94366124d9f2817b09c84921d2a653f5ac0c"</span>,</span><br><span class="line">   <span class="attr">"crypto"</span>:&#123;  </span><br><span class="line">      <span class="attr">"cipher"</span>:<span class="string">"aes-128-ctr"</span>,</span><br><span class="line">      <span class="attr">"ciphertext"</span>:<span class="string">"41c14f88ec8f35c9fe57cd39121a76c2dadbd82ea8fec59866468bc0d7371f2e"</span>,</span><br><span class="line">      <span class="attr">"cipherparams"</span>:&#123;  </span><br><span class="line">         <span class="attr">"iv"</span>:<span class="string">"43443bf394e8f6ebcc687e13bc0effb9"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"kdf"</span>:<span class="string">"scrypt"</span>,</span><br><span class="line">      <span class="attr">"kdfparams"</span>:&#123;  </span><br><span class="line">         <span class="attr">"dklen"</span>:<span class="number">32</span>,</span><br><span class="line">         <span class="attr">"n"</span>:<span class="number">262144</span>,</span><br><span class="line">         <span class="attr">"p"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"r"</span>:<span class="number">8</span>,</span><br><span class="line">         <span class="attr">"salt"</span>:<span class="string">"aaef6847d09cb1e9f5ceadaf5865d96a7493df1cae146b24e31092cc0a7844af"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"mac"</span>:<span class="string">"5e9781c587db5795c6d41cb4f001bf086cc3db33b6e7eefcc2ef472145e76821"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"id"</span>:<span class="string">"bcd61a88-283f-4d81-8457-30ec9c11521f"</span>,</span><br><span class="line">   <span class="attr">"version"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过keystore文件中的内容，我们可以看到其中包括了私钥加密的相关信息：</p><ul><li>address：该账户的地址</li><li>cipher：加密方法使用的是AES-128-CTR算法<a href="AES五种加密模式（CBC、ECB、CTR、OCF、CFB）：[https://www.cnblogs.com/starwolf/p/3365834.html](https://www.cnblogs.com/starwolf/p/3365834.html)">^4</a></li><li>ciphertext：加密后的密文</li><li>cipherparams：AES-128-CTR算法加密所需的相关参数</li><li>kdf：秘钥生成函数，用于使用密码对keystore文件进行加密</li><li>kdfparams：kdf算法所需的参数</li><li>mac：用于验证密码的编码</li></ul><h2 id="私钥、公钥和地址是如何生成的？"><a href="#私钥、公钥和地址是如何生成的？" class="headerlink" title="私钥、公钥和地址是如何生成的？"></a>私钥、公钥和地址是如何生成的？</h2><p>大体来说，地址的生成的流程是：私钥 -> 公钥 -> 地址。因此地址的生成需要三步：</p><ol><li>生成一个随机的私钥（32字节）</li><li>通过私钥生成公钥（64字节）</li><li>通过公钥得到地址（20字节）</li></ol><p><strong>私钥的生成</strong></p><p>私钥是一组64位的16进制字符，通过私钥我们能够访问一个账户。以太坊的私钥生成是通过secp256k1<a href="Secp256k1：[https://en.bitcoin.it/wiki/Secp256k1](https://en.bitcoin.it/wiki/Secp256k1)">^5</a>曲线生成的，secp256k1是一个椭圆曲线算法，比特币使用的也是相同的曲线算法。</p><p>通过OpenSSL<a href="OpenSSL：[https://github.com/openssl/openssl](https://github.com/openssl/openssl)">^6</a>我们可以生成一个椭圆曲线私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ openssl ecparam -name secp256k1 -genkey -noout                                                                                                                                                                                                                    </span><br><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MHQCAQEEICGlTPPQInj0R/jaa7+bjF1twiR3RDLdOChSq98L5FmWoAcGBSuBBAAK</span><br><span class="line">oUQDQgAERynScthXq2n4Ahkfp08s/QNogZEtVCfQE/XTvpjsnIeQEZGJIOb+Liyl</span><br><span class="line">uF8PIerBE1CjvCs5LLU+fZz+B31+Bg==</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p><strong>公钥的生成</strong></p><p>其实，通过OpenSSL我们可以同时得到私钥和公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> openssl ecparam -name secp256k1 -genkey -noout | openssl ec -text -noout                                                                                                                                                                                          </span></span><br><span class="line">read EC key</span><br><span class="line">Private-Key: (256 bit)</span><br><span class="line">priv:</span><br><span class="line">    3f:64:bb:20:0a:b5:82:e9:73:03:8a:8b:79:68:62:</span><br><span class="line">    41:8b:98:a7:10:00:fb:50:de:c4:4d:0d:06:3d:a2:</span><br><span class="line">    ed:cd</span><br><span class="line">pub:</span><br><span class="line">    04:4a:18:c2:c7:40:f4:9a:77:b2:89:e9:27:0c:39:</span><br><span class="line">    94:8b:94:10:a1:b0:c9:81:d9:af:06:8c:06:23:93:</span><br><span class="line">    63:d7:26:82:fd:b0:22:fe:f6:7f:4f:8a:69:58:2f:</span><br><span class="line">    98:3a:b3:94:ab:5f:06:85:4c:25:f3:3d:8e:f1:35:</span><br><span class="line">    2f:e7:fe:50:4d</span><br><span class="line">ASN1 OID: secp256k1</span><br></pre></td></tr></table></figure><p><strong>地址的生成</strong></p><p>地址是通过对上述的公钥做Keccak-256哈希<a href="Keccak-256_Online：[https://emn178.github.io/online-tools/keccak\_256.html](https://emn178.github.io/online-tools/keccak_256.html)">^7</a>，然后取最后的40位16进制字符得到的。我们对上述的公钥做哈希后并取后40位的结果是：<code>0x24602722816b6cad0e143ce9fabf31f6026ec622</code>。得到的该结果就是一个有效的以太坊地址。</p><h2 id="如何验证地址的有效性"><a href="#如何验证地址的有效性" class="headerlink" title="如何验证地址的有效性"></a>如何验证地址的有效性</h2><p><strong>Geth Web3进行验证：</strong></p><p>通过以太坊客户端Geth的Web3接口可以对以太坊地址进行有效性验证：</p><pre><code>&gt; web3.utils.isAddress(&apos;0xc1912fee45d61c87cc5ea59dae31190fffff232d&apos;);&gt; true</code></pre><p><strong>通过第三方JS库进行验证：</strong></p><p>wallet-address-validator<a href="wallet-address-validator：[https://github.com/ognus/wallet-address-validator](https://github.com/ognus/wallet-address-validator)">^8</a>是一个JavaScript库能够对多种加密货币的地址进行验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WAValidator = <span class="built_in">require</span>(<span class="string">'wallet-address-validator'</span>);</span><br><span class="line"><span class="keyword">var</span> valid1 = WAValidator.validate(<span class="string">'0x24602722816b6cad0e143ce9fabf31f6026ec622'</span>, <span class="string">'ETH'</span>);</span><br><span class="line"><span class="keyword">if</span>(valid1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'This is a valid address'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Address INVALID'</span>);</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/17/eth-basis-accounts-address-pubkey-prikey/#disqus_thread</comments>
    </item>
    
    <item>
      <title>多节点FastCoin山寨币的搭建</title>
      <link>http://blog.luoyuanhang.com/2018/04/08/fastcoin-multinodes/</link>
      <guid>http://blog.luoyuanhang.com/2018/04/08/fastcoin-multinodes/</guid>
      <pubDate>Sun, 08 Apr 2018 14:10:28 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章给出了Fastcoin多节点环境的搭建文档，FastCoin是一个由&lt;a href=&quot;https://github.com/imharrywu/fastcoin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@harrywu&lt;/a&gt;修改&lt;a href=&quot;https://github.com/bitcoin/bitcoin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BitCoin源代码&lt;/a&gt;产生的一个简单的山寨币。该山寨币在原有BitCoin源码基础上，对BitCoin相关网络参数、创世块信息、工作量机制等进行了修改，从而构建出了一个简单的山寨币系统，该系统加快了原有的挖矿速度，能够更方便的进行区块链开发的相关测试。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章给出了Fastcoin多节点环境的搭建文档，FastCoin是一个由<a href="https://github.com/imharrywu/fastcoin" target="_blank" rel="noopener">@harrywu</a>修改<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">BitCoin源代码</a>产生的一个简单的山寨币。该山寨币在原有BitCoin源码基础上，对BitCoin相关网络参数、创世块信息、工作量机制等进行了修改，从而构建出了一个简单的山寨币系统，该系统加快了原有的挖矿速度，能够更方便的进行区块链开发的相关测试。</p></blockquote><a id="more"></a><h1 id="1-FastCoin简介"><a href="#1-FastCoin简介" class="headerlink" title="1 FastCoin简介"></a>1 FastCoin简介</h1><p>FastCoin是一个由<a href="https://github.com/imharrywu/fastcoin" target="_blank" rel="noopener">@harrywu</a>修改<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">BitCoin源代码</a>产生的一个简单的<a href="https://blog.csdn.net/hacode/article/details/40422535" target="_blank" rel="noopener">山寨币</a>。该山寨币在原有BitCoin源码基础上，对BitCoin相关网络参数、创世块信息、工作量机制等进行了修改，从而构建出了一个简单的山寨币系统，该系统加快了原有的挖矿速度，能够更方便的进行区块链开发的相关测试。</p><h1 id="2-系统环境"><a href="#2-系统环境" class="headerlink" title="2 系统环境"></a>2 系统环境</h1><p>该文档的采用了两个节点进行测试，两个节点的系统环境如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS: Ubuntu</span><br><span class="line">Linux Kernel: Linux 4.4.0</span><br><span class="line">Memory: 1G</span><br><span class="line">gcc Version: 5.4.0</span><br><span class="line">g++ Version: 5.4.0</span><br></pre></td></tr></table></figure><h1 id="3-安装准备"><a href="#3-安装准备" class="headerlink" title="3 安装准备"></a>3 安装准备</h1><p>该文档采用两个节点对FastCoin山寨币进行搭建，两个节点做同样的配置。</p><h2 id="3-1-获取FastCoin源码"><a href="#3-1-获取FastCoin源码" class="headerlink" title="3.1 获取FastCoin源码"></a>3.1 获取FastCoin源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/imharrywu/fastcoin.git</span><br></pre></td></tr></table></figure><h2 id="3-2-安装项目构建依赖"><a href="#3-2-安装项目构建依赖" class="headerlink" title="3.2 安装项目构建依赖"></a>3.2 安装项目构建依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libtool autotools-dev autoconf pkg-config libssl-dev</span><br></pre></td></tr></table></figure><h2 id="3-3-安装Berkeley-DB-4-8"><a href="#3-3-安装Berkeley-DB-4-8" class="headerlink" title="3.3 安装Berkeley DB 4.8"></a>3.3 安装Berkeley DB 4.8</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fastcoin/</span><br><span class="line">BITCOIN_ROOT=$(<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 Berkeley DB安装路径，此处为fastcoin子目录下</span></span><br><span class="line">BDB_PREFIX=<span class="string">"<span class="variable">$&#123;BITCOIN_ROOT&#125;</span>/db4"</span></span><br><span class="line">mkdir -p <span class="variable">$BDB_PREFIX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">wget <span class="string">'http://download.oracle.com/berkeley-db/db-4.8.30.NC.tar.gz'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'12edc0df75bf9abd7f82f821795bcee50f42cb2e5f76a6a281b85732798364ef  db-4.8.30.NC.tar.gz'</span> | sha256sum -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结应该为： -&gt; db-4.8.30.NC.tar.gz: OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xzvf db-4.8.30.NC.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建安装</span></span><br><span class="line"><span class="built_in">cd</span> db-4.8.30.NC/build_unix/</span><br><span class="line">../dist/configure --<span class="built_in">enable</span>-cxx --<span class="built_in">disable</span>-shared --with-pic --prefix=<span class="variable">$BDB_PREFIX</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="3-4-安装Boost"><a href="#3-4-安装Boost" class="headerlink" title="3.4 安装Boost"></a>3.4 安装Boost</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libboost-all-dev</span><br></pre></td></tr></table></figure><h2 id="3-5-安装miniupnp"><a href="#3-5-安装miniupnp" class="headerlink" title="3.5 安装miniupnp"></a>3.5 安装miniupnp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://miniupnp.tuxfamily.org/files/download.php?file=miniupnpc-1.6.20120410.tar.gz</span><br><span class="line">tar -xzvf miniupnpc-1.6.20120410.tar.gz</span><br><span class="line"><span class="built_in">cd</span> miniupnpc-1.6</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>也可以使用Ubuntu源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libminiupnpc-dev</span><br></pre></td></tr></table></figure><h1 id="4-搭建过程"><a href="#4-搭建过程" class="headerlink" title="4 搭建过程"></a>4 搭建过程</h1><h2 id="4-1-编译源码"><a href="#4-1-编译源码" class="headerlink" title="4.1 编译源码"></a>4.1 编译源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure --with-miniupnpc --without-gui --<span class="built_in">enable</span>-upnp-default LDFLAGS=<span class="string">"-L<span class="variable">$&#123;BDB_PREFIX&#125;</span>/lib/"</span> CPPFLAGS=<span class="string">"-I<span class="variable">$&#123;BDB_PREFIX&#125;</span>/include/"</span> --<span class="built_in">enable</span>-wallet</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译安装之后，在<code>src</code>目录下会生成相应的二进制文件，主要用到的二进制文件有：</p><ul><li>bitcoind：fastcoin主程序</li><li>bitcoin-cli：fastcoin RPC控制台程序</li></ul><p><em>如果在编译过程中遭遇如下报错信息，详见【6.1 Boost依赖库引起的报错】：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/boost/variant/get.hpp:178:5: error: invalid application of <span class="string">'sizeof'</span> to incomplete <span class="built_in">type</span> <span class="string">'boost::STATIC_ASSERTION_FAILURE&lt;false&gt;'</span></span><br><span class="line">     BOOST_STATIC_ASSERT_MSG(</span><br><span class="line">     ^</span><br><span class="line">Makefile:3654: recipe <span class="keyword">for</span> target <span class="string">'libbitcoin_server_a-rpcrawtransaction.o'</span> failed</span><br><span class="line">make[2]: *** [libbitcoin_server_a-rpcrawtransaction.o] Error 1</span><br></pre></td></tr></table></figure><h2 id="4-2-相关configuration参数"><a href="#4-2-相关configuration参数" class="headerlink" title="4.2 相关configuration参数"></a>4.2 相关configuration参数</h2><ul><li><code>--without-gui</code>：不使用GUI，如果需要图形化界面，详见【6.6 图形化界面钱包的构建】</li><li><code>--enable-wallet:</code>启用钱包（不启用钱包<code>--disable-wallet</code>也可以进行挖矿，如果不启用钱包，则无需安装Berkeley DB）</li><li><code>--enable-debug:</code>启用debug模式</li><li><code>--enable-tests:</code>对测试程序进行编译</li><li><code>CPPFLAGS</code>、<code>LDFLAGS</code>：指定Berkeley DB的路径</li></ul><h1 id="5-FastCoin测试"><a href="#5-FastCoin测试" class="headerlink" title="5 FastCoin测试"></a>5 FastCoin测试</h1><h2 id="5-1-FastCoin配置文件"><a href="#5-1-FastCoin配置文件" class="headerlink" title="5.1 FastCoin配置文件"></a>5.1 FastCoin配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.fastcoin/fastcoin.conf</span><br></pre></td></tr></table></figure><p>在<code>fastcoin.conf</code>文件中添加如下配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">rpcuser=user</span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">rpcpassword=password</span><br><span class="line"></span><br><span class="line">daemon=1</span><br><span class="line">txindex=1</span><br><span class="line">server=1</span><br></pre></td></tr></table></figure><h2 id="5-2-启动bitcoind"><a href="#5-2-启动bitcoind" class="headerlink" title="5.2 启动bitcoind"></a>5.2 启动bitcoind</h2><p>在其中一个节点中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fastcoin/src</span><br><span class="line">./bincoind -gen=1 -reindex -checkpoints=0</span><br></pre></td></tr></table></figure><p>另一个节点执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bincoind -gen=1 -reindex -checkpoints=0 -addnode=<span class="string">"另一个节点的IP，例：192.169.1.233"</span></span><br></pre></td></tr></table></figure><h2 id="5-3-bitcoind相关启动参数"><a href="#5-3-bitcoind相关启动参数" class="headerlink" title="5.3 bitcoind相关启动参数"></a>5.3 bitcoind相关启动参数</h2><ul><li><code>-rpcuser=</code>：指定用户名</li><li><code>-rpcpassword=</code>：指定密码</li><li><code>-daemon=</code>：bitcoind作为daemon进程在后台运行</li><li><code>-gen=</code>：生成山寨币（挖矿）</li><li><code>-addnode=</code>：添加节点</li><li><code>-reindex</code>：bitcoind启动时从当前<code>blk000??.dat</code>文件中的index重建区块链</li><li><code>-server</code>：启用RPC服务器</li></ul><h2 id="5-4-bitcoin-cli"><a href="#5-4-bitcoin-cli" class="headerlink" title="5.4 bitcoin-cli"></a>5.4 bitcoin-cli</h2><p>使用<code>./bitcoin-cli &lt;parameters&gt;</code>可以查看当前区块链、网络、钱包等信息。</p><p>相关参数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">== Blockchain ==</span><br><span class="line">getbestblockhash</span><br><span class="line">getblock &quot;hash&quot; ( verbose )</span><br><span class="line">getblockchaininfo</span><br><span class="line">getblockcount</span><br><span class="line">getblockhash index</span><br><span class="line">getchaintips</span><br><span class="line">getdifficulty</span><br><span class="line">getmempoolinfo</span><br><span class="line">getrawmempool ( verbose )</span><br><span class="line">gettxout &quot;txid&quot; n ( includemempool )</span><br><span class="line">gettxoutsetinfo</span><br><span class="line">verifychain ( checklevel numblocks )</span><br><span class="line"></span><br><span class="line">== Control ==</span><br><span class="line">getinfo</span><br><span class="line">help ( &quot;command&quot; )</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">== Generating ==</span><br><span class="line">getgenerate</span><br><span class="line">setgenerate generate ( genproclimit )</span><br><span class="line"></span><br><span class="line">== Mining ==</span><br><span class="line">getblocktemplate ( &quot;jsonrequestobject&quot; )</span><br><span class="line">getmininginfo</span><br><span class="line">getnetworkhashps ( blocks height )</span><br><span class="line">prioritisetransaction &lt;txid&gt; &lt;priority delta&gt; &lt;fee delta&gt;</span><br><span class="line">submitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )</span><br><span class="line"></span><br><span class="line">== Network ==</span><br><span class="line">addnode &quot;node&quot; &quot;add|remove|onetry&quot;</span><br><span class="line">getaddednodeinfo dns ( &quot;node&quot; )</span><br><span class="line">getconnectioncount</span><br><span class="line">getnettotals</span><br><span class="line">getnetworkinfo</span><br><span class="line">getpeerinfo</span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line">== Rawtransactions ==</span><br><span class="line">createrawtransaction [&#123;&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n&#125;,...] &#123;&quot;address&quot;:amount,...&#125;</span><br><span class="line">decoderawtransaction &quot;hexstring&quot;</span><br><span class="line">decodescript &quot;hex&quot;</span><br><span class="line">getrawtransaction &quot;txid&quot; ( verbose )</span><br><span class="line">sendrawtransaction &quot;hexstring&quot; ( allowhighfees )</span><br><span class="line">signrawtransaction &quot;hexstring&quot; ( [&#123;&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;&#125;,...] [&quot;privatekey1&quot;,...] sighashtype )</span><br><span class="line"></span><br><span class="line">== Util ==</span><br><span class="line">createmultisig nrequired [&quot;key&quot;,...]</span><br><span class="line">estimatefee nblocks</span><br><span class="line">estimatepriority nblocks</span><br><span class="line">validateaddress &quot;fastcoinaddress&quot;</span><br><span class="line">verifymessage &quot;fastcoinaddress&quot; &quot;signature&quot; &quot;message&quot;</span><br><span class="line"></span><br><span class="line">== Wallet ==</span><br><span class="line">addmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )</span><br><span class="line">backupwallet &quot;destination&quot;</span><br><span class="line">dumpprivkey &quot;fastcoinaddress&quot;</span><br><span class="line">dumpwallet &quot;filename&quot;</span><br><span class="line">encryptwallet &quot;passphrase&quot;</span><br><span class="line">getaccount &quot;fastcoinaddress&quot;</span><br><span class="line">getaccountaddress &quot;account&quot;</span><br><span class="line">getaddressesbyaccount &quot;account&quot;</span><br><span class="line">getbalance ( &quot;account&quot; minconf includeWatchonly )</span><br><span class="line">getnewaddress ( &quot;account&quot; )</span><br><span class="line">getrawchangeaddress</span><br><span class="line">getreceivedbyaccount &quot;account&quot; ( minconf )</span><br><span class="line">getreceivedbyaddress &quot;fastcoinaddress&quot; ( minconf )</span><br><span class="line">gettransaction &quot;txid&quot; ( includeWatchonly )</span><br><span class="line">getunconfirmedbalance</span><br><span class="line">getwalletinfo</span><br><span class="line">importaddress &quot;address&quot; ( &quot;label&quot; rescan )</span><br><span class="line">importprivkey &quot;fastcoinprivkey&quot; ( &quot;label&quot; rescan )</span><br><span class="line">importwallet &quot;filename&quot;</span><br><span class="line">keypoolrefill ( newsize )</span><br><span class="line">listaccounts ( minconf includeWatchonly)</span><br><span class="line">listaddressgroupings</span><br><span class="line">listlockunspent</span><br><span class="line">listreceivedbyaccount ( minconf includeempty includeWatchonly)</span><br><span class="line">listreceivedbyaddress ( minconf includeempty includeWatchonly)</span><br><span class="line">listsinceblock ( &quot;blockhash&quot; target-confirmations includeWatchonly)</span><br><span class="line">listtransactions ( &quot;account&quot; count from includeWatchonly)</span><br><span class="line">listunspent ( minconf maxconf  [&quot;address&quot;,...] )</span><br><span class="line">lockunspent unlock [&#123;&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n&#125;,...]</span><br><span class="line">move &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )</span><br><span class="line">sendfrom &quot;fromaccount&quot; &quot;tofastcoinaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )</span><br><span class="line">sendmany &quot;fromaccount&quot; &#123;&quot;address&quot;:amount,...&#125; ( minconf &quot;comment&quot; )</span><br><span class="line">sendtoaddress &quot;fastcoinaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; )</span><br><span class="line">setaccount &quot;fastcoinaddress&quot; &quot;account&quot;</span><br><span class="line">settxfee amount</span><br><span class="line">signmessage &quot;fastcoinaddress&quot; &quot;message&quot;</span><br></pre></td></tr></table></figure><p>具体的RPC调用可以参考<a href="http://chainquery.com/bitcoin-api" target="_blank" rel="noopener">BitCoin RPC API文档</a>。</p><h1 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6 注意事项"></a>6 注意事项</h1><h2 id="6-1-Boost依赖库引起的报错"><a href="#6-1-Boost依赖库引起的报错" class="headerlink" title="6.1 Boost依赖库引起的报错"></a>6.1 Boost依赖库引起的报错</h2><p>如果在编译FastCoin源码过程中遭遇如下报错信息，则需要我们对FastCoin源码进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/boost/variant/get.hpp:178:5: error: invalid application of <span class="string">'sizeof'</span> to incomplete <span class="built_in">type</span> <span class="string">'boost::STATIC_ASSERTION_FAILURE&lt;false&gt;'</span></span><br><span class="line">     BOOST_STATIC_ASSERT_MSG(</span><br><span class="line">     ^</span><br><span class="line">Makefile:3654: recipe <span class="keyword">for</span> target <span class="string">'libbitcoin_server_a-rpcrawtransaction.o'</span> failed</span><br><span class="line">make[2]: *** [libbitcoin_server_a-rpcrawtransaction.o] Error 1</span><br></pre></td></tr></table></figure><p>将<code>src/rpcrawtransaction.c</code>文件中的第288行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CScriptID&amp; hash = boost::get&lt;<span class="keyword">const</span> CScriptID&amp;&gt;(address);</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CScriptID&amp; hash = boost::get&lt;CScriptID&gt;(address);</span><br></pre></td></tr></table></figure><h2 id="6-2-Berkeley-DB安装问题"><a href="#6-2-Berkeley-DB安装问题" class="headerlink" title="6.2 Berkeley DB安装问题"></a>6.2 Berkeley DB安装问题</h2><p>如果不想对Berkeley DB的源码进行编译安装，还可以直接采用Debian源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:bitcoin/bitcoin</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libdb4.8-dev libdb4.8++-dev</span><br></pre></td></tr></table></figure><h2 id="6-3-nTXConfirmTarget参数"><a href="#6-3-nTXConfirmTarget参数" class="headerlink" title="6.3 nTXConfirmTarget参数"></a>6.3 nTXConfirmTarget参数</h2><p>该参数是确认目标值，用于计算矿工费用，默认值为1，适用于双节点的系统，如需对该参数进行修改。可以在执行<code>./bitcoind</code>时添加参数<code>-txconfirmtarget=number</code>进行配置。</p><h2 id="6-4-txindex参数问题"><a href="#6-4-txindex参数问题" class="headerlink" title="6.4 txindex参数问题"></a>6.4 txindex参数问题</h2><p>如果在<code>~/.fastcoin/fastcoin.conf</code>配置文件中添加了<code>txindex</code>参数，则需要在启动<code>bitcoind</code>时添加启动参数<code>—reindex</code>。</p><h2 id="6-5-图形化界面钱包的构建"><a href="#6-5-图形化界面钱包的构建" class="headerlink" title="6.5 图形化界面钱包的构建"></a>6.5 图形化界面钱包的构建</h2><p>如需使用图形化界面的钱包，需要安装QT并且在<code>./congfiguration</code>时不使用<code>--without-gui</code>选项，FastCoin默认使用QT4：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libqt4-dev libprotobuf-dev protobuf-compiler</span><br></pre></td></tr></table></figure><p>如需使用QT5，需要采用<code>--with-gui=qt5</code>选项，并安装QT5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2018/04/08/fastcoin-multinodes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>容错虚拟机分布式系统的设计</title>
      <link>http://blog.luoyuanhang.com/2017/05/20/ftvm-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/05/20/ftvm-notes/</guid>
      <pubDate>Sat, 20 May 2017 07:39:57 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章是我阅读论文《&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/vm-ft.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Design of a Practical System for Fault-Tolerant Virtual Machines&lt;/a&gt;》时的笔记，这篇论文是 VMware 发表的论文，使用虚拟机来设计一个分布式容错系统。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章是我阅读论文《<a href="http://nil.csail.mit.edu/6.824/2017/papers/vm-ft.pdf" target="_blank" rel="noopener">The Design of a Practical System for Fault-Tolerant Virtual Machines</a>》时的笔记，这篇论文是 VMware 发表的论文，使用虚拟机来设计一个分布式容错系统。</p></blockquote><a id="more"></a><p>在分布式系统中，容错方法有很多种，常见的传统方法有：主/副服务器方法（当主服务器宕机之后，由副服务器来接管它的工作），这种方法通常需要机器之间的高带宽。</p><p>另外还有确定（deterministic）状态机方法：将另一台服务器初始化为和主服务器一样的状态，然后让它们都接受到同样的输入，这样它们的状态始终保持一致，但是这种方法对于非确定的（non-deterministic）操作并不适用。</p><p>本文中讨论的方法是使用虚拟机作为状态机，它具有以下优点：</p><ul><li>操作全部被虚拟化</li><li>虚拟机本身就支持 non-deterministic 操作</li><li>虚拟机管理程序（Hypervision）能够记录所有在虚拟机上的操作，所以能够记录主服务器（Primary）所有操作，然后在副服务器（Backup）上进行演绎</li></ul><h1 id="基本设计方案"><a href="#基本设计方案" class="headerlink" title="基本设计方案"></a>基本设计方案</h1><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1ffrt85wk4wj20a50bmdh1.jpg" alt=""></p><p>如图就是本文提到的容错系统的架构，一个 Primary，一个 Backup，Primary 和 Backup 之间通过 Logging Channel 进行通信，Primary 和 Backup 基本保持同步，Backup 稍稍落后，它们两个之间会通过 heartbeat 进行 fail 检测，并且它们使用共享磁盘（Shared Disk）。</p><h2 id="确定（deterministic）操作的演绎"><a href="#确定（deterministic）操作的演绎" class="headerlink" title="确定（deterministic）操作的演绎"></a>确定（deterministic）操作的演绎</h2><p>让两台机器初始状态相同，它们接受相同的输入，顺序相同，两台机器执行的任务的结果就会相同。</p><p>但是如果存在非确定的（non-deterministic）操作（比如中断事件、读取CPU时钟计数器的值操作就是非确定的），它会影响状态机的执行。</p><p>难点在于：</p><ul><li>需要捕捉全部的输入和 non-deterministic 操作在保证 Backup 是deterministic 的</li><li>需要准确将全部输入和 non-deterministic 操作应用到 Backup 中</li><li>需要保证系统高效</li></ul><p>设计方案为：将所有的 input 和 non-deterministic 操作写入到 log 中（file），对于 non-deterministic 操作还要记录和它相关的状态信息等，确保 non-deterministic 操作后Backup状态还是和 Primary 一致</p><h2 id="FT（Fault-Tolerance）协议"><a href="#FT（Fault-Tolerance）协议" class="headerlink" title="FT（Fault-Tolerance）协议"></a>FT（Fault-Tolerance）协议</h2><p>FT 协议是应用于 logging channel 的协议，协议的基本要求为：</p><p>如果 Primary 宕机了，Backup 接替它的工作，Backup 之后向外界发出所有的 Output 要和 Primary 原本应当发送的一致。</p><p>为了保证以上的要求，设计如下系统：</p><ul><li>Primary会在所有关于本次Output 的所有信息都发送给 Backup 之后（并且要确保 Backup 收到）才会把 output 发送给外界</li><li>Primary 只是推迟将 output 发送给外界，而不会暂停执行后边的任务</li></ul><p>流程如图所示：</p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1ffru2zo16dj20if09ddgr.jpg" alt=""></p><p>但是这种方法不能保证 output 只发出一次，如果 primary 宕机了，backup 不能判断它是在发送了 output 之前还是之后宕机的，因此 backup 会再发送一次 output。但是这个问题很容易解决，因为：</p><ul><li>output 是通过网络进行发送的，例如 TCP 之类的网络协议能够检测重复的数据包</li><li>即使 output 被发送了2次其实也没关系。如果 output 是一个写操作，它会在同一个位置写入两次，结果不会发生变化；如果 output 是读取操作，读的内容会被放入 bounce buffer（为了消除 DMA 竞争），数据会在 IO 中断之后被送到</li></ul><h2 id="宕机检测"><a href="#宕机检测" class="headerlink" title="宕机检测"></a>宕机检测</h2><p>如何知道有机器宕机，在该系统中是十分重要的。该设计使用的是UDP heartbeat 机制来检测 Primary 与 Backup 之间的通信是否正常。</p><p>但是使用这种方法会存在裂脑问题（split-brain，Primary 和 Backup 同时宕机），该怎么解决呢？</p><p>该设计中使用了共享存储（Shared Storage），对它的操作是原子的，Primary 和 Backup不能同时进行一个操作（提供原子的 test-and-set 操作）</p><p>如果检测出 Primary 宕机，Backup 会成为 Primary，接替之前的工作，然后再寻找一个 Backup。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="启动-重启-Virtual-Machine"><a href="#启动-重启-Virtual-Machine" class="headerlink" title="启动/重启 Virtual Machine"></a>启动/重启 Virtual Machine</h2><p>如何启动一个和 Primary 状态一样的 Backup？</p><p>VMware Vmotion 操作能够将一台 VM 从一个 Server 完整的迁移到另一个 Server（只需要很短的中断），在该设计中的方法对 Vmotion 做了一点修改，不是进行迁移，而是直接克隆。</p><h2 id="管理-Logging-Channel"><a href="#管理-Logging-Channel" class="headerlink" title="管理 Logging Channel"></a>管理 Logging Channel</h2><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1ffruxtx8wzj20ez0chwfd.jpg" alt=""></p><p>如图，该设计使用了一个大的 buffer，来保存 logging entries，Primary 把自己的 entry 存到 buffer 中，由 logging channel 发送给Backup 的 buffer，然后 Backup 从 buffer 读取命令执行。</p><ul><li>如果 Backup 的 buffer 空了，没有命令执行了，Backup 会等待新的 entry</li><li>如果 Primary 的 buffer 满了，Primary 会等待，等 buffer 中有空余空间再继续执行</li></ul><h2 id="Disk-I-O问题"><a href="#Disk-I-O问题" class="headerlink" title="Disk I/O问题"></a>Disk I/O问题</h2><ol><li><p>disk 操作是并行的，同时对 disk 的同一位置进行操作会导致 non-deterministic</p><p>解决方案：检测 IO 竞争，使这些操作串行执行</p></li><li><p>Disk IO 使用 DMA（Direct Memory Access），同时访问内存同一位置的操作会导致 non-deterministic</p><p>解决方案：对 disk 操作的内存设置内存的页保护，但是这种方法代价太高；该设计中使用了 bounce buffer，它的大小和 disk 所操作的内存部分大小是一致的，read 操作直接将内容读入 buffer，当其他操作完成，写入内存，write 操作将写内容写入 buffer，之后再写入磁盘。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vmware 提出的这种 Primary/Backup 方法是分布式容错方法中非常重要的一部分，可以用在许多系统中，不仅仅是分布式存储（GFS 的容错方法），也可以用在分布式计算中，因为它是将所有的操作都记录下来，将它们重新在 Backup 上进行演绎，从而起到了备份的作用，能够做到容错（Fault-Tolerance）。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/05/20/ftvm-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>GFS 阅读笔记</title>
      <link>http://blog.luoyuanhang.com/2017/05/15/gfs-reading-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/05/15/gfs-reading-notes/</guid>
      <pubDate>Mon, 15 May 2017 13:09:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇博客是我阅读著名的 &lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/gfs.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GFS 论文（The Google File System）&lt;/a&gt;所总结的笔记以及自己一些的思考。这篇论文是一篇非常经典的论文，尤其对于想要了解分布式或者刚刚开始研究分布式的人来说，是一篇非常好的读物，它里面提到了许多分布式方向的基本问题，许多分布式的研究都是围绕这些基本问题的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这篇博客是我阅读著名的 <a href="http://nil.csail.mit.edu/6.824/2017/papers/gfs.pdf" target="_blank" rel="noopener">GFS 论文（The Google File System）</a>所总结的笔记以及自己一些的思考。这篇论文是一篇非常经典的论文，尤其对于想要了解分布式或者刚刚开始研究分布式的人来说，是一篇非常好的读物，它里面提到了许多分布式方向的基本问题，许多分布式的研究都是围绕这些基本问题的。</p><a id="more"></a><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>在了解谷歌文件系统（Google File System）之前，我们必须要了解一下有关分布式系统的一些概念。</p><p><strong>Q1：一致性是什么？</strong></p><p>在分布式文件系统中，很重要的一部分就是数据的复制（replica），为了保证分布式文件系统的高可用性，我们常常会把文件在不同的机器上存储多份，一致性的要求就是保证这些不同机器上的复制品（replicas）能够保持一致。</p><p><strong>Q2：如果只有一个应用程序，它对文件系统进行了一次写操作，这个应用程序在这次写操作之后的读操作会观测到什么呢？</strong></p><p>它会正常观测到它刚刚写入的数据。</p><p><strong>Q3：如果另外多个应用程序执行的读操作呢，它们会观测到什么呢？</strong></p><p>对于弱一致性的模型来说，这次读操作有可能会读取到已经过期的数据；</p><p>对于强一致性的模型来说，读操作读到的始终是上一次写入操作进行完成之后的数据。</p><p>强一致性能保证写入操作，但是它会影响性能（强一致性协议复杂）</p><p><strong>Q4：理想化的一致性模型是怎样的？</strong></p><p>分布式文件系统通过在多个机器上复制文件来保证可用性，在理想化的一致性模型中，在文件系统中所进行的各种操作都要像是在一台机器上进行的操作。实现理想化一致性模型的难点在于处理高并发问题、如何处理分布式集群中的机器崩溃以及达到网络的高效利用，理想化的一致性模型还会出现裂脑问题（split-brain，如果两个存储着相同文件的机器 A，B同时崩溃，其他的机器并不知道是哪一个先崩溃的，所以就不知道该用 A 恢复 B还是用 B 恢复 A）。总之，使用理想化一致性算法会影响性能，并且它的实现非常复杂（例如：Paxos）</p><p>GFS 不是采用的理想化一致性模型，但是它解决了机器崩溃恢复的问题以及能够应对高并发操作同时又能相对高效地利用网络。</p><h1 id="GFS-是什么？"><a href="#GFS-是什么？" class="headerlink" title="GFS 是什么？"></a>GFS 是什么？</h1><p>GFS（Google File System ）是一个大规模分布式文件系统，具有容错的特性（机器崩溃后的处理），并且具有较高性能，能够响应众多的客户端。</p><h2 id="GFS-设计背景"><a href="#GFS-设计背景" class="headerlink" title="GFS 设计背景"></a>GFS 设计背景</h2><ul><li>经常会有机器崩溃（因为机器众多，难免会有机器崩溃）</li><li>有些存储的文件比较大</li><li>append 操作更常见（在文件后追加，而不是 overwrite 覆盖）</li><li>主要包括两种读取 （read）操作：一种是大的顺序读取（单个文件读取几百 KB 甚至是几 MB）；另一种是小的随机读取（在随机位置读取几 KB）</li><li>需要支持并发（例如，多个客户端同时进行 append 操作）</li></ul><h2 id="GFS-所需提供操作"><a href="#GFS-所需提供操作" class="headerlink" title="GFS 所需提供操作"></a>GFS 所需提供操作</h2><p>create（文件创建）、delete（文件删除）、open（打开文件）、close（关闭文件）、read（读取文件）、write（写入文件）、record append（追加文件）、snapshot（快照）。</p><h1 id="GFS-架构"><a href="#GFS-架构" class="headerlink" title="GFS 架构"></a>GFS 架构</h1><p>GFS 的架构由一台 master 服务器和许多台文件服务器（chunkserver）构成，并且有若干客户端（client）与之交互。</p><h2 id="GFS-特点概述"><a href="#GFS-特点概述" class="headerlink" title="GFS 特点概述"></a>GFS 特点概述</h2><ul><li>文件分块（chunks），每块有一个64位标识符（chunk handle），它是在 chunk 被创建时由 master 分配的，每一个 chunk 会有3个备份，分别在不同的机器上。</li><li>Master 存储所有的 metadata，包括命名空间（namespace）、访问控制信息（access control）、文件与 chunk 的映射关系（mapping）以及 chunk 的存储位置</li><li>Master 管理 chunk 租约（lease）、chunk 迁移（如果 chunkserver 挂掉）、chunkserver 之间的通信（heartbeat，它也会向 chunkserver传达master 的命令，chunkserver 通过 heartbeat 向 master 报告自己的状态）</li><li>Client 会和 master 以及 chunkserver 进行交互，client向 master 请求 metadata，然后向 chunkserver 进行读写操作</li><li>client 与 chunkserver 都不会缓存文件数据，为的是防止数据出现不一致的状况。但是 client 会缓存 metadata 的信息（但是会出现一个问题，如果 metadata 过期怎么办呢？GFS 给出了自己的解决方案，也就是租约 lease）</li></ul><h2 id="单一-Master-架构"><a href="#单一-Master-架构" class="headerlink" title="单一 Master 架构"></a>单一 Master 架构</h2><p>GFS 为了简化设计，在整个系统中只有一个 master 进行管理。Master 不提供读写操作，它只会告诉 client，它所请求操作的文件在哪个 chunkserver 上，然后 client 会根据 master 提供的信息，与对应的 chunkserver 进行通信。</p><p>例如：以 client 要进行读取操作为例</p><ol><li>client 将应用程序请求的文件名、大小转化为 chunk index，然后将文件名和 index 发送给 master</li><li>master 返回文件的 chunk handle 和所有该文件备份的位置</li><li>client 将这两个 master 发送给它的信息缓存起来作为 value，文件名和 chunk index 作为 key</li><li>client 向三个备份之一的 chunkserver 发送读请求（选择最近的机器），请求中包含 chunk index 和它要读取的文件的 Byte 范围</li><li>如果 client 缓存的信息没有过期（如何知道是否过期会在后面的文章进行介绍），client 就不用在与 master 进行通信了，以后可以直接与 chunkserver 进行通信</li></ol><h2 id="chunk-大小"><a href="#chunk-大小" class="headerlink" title="chunk 大小"></a>chunk 大小</h2><p>GFS 中将 chunk 的大小定为 64MB，它比一般的文件系统的块大小要大。</p><p>这样做的优点有：</p><ul><li>减少 client 与 master 的交互</li><li>client 可以在一个块上执行更多的操作，通过 TCP 长连接减少网络压力</li><li>减小 metadata 的大小</li></ul><p>但是这样做也存在缺点：</p><ul><li>一个 chunk 可以存更多的小文件了，这样的话如果有一个块存储了许多小文件，client 和它进行操作的几率大大提高，这个 chunk 的压力会很大（然而在实际中，这个问题影响并不大）</li><li>在批处理系统中存在很大问题（如果在一个 chunk 上有一个可执行文件，同时有许多 client 都要请求执行这个文件，它的压力会很大。解决方案是把该文件在不同的 chunkserver 上多添加几个备份，更长久的方案是应该允许 client 去读取其他 client 的文件）</li></ul><h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>GFS 的 metadata 存储着 3 种类型的信息：</p><ul><li>文件名以及 chunk 的名称</li><li>文件与 chunk 的映射关系</li><li>各个备份（replicas）的位置</li></ul><p>Metadata 通常存储于内存中，前两种信息有时会存于磁盘中，它们有时会作为操作记录（operation log）备份的一部分存储于磁盘，备份于远程机器。</p><p>把 metadata 存储于内存有许多优点，查看 metadata 信息时很方便，速度快，有利于 chunk 的垃圾回收（garbage collection）、再备份（re-replication）以及 chunk 迁移（为的是负载均衡）。</p><p>但是如果如果Metadata都存放于内存的话会不会受限于内存的大小呢？</p><p>实际上不会的，因为每一条 metadata 的大小非常小，namespace 信息也很小，并且使用了前缀压缩（prefix compression）进行存储。并且升级内存的花费实际上也很小。</p><h2 id="chunk-位置"><a href="#chunk-位置" class="headerlink" title="chunk 位置"></a>chunk 位置</h2><p>chunk 的位置信息在 master 中不是一成不变的，master 会通过定期的 heartbeat 进行更新，这样做能够减小开销，这样做就不用 master 与 chunkserver 时刻保持同步通信（包括 chunkserver 的加入、退出、改名、宕机、重启等）。chunkserver 上有一个 final word，它表示了哪个 chunk 在它的磁盘上，哪个 chunk 不在。</p><h2 id="操作记录（operation-log）"><a href="#操作记录（operation-log）" class="headerlink" title="操作记录（operation log）"></a>操作记录（operation log）</h2><p>operation log 中包括了 metadata 变更的历史记录</p><ul><li>它是 metadata 的持久化记录，备份于磁盘上</li><li>它表示了并发操作的时间线</li><li>用于 Master 恢复</li></ul><h1 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h1><p>GFS 采用的一致性模型并不是强一致性模型，这是在考虑了各种问题后权衡的结果。</p><p><strong>GFS 是如何保证一致性的？</strong></p><p>有关文件命名空间的操作都是原子的（由 namespace lock 保证）</p><p>我们先来介绍一下 GFS 保证一致性的前提和一些概念：</p><ul><li>如果所有客户端不论从哪一个备份中读取同一个文件，得到的结果都是相同的，那么我们就说这个文件空间是一致的（consistent）</li><li><strong>defined：</strong>如果一个文件区域在经过一系列操作之后依旧是一致的，并且客户端完全知晓对它所做的所有操作，我们就称它为『defined』</li><li>一个操作如果没有被其他并发的写操作影响，那么这个被操作的文件区域是 defined 的</li><li>成功的并发操作也会导致文件区域 undefined，但是一定是一致的（consistent）（客户端有可能只看到了最终一致的结果，但是它并不知道过程）</li><li>失败的并发操作会导致文件区域 undefined，所以一定也是不一致的（inconsistent）</li><li>GFS 并不需要是因为什么导致的 undefined（不区分是哪种 undefined），它只需要知道这个区域是 undefined 还是 defined 就可以</li></ul><p>造成数据改变的操作可能是写入（write）或者追加（record append）：</p><ul><li>write：往应用程序指定的 offset 进行写入</li><li>record append：往并发操作进行过的 offset 处进行写入，这个 offset 是由 GFS 决定的（至于如何决定的后面会有介绍），这个 offset 会作为 defined 区域的起始位置发送给 client。</li><li>“regular” append：对应于 record append 的一个概念，普通的 append 操作通常 offset 指的是文件的末尾，但是在分布式的环境中，offset 就没有这么简单了</li></ul><p><strong>重要问题</strong></p><ol><li>GFS 通过在所有的备份（replicas）上应用顺序相同的操作来保证一个文件区域的 defined（具体细节后面会讨论）</li><li>GFS 会使用 chunk version（版本号）来检测 replicas 是否过期，过期的 replicas 既不会被读取也不会被写入</li><li>GFS 通过握手（handshakes）来检测已经宕机的 chunkserver</li><li>GFS 会通过校验和（checksuming）来检测文件的完整性</li></ol><h1 id="系统间的交互"><a href="#系统间的交互" class="headerlink" title="系统间的交互"></a>系统间的交互</h1><p>这一部分我们来谈谈系统中各个部分之间的交互（master 和 chunkserver、client 和 master、chunkserver 等），GFS 设计的目标是尽可能地让 master 更少的涉及到各种操作中。</p><h2 id="租约（lease）和修改的顺序（mutation-order）"><a href="#租约（lease）和修改的顺序（mutation-order）" class="headerlink" title="租约（lease）和修改的顺序（mutation order）"></a>租约（lease）和修改的顺序（mutation order）</h2><p> Mutation（修改）：mutation 指的是改变了 chunk 的内容或者 metadata，每一次 mutation 都应该作用于所有的备份</p><p>GFS 使用租约机制（lease）来保障 mutation 的一致性：多个备份中的一个持有 lease，这个备份被称为 primary replica（其余的备份为 secondary replicas），GFS 会把所有的 mutation 都序列化（串行化），让 primary 直行，secondary 也按相同顺序执行，primary 是由 master 选出来的。一个 lease 通常60秒会超时。</p><p>现在我们以写操作的数据流程来说明租约机制是如何进行的：</p><ol><li>client 向 master 请求持有 lease 的 chunk（primary replica）位置和其他 replicas 的位置（如果没有 chunk 持有 lease，那么 master 会授予其中一个 replica 一个 lease）</li><li>master 返回 primary 的信息和其他 replicas 的位置，然后 client 将这些信息缓存起来（只有当 primary 无法通信或者该 primary replica 没有 lease 了，client 才会向 master 再次请求）</li><li>client 会将数据发送到所有的 replicas，每个 chunkserver 会把数据存在 LRU 缓存中</li><li>在所有的 replicas 都收到了数据之后，client 会向 primary 发送写请求。primary 会给它所收到的所有 mutation 分配序列号（这些 mutation 有可能不是来自于同一个 client），它会在自己的机器上按序列号进行操作</li><li>primary 给 secondaries 发送写请求，secondaries 会按相同的序列执行操作</li><li>secondaries 告知 primary 操作执行完毕</li><li>primary 向 client 应答，期间的错误也会发送给 client，client 错误处理程序（error handler）会重试失败的 mutation</li></ol><p>其他问题：</p><ul><li>如果一次写操作要写的数据比较大，可能会跨越多个 chunk，GFS client 会把它分为几次小的操作，GFS 支持的最大的操作大小是 chunk 的1/4的大小</li><li><strong>但是如果像上述这么做会出现 undefined 但是 consistent 的区域，这是为什么呢？</strong>GFS 的 record append 操作仅能保证数据在一个原子单位中被写了一次，并不能保证对所有的 replicas 操作的位置都是相同的，比如每次写入的 offset 相同，但是 chunk 有可能不一样</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>GFS 对其数据流的设计目标如下：</p><ul><li>要充分利用网络带宽</li><li>避免网络瓶颈和高延迟</li><li>减少数据流动延迟</li></ul><p>设计方案如下：</p><ul><li>数据以链（chain）的形式 在 chunkserver 之间线性流动（每个机器都在用自己的全部带宽与另外一个机器通信，而不是同时让多个机器分享带宽）</li><li>每个机器会把数据发送到离自己最近的还没有收到数据的机器（GFS 中可以通过机器 IP 地址进行计算）</li><li>通过 TCP 连接将数据传输流水线化（pipelining），pipelining 之所以能够有效果是因为 GFS 的网络是全双工的交换网络</li></ul><h1 id="Snapshot-快照"><a href="#Snapshot-快照" class="headerlink" title="Snapshot 快照"></a>Snapshot 快照</h1><p>GFS 通过 snapshot 来立即创建一个文件或者目录树的备份，它可以用于备份文件或者创建 checkpoint（用于恢复），同时 GFS 把写时复制技术（copy-on-write）引入到了快照操作中，原理与 Linux 进程中的写时复制基本相同。</p><p>当 master 收到 snapshot 操作请求后：</p><ol><li>废除所有的 lease，准备 snapshot（相当于暂停了所有写操作）</li><li>master 记录所有操作，并且将记录写入磁盘</li><li>master 将源文件和目录树的 metadata 进行复制，这样之前的记录就和当前的内存中所保存的状态对应起来了，新建的 snapshot 和源文件指向的会是同一个 chunk</li></ol><h1 id="Master-职责"><a href="#Master-职责" class="headerlink" title="Master 职责"></a>Master 职责</h1><ul><li>执行所有有关于 namespace 的操作</li><li>管理整个系统的 chunk replicas：<ul><li>做出 chunk replicas 的放置决定</li><li>创建 chunk/replicas</li><li>协调各种操作，保证 chunk 被完全复制</li><li>负载均衡</li><li>回收闲置空间</li></ul></li></ul><h2 id="管理-namespace"><a href="#管理-namespace" class="headerlink" title="管理 namespace"></a>管理 namespace</h2><p>在进行快照操作时，lease 会被废除，无法进行写操作，但是 GFS 希望其他 Master 操作不受影响，GFS 采取的方法是使用<strong>namespace 锁</strong>。</p><p>GFS 的namespace 是一个查找表（lookup table），并且采用了前缀压缩的方式存储在内存中，它是一个树结构，namespace 树中的每一个节点（文件名或者目录名）都有一个读/写锁。</p><p>在 Master 对文件或者目录进行操作之前它首先需要获取一个锁，比如要对 /d1/d2/…/dn/leaf 进行操作，需要获得 /d1, /d1/d2, /d1/d2/…/dn的读锁，需要 /d1/d2/…/dn/leaf 的读锁或者写锁（根据不同的操作，锁也不同）</p><p><strong>例如，当/home/user 被快照备份至/save/user 时，如果此时要创建/home/user/foo 会发生什么呢？</strong></p><p>快照操作获得了/home, /save 的读锁和/home/user, /save/user 的写锁。创建/home/user/foo需要/home, /home/user的读锁和/home/user/foo 的写锁。因为两个操作在 /home/user的锁上产生了冲突，所以操作会依次执行，在完成 snapshot 操作之后，释放了/home/user 的写锁， /home/user/foo才会被创建。</p><h2 id="放置-replicas"><a href="#放置-replicas" class="headerlink" title="放置 replicas"></a>放置 replicas</h2><p>如何安置replicas 的目标是：</p><ul><li>最大化数据可靠性和可用性</li><li>最大化网络带宽的利用</li></ul><p><strong>这里的最大化不仅仅是机器间的问题，还要考虑机架间的问题</strong></p><p>在以下3种情况下，Master 会进行创建 replicas 的操作：</p><ul><li>创建了新的 chunk</li><li>需要重新备份</li><li>负载均衡</li></ul><p><strong>如何选择将 replicas放置到哪台机器上呢？</strong></p><ol><li>优先选择磁盘利用率低的 chunkserver</li><li>GFS 会限制每个 chunkserver『最近』创建的次数。换句话说，如果一个 chunkserver 近期创建 replicas 的操作比较频繁，就不会优先选择它（因为创建就意味着以后会进行读取，为了防止突然间大量的读取出现在同一台机器上）</li><li>保证可用性，尽可能跨机架进行创建操作</li></ol><p>当可用的备份低于要求时（GFS 要求为3份），master 会对 chunk 进行重新备份，在以下情况有可能需要重新备份：</p><ul><li>chunkserver 不可用了</li><li>备份损坏了</li><li>硬盘挂掉了</li><li>所要求的最低备份数量提高了</li></ul><p>当有多个 chunk 需要备份时，GFS 如何决定先备份哪个呢？策略如下：</p><ul><li>优先选择可用备份少的</li><li>优先备份最近没有 delete 文件的</li><li>优先备份阻塞了 client 操作的</li></ul><p>当 master 决定了备份哪个之后，会把当前可用的 chunk 直接克隆到目标位置（遵循replicas 放置规则）</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>文件 delete 之后，GFS 并不会立即对空间进行回收，而是等待垃圾回收机制会空间进行释放。</p><p>当文件被删除之后，Master 会想其他操作一样，把删除操作记录下来，但是不进行空间的回收，而是将这块空间命名为 hidden（并且包含被删除时的时间戳），Master 会定期进行扫描，把隐藏了一定时间的文件空间进行回收（这个时间是可以进行配置的），在此期间可以对这块空间的文件进行恢复（直接通过重命名回原来的名称就可以）。</p><p>除此之外，垃圾回收机制还会扫描孤儿 chunk（所有的文件都没有用到的非空 chunk），然后对这块 chunk 的 metadata 进行清除。具体的做法是，在 master 于 chunkserver 的 heartbeat 信息中会携带关于 chunk 的信息，master 会把 metadata 中不存在的 chunk 发送给 chunkserver，chunkserver 会把它拥有的 chunk 发送给 master。</p><h2 id="过期-replica-检测"><a href="#过期-replica-检测" class="headerlink" title="过期 replica 检测"></a>过期 replica 检测</h2><p>chunkserver 宕机或者是 mutation 的丢失会导致 replica 的过期，GFS 是如何对 replicas 进行检测，判断它们是否是最新的呢？</p><p>GFS 对于每一个 chunk 都会有一个版本号，这个版本号由 master 进行管理，通过版本号可以对过期的 replica 进行甄别。当 master 授予 lease 的时候，会增加版本号并且通知所有未过期的 replicas，master 和 replicas 都会记录下最新的版本号（这些操作需要在客户端进行写入操作之前完成）。如果这时，有一个 replica 不可用了，它的版本号就不会再增加了，在 chunkserver 重启或者重新向 master报告它的版本号时，master 就会知道这个 replica 已经过期了，并且会在垃圾回收时将它进行回收。如果 master 的版本号落后了呢，它会更新自己的版本号。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/05/15/gfs-reading-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MapReduce 阅读笔记</title>
      <link>http://blog.luoyuanhang.com/2017/04/19/mapreduce-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/04/19/mapreduce-notes/</guid>
      <pubDate>Wed, 19 Apr 2017 15:54:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇文章是我阅读 &lt;a href=&quot;https://research.google.com/archive/mapreduce-osdi04.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MapReduce 论文：《MapReduce: Simplified Data Processing on Large Clusters》&lt;/a&gt;的笔记，这篇笔记概述了 MapReduce 是什么，它的工作流程，一些细节问题，以及我的个人理解与思考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这篇文章是我阅读 <a href="https://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">MapReduce 论文：《MapReduce: Simplified Data Processing on Large Clusters》</a>的笔记，这篇笔记概述了 MapReduce 是什么，它的工作流程，一些细节问题，以及我的个人理解与思考。</p><a id="more"></a><h1 id="MapReduce-是什么？"><a href="#MapReduce-是什么？" class="headerlink" title="MapReduce 是什么？"></a>MapReduce 是什么？</h1><p>MapReduce 是 Google设计的一种用于大规模数据集的分布式模型，它具有支持并行计算、容错、易使用等特点。它的设计目标如下：</p><ul><li>支持并行</li><li>用于分布式</li><li>能够进行错误处理（比如机器崩溃）</li><li>易于使用（程序员友好）</li><li>负载均衡</li></ul><h1 id="模型流程"><a href="#模型流程" class="headerlink" title="模型流程"></a>模型流程</h1><p>MapReduce 模型主要分为 2 个部分：<strong>Map</strong> 和 <strong>Reduce</strong>。</p><p>在 Map 过程中，Map 函数会获取输入的数据，产生一个临时中间值，它是一个 K/V 对，然后MapReduce Library 会按 Key 值给键值对（K/V）分组然后传递给 Reduce 函数。而后，Reduce 接收到了这些 K/V 对，会将它们合并。</p><p>以论文中的字数统计程序为例：</p><p>现在我们来考虑，如果我们有许多文档，然后我们想要统计在这些文档中每个字出现的次数，现在用 MapReduce 来解决这个问题。Map 函数所做的工作，就是进行分词，产生一组形如下表的 K/V 键值对：</p><table><thead><tr><th>apple</th><th>1</th></tr></thead><tbody><tr><td>apple</td><td>1</td></tr><tr><td>by</td><td>1</td></tr><tr><td>by</td><td>1</td></tr><tr><td>by</td><td>1</td></tr><tr><td>google</td><td>1</td></tr><tr><td>google</td><td>1</td></tr><tr><td>take</td><td>1</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>然后将这组键值对传递给 Reduce，由 Reduce 进行合并。</p><p><strong>具体流程如下：</strong></p><ol><li>由用户程序中调用的 MapReduce Library 将文件分成 M 块（M 要远大于 Map Worker 的数量，每块大小16MB~64MB），此时，进入 MapReduce 过程；</li><li>由 Master 给空闲的 Worker 分配任务，共有 M 个 Map 任务，R 个 Reduce 任务；</li><li>Map Worker 读取文件，将文件处理为 K/V 键值对，K/V 键值对缓存于内存中（此时存在一个问题，如果断电怎么办？往下看后边有解释）；</li><li>将缓存于内存的 K/V 键值对写入磁盘，分成 R 堆（分堆方法有很多种，论文中提到了使用 Hash 散列函数），然后将结果发送给 Master；</li><li>Master 将这些 K/V 键值对的存储地址告知 Reduce，Reduce Worker 通过 RPC（远程过程调用）进行读取，读取完毕之后会根据 Key 值进行排序（这样，相同 Key 值的就会在一起。但是存在一个问题，如果内存不够大，排序该怎么进行？可以使用外部排序）；</li><li>Reduce Worker 将已经排序的结果进行遍历，将每个 Key 值所对应的一组 Value，所组成的  <code>&lt;key, value[num]&gt;</code>传递给用户所编写的 reduce 函数进行处理；</li><li>所有的 Map，Reduce 任务都完成后，告知用户程序，MapReduce 已经结束，返回用户程序。</li></ol><h1 id="容错处理（Fault-Tolerance）"><a href="#容错处理（Fault-Tolerance）" class="headerlink" title="容错处理（Fault-Tolerance）"></a>容错处理（Fault-Tolerance）</h1><p>MapReduce 中的容错处理是非常重要的，因为MapReduce 是运行于分布式环境中的，在分布式环境中经常会有机器出现错误，我们不能让个别机器的错误影响到整体。</p><h2 id="Worker-崩溃"><a href="#Worker-崩溃" class="headerlink" title="Worker 崩溃"></a>Worker 崩溃</h2><p>Master 通过定期给 Worker 发送心跳（heartbeat）来检测 Worker 是否还在正常工作，如果 Worker 无应答或者是应答有误，我们认定它已经宕机（fail）。如果正在工作的 Worker 宕机了，那么运行在它上面的 map 任务会进行初始化（初始状态为 idle，任务还有其他2种状态，in-progress处理中，completed 已完成），重新被分配到正常的 Worker 上。</p><p>如果说 Map Worker 已经完成了一些工作，我们仍然要对运行在它上面的所有任务重新进行分配，这是为什么呢？这里同时可以解决上面的那个问题。因为 Map Worker 处理后的中间结果存在于内存中，或者是 local disk 中，一旦它宕机，这些数据就获取不到了。</p><p>但是对于 Reduce Worker，它完成的任务不用重做，因为它处理后的结果是保存在全局存储中的。</p><p>如果，在 Map Worker A 宕机之后，它所做的任务被重新分配给了 Map Worker B，后边的 Reduce Worker 会被告知，A 已经宕机，要去 B 去读取数据。</p><h2 id="Master-崩溃"><a href="#Master-崩溃" class="headerlink" title="Master 崩溃"></a>Master 崩溃</h2><p>如果说 MapReduce 的 Master 宕机了，又该如何处理呢？</p><p>MapReduce 中的 Master 会定期进行 checkpoint 备份，如果 Master 宕机，会根据之前的 checkpoint 进行恢复，但是恢复期间，MapReduce 任务会中断。</p><h1 id="一些细节问题"><a href="#一些细节问题" class="headerlink" title="一些细节问题"></a>一些细节问题</h1><p><strong>1. 考虑用户编写的 reduce 函数是确定的（deterministic，对于同样的输入执行的结果是一样的），如果有多个 Reduce Worker 都执行了一个 Reduce 任务该怎么办？</strong></p><p>因为用户的 reduce 函数是 deterministic 的，所以即使有多个 Reduce Worker 都执行了同一个任务，但是它们执行的结果都是一样的，并不影响最后的结果。</p><p><strong>2. 如果用户编写的 reduce 函数是不确定（non-deterministic）的呢？</strong></p><p>正是因为 reduce 函数是 non-deterministic 的，本来每次执行的结果也不确定，所以更不会产生影响。</p><p><strong>3. 我们所需要处理的输入文件是如何保存的？</strong></p><p>Input 文件保存于 GFS 中，GFS 会将它们分块保存（每块16MB~64MB），GFS 会对每个文件有3个备份，备份在不同的机器上。</p><p><strong>4. Master 是如何分配任务的？</strong></p><p>遵循就『近』原则，将任务分配给离任务所保存的位置最『近』的 Worker，这里对『近』的定义是网络层面上的，比如说在同一个交换机下的两个机器就是距离『近』的。</p><p><strong>5. MapReduce 是如何做到负载均衡的？</strong></p><p>一开始将文件分块时，分为 M 块，远大于 Map Worker 的数量就有助于负载均衡。同时，这样做还有一个好处，就是当一个 Worker 宕机的时候，可以将任务迅速分配开来，分到多个 Worker 上去。如果 M 比较小，有可能当一个 Worker 宕机时，它的任务不够分配到剩下的 Worker 中，会有 Worker 闲置。</p><p><strong>6. 如何解决 straggler 问题（其他 Worker 都已经完成了自己的任务，但是有一个异常慢的机器，它还有任务没完成，拖慢了整体的速度）？</strong></p><p>MapReduce 有一种机制应对这种情况：MapReduce 会对未完成的任务（in-progress） 定时执行备份执行操作（即，把这些正在某些 Worker 上执行但未完成的任务再次分配给其他 Worker 去执行），不论这个任务被哪个 Worker 完成都会被标记为已完成。</p><p><strong>7. 如果在 Map 任务中有一个 key 特别多，可能会拖慢整个网络的速度，该怎么办？（例如，在字数统计的例子中，the 这个词的数量特别多）</strong></p><p>MapReduce 给用户提供了一个 Combiner 函数，这个函数可以将结果在发送到网络之前进行合并，例如发送键值对&lt;”by”, 3>。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/04/19/mapreduce-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 79. Word Search</title>
      <link>http://blog.luoyuanhang.com/2017/03/26/leetcode-079/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/26/leetcode-079/</guid>
      <pubDate>Sun, 26 Mar 2017 07:54:39 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;https://leetcode.com/problems/word-search/#/description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 79. Word Search.md&lt;/a&gt; 的分析与解法。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章是 <a href="https://leetcode.com/problems/word-search/#/description" target="_blank" rel="noopener">LeetCode 79. Word Search.md</a> 的分析与解法。</p></blockquote><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>For example,</p><p>Given <strong>board</strong> =</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>word = <code>ABCCED</code>, -&gt; returns <code>true</code>,</p><p>word = <code>SEE</code>, -&gt; returns <code>true</code>,</p><p>word = <code>ABCB</code>, -&gt; returns <code>false</code>.</p><p>这道题的意思就是在给定的字母板上寻找给定的单词，规则是从一个字母开始垂直或者水平方向上开始寻找，同一个位置的字母只能在路径上经过一次。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>这个问题首先能想到的方法就是暴力搜索，从字母板的(0, 0)位置开始搜索，到(n, n)位置结束。如果在搜索的过程中找到了给定的单词就直接返回。</p><p>以下图为例，假设我们要搜索的单词是『BED』，搜索顺序为『上下左右』：</p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fe095o469sj204q04qglg.jpg" alt=""></p><p>搜索过程如下：</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1fe0afna8e6j20ck0a2jrq.jpg" alt=""></p><ol><li>从(0, 0)位置的 A 开始搜索，A 与给定单词的[0]位置的字母不匹配，到(1, 0)位置；</li><li>(1, 0)位置的 B 与给定单词的[0]位置的字母相同，按照 B 的上下左右的方向依次搜索，已经经过的位置不再搜索；</li><li>搜索至(1,1)位置的 E，与给定单词的[1]的字母相同，按照 E 的上下左右的方向依次搜索，已经经过的位置不再搜索；</li><li>直到搜索到 D，完成 BED 的搜索，返回。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == <span class="number">0</span> || word.length() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || y &gt;= board[x].size() || x &gt;= board.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] != word[pos])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[x][y];</span><br><span class="line">        board[x][y] = <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> result = search(board, word, x<span class="number">-1</span>, y, pos+<span class="number">1</span>)</span><br><span class="line">        || search(board, word, x+<span class="number">1</span>, y, pos+<span class="number">1</span>)</span><br><span class="line">        || search(board, word, x, y+<span class="number">1</span>, pos+<span class="number">1</span>)</span><br><span class="line">        || search(board, word, x, y<span class="number">-1</span>, pos+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        board[x][y] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本文的完整代码详见<a href="https://github.com/luoyhang003/leetcode" target="_blank" rel="noopener">我的 GitHub</a></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/26/leetcode-079/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 131. Palindrome Partitioning</title>
      <link>http://blog.luoyuanhang.com/2017/03/24/leetcode-131/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/24/leetcode-131/</guid>
      <pubDate>Fri, 24 Mar 2017 08:08:47 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;https://leetcode.com/problems/palindrome-partitioning/#/description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 131. Palindrome Partitioning&lt;/a&gt; 的分析与解法。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章是 <a href="https://leetcode.com/problems/palindrome-partitioning/#/description" target="_blank" rel="noopener">LeetCode 131. Palindrome Partitioning</a> 的分析与解法。</p></blockquote><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>, Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这道题的意思就是将给定的字符串分成回文串的组合，就像例子中所说，<code>aab</code>有两种回文串组合：<code>aa</code>,<code>b</code>和<code>a</code>,<code>a</code>,<code>b</code>.</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>对于这个问题，我们很简单的将它分解为两个子问题：</p><ul><li>拆分字符串</li><li>判断一个字符串是否是回文串</li></ul><h2 id="Step-1-判断回文字符串"><a href="#Step-1-判断回文字符串" class="headerlink" title="Step 1 判断回文字符串"></a>Step 1 判断回文字符串</h2><p>如果一个字符串正读和反读结果都一样，我们就说它是一个回文字符串。判断一个字符串是不是回文的有很多种方法，我想起来 3 种方法，都会在接下来的文章中进行介绍，并给出源码（文中的代码皆为 C++）。</p><h3 id="反转字符串法"><a href="#反转字符串法" class="headerlink" title="反转字符串法"></a>反转字符串法</h3><p>这个方法是最容易理解的，将字符串反转，如果和原来的字符串一样，那么它就是回文的，这个方法在编码上也是最简单的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome_reverse</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> r = s;</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    <span class="keyword">if</span>(s.compare(r)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法是通过两个指针，一个指向字符串首，另一个指向字符串尾，如果两个指针指向的字符相同，则两个指针向中间移动，继续判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome_doublepoints</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归法和双指针法很类似，当前字符串是否回文取决于首尾字符是否相同，然后递归的判断除去首尾的剩余字符串是否回文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome_recursion</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome_recursion(s, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-2-拆分字符串"><a href="#Step-2-拆分字符串" class="headerlink" title="Step 2 拆分字符串"></a>Step 2 拆分字符串</h2><p>这一步是这个问题的关键，解决拆分字符串的方案也有 2 种：<strong>暴力回溯法</strong> 和 <strong>递归法</strong>。</p><h3 id="暴力回溯法"><a href="#暴力回溯法" class="headerlink" title="暴力回溯法"></a>暴力回溯法</h3><p>暴力回溯法比较好理解，它使用的是回溯法的思想，我们穷举出来字符串的所有子串组合，然后判断其中的子串是不是回文的，去掉不符合要求的组合，剩余的就是我们要的结果。</p><p>在进行穷举的时候，如果遇到不是回文的子串，我们就进行回溯。</p><p>以题目中的<code>aab</code>为例：</p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1fdxz57h7m7j20pk0c6my6.jpg" alt=""></p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;vec, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;temp, <span class="built_in">string</span> s, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        vec.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">                temp.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                backtrace(vec, temp, s, i+<span class="number">1</span>);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>递归法的思路是把一个字符串分为 A+B，如果 A 为回文则递归的求 B 的回文组合，然后将 A 和 B 的回文串组合做笛卡尔积。</p><p>以字符串 aabb 为例：</p><ol><li>将aabb 分为 a+abb，然后求 abb 的回文组合为[a, b, b], [a, bb]，所以做笛卡尔积后为：[a, a, b,b ], [a, a, bb]</li><li>将字符串分为 aa+bb，然后求 bb 的回文组合为[b, b], [bb],结果为[aa, b, b], [aa, bb]</li><li>将字符串分为 aab+b，aab 不回文</li><li>aabb 回文，结果为[aabb]</li><li>最终结果为：[a, a, b,b ], [a, a, bb], [aa, b, b], [aa, bb], [aabb]</li></ol><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition_recursion(<span class="built_in">string</span> s)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isPalindrome_recursion(s, <span class="number">0</span>, s.length()<span class="number">-1</span>))&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        temp.push_back(s);</span><br><span class="line">        vec.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> left = s.substr(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(left, <span class="number">0</span>, left.length()<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="built_in">string</span> right = s.substr(i, s.length()-i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; rightVec = partition_recursion(right);</span><br><span class="line">            <span class="keyword">if</span>(rightVec.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rightVec.size(); j++)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">                    temp.push_back(left);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; rightVec[j].size(); x++)&#123;</span><br><span class="line">                        temp.push_back(rightVec[j][x]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    vec.push_back(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h1><p>将几种方法组合后的测试结果如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">反转字符串法</th><th style="text-align:center">双指针法</th><th style="text-align:center">递归法</th></tr></thead><tbody><tr><td style="text-align:center">暴力回溯法</td><td style="text-align:center">16 ms</td><td style="text-align:center"><strong>13 ms</strong></td><td style="text-align:center"><strong>13 ms</strong></td></tr><tr><td style="text-align:center">递归法</td><td style="text-align:center">89 ms</td><td style="text-align:center">76 ms</td><td style="text-align:center">76 ms</td></tr></tbody></table><p>我们看到回溯法要明显优于递归的方法。</p><p>本文的完整代码详见<a href="https://github.com/luoyhang003/leetcode" target="_blank" rel="noopener">我的 GitHub</a></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/24/leetcode-131/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【从0到1学习Java线程池】一个Java线程池的简单实现</title>
      <link>http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/</guid>
      <pubDate>Wed, 15 Mar 2017 12:08:21 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这是【从0到1学习Java线程池】系列文章的第 叁 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章实现了一个简单的 Java 线程池。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这是【从0到1学习Java线程池】系列文章的第 叁 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章实现了一个简单的 Java 线程池。</p></blockquote><a id="more"></a><p>【从0到1学习Java线程池】系列文章共有3篇，目录如下：</p><ul><li><a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a></li><li><a href="http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/">【从0到1学习Java线程池】Java线程池原理</a></li><li><a href="http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/">【从0到1学习Java线程池】一个Java线程池的简单实现</a></li></ul><p>从上两篇文章中，我们已经知道了线程池的基本原理，这篇文章我们就来具体实现一个简单的 Java 线程池。</p><h1 id="设计先行"><a href="#设计先行" class="headerlink" title="设计先行"></a>设计先行</h1><p>想要实现一个线程池，我们首先要来进行设计，考虑它需要有哪些功能，如何设计和安排这些功能是至关重要的。</p><p>在我们所要实现的 Java 线程池需要有：</p><ul><li>任务队列：它能够添加或者删除任务，并且它还需要支持原子操作，不能同时有多个线程从中取出任务。</li><li>通知机制：如果任务队列为空，工作线程将会阻塞在获取任务这一操作上；如果这时任务队列中有了新的任务，需要通知工作线程从中获取任务来执行。</li><li>线程类：线程类的例程是用来获取任务和执行任务的。</li><li>任务类：用于被线程抓取和执行的任务。</li><li>线程管理类：能够创建一定数量的线程，并且提供对任务队列进行操作的方法（获取任务、添加任务等）。</li></ul><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="系统配置类"><a href="#系统配置类" class="headerlink" title="系统配置类"></a>系统配置类</h2><p>其中的参数主要是该线程池所支持的最大线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemConfig</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_POOL_MAX_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadDefalutSize</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> THREAD_POOL_MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程管理类"><a href="#线程管理类" class="headerlink" title="线程管理类"></a>线程管理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolManager</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isThreadPoolValid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sizeOfPoolThread = SystemConfig.getThreadDefalutSize();</span><br><span class="line"></span><br><span class="line">List&lt;Task&gt; taskList= <span class="keyword">new</span> LinkedList&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolManager</span><span class="params">(String threadpoolname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(threadpoolname);</span><br><span class="line">setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sizeOfPoolThread == <span class="number">0</span> || isThreadPoolValid != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception exception)&#123;</span><br><span class="line">exception.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeOfPoolThread; i++)&#123;</span><br><span class="line"><span class="keyword">new</span> WorkThread(i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isThreadPoolValid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stopThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sizeOfPoolThread == <span class="number">0</span> || isThreadPoolValid != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception exception)&#123;</span><br><span class="line">exception.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskList.clear();</span><br><span class="line">sizeOfPoolThread = <span class="number">0</span>;</span><br><span class="line">isThreadPoolValid = <span class="number">0</span>;</span><br><span class="line">interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Task newTask)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskList.add(newTask);</span><br><span class="line"></span><br><span class="line">notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Task <span class="title">getTask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(taskList == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(taskList.size() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> taskList.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(<span class="keyword">int</span> threadID)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(ThreadPoolManager.<span class="keyword">this</span>, <span class="string">""</span>+threadID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">Task runTask = getTask();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(runTask == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">runTask.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><strong>测试任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestTask</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.i = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Task "</span> + i + <span class="string">" is RUNNING."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadPoolManager manager = <span class="keyword">new</span> ThreadPoolManager(<span class="string">"SimplePool"</span>);</span><br><span class="line">manager.startThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">Task task = <span class="keyword">new</span> TestTask(i);</span><br><span class="line">manager.addTask(task);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task 3 is RUNNING.</span><br><span class="line">Task 4 is RUNNING.</span><br><span class="line">Task 1 is RUNNING.</span><br><span class="line">Task 0 is RUNNING.</span><br><span class="line">Task 2 is RUNNING.</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《创新的洞见》短评&amp;书摘</title>
      <link>http://blog.luoyuanhang.com/2017/03/13/insight-in-innovation/</link>
      <guid>http://blog.luoyuanhang.com/2017/03/13/insight-in-innovation/</guid>
      <pubDate>Mon, 13 Mar 2017 15:16:20 GMT</pubDate>
      <description>
      
        《创新的洞见》这本书是2016年年初出版的，其中写的好多是2015年互联网世界发生的事情，而我却是在2017年年初才看完的这本书，有些内容不免有些过时，因为在近几年中我国互联网世界的发展速度令人叹为观止，这个世界的变化天翻地覆。但是此书中的不少内容不失为经典，在书中的一些报告中，有许多创业者等等对当时未来的发展做出了预测，有些在两年后的今天看来十分准确，有些就显得有比较大的偏差了。但是，不论如何这些都是对创业者们十分有益、宝贵的阅读资料。当然了，由于书中选择了众多领域的不同人的文章或是报告，其中内容良莠不齐。
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h1><p>《创新的洞见》这本书是2016年年初出版的，其中写的好多是2015年互联网世界发生的事情，而我却是在2017年年初才看完的这本书，有些内容不免有些过时，因为在近几年中我国互联网世界的发展速度令人叹为观止，这个世界的变化天翻地覆。但是此书中的不少内容不失为经典，在书中的一些报告中，有许多创业者等等对当时未来的发展做出了预测，有些在两年后的今天看来十分准确，有些就显得有比较大的偏差了。但是，不论如何这些都是对创业者们十分有益、宝贵的阅读资料。当然了，由于书中选择了众多领域的不同人的文章或是报告，其中内容良莠不齐。</p><h1 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h1><ul><li>实际上以利润换市场无异于饮鸩止渴，最终会陷入不烧钱数据下降，烧钱又难以为继的两难，甚至不得不为了烧钱而损害未来的利益。</li></ul><ul><li>仓廪实而知礼节，衣食足而知荣辱，如果一个成年人日日为填饱肚子忙活，那就不要指望未来能有多大的空间。企业也是一样，当受制于资金支持随时可能断炊时，企业唯一能做的只有活下来，而不是过更好。</li><li>在特定时期VC可以让企业催熟、早产，甚至也不排除考虑杀鸡取卵。</li><li>BAT投资无外乎四种：<ol><li>现有业务互补；</li><li>新兴业务布局；</li><li>财务投资；</li><li>抹杀创新，消除竞争。</li></ol></li><li>最基本创业的初始点还是满足用户的需求，但是这样一个简简单单的一句话包含了三层意思，就是什么是用户的需求，谁是你的用户，以及怎么满足。除此之外，也是结合爱乐活的经验，有三点：<ul><li>第一点，团队极其重要。</li><li>第二点，时机。</li><li>第三点，产品是最重要的。</li></ul></li><li>我们犯的错误都是来自于对你内心里面相信的东西，是否有足够的坚定、坚持以及决心，还是说会过于犹豫，会迫于压力和利益，最后选择了妥协。</li><li>这个世界从不在乎你输入了什么，而在乎你输出了什么。</li><li>移动互联网和我们可以预见的可穿戴设备像一只吸血鬼，它让每个人都可以消费有价值的内容，而从不产生任何有价值的内容。</li><li>白花花的银子背后是钢铁般的团队，钢铁般的团队背后是老大金子般的人品。</li><li>黑塞说：“对于每个人而言，真正的职责只有一个：找到自我，然后在心中坚守其一生，全心全意，永不停息。所有其他的路都是不完整的，是人的逃避方式，是对大众期望的懦弱回归，是随波逐流，是对内心的恐惧。”你最怕的人，其实是你自己。</li><li>元数据是描述数据属性的集合，是对数据的说明,比如，数据的类型、名称、字段等。</li><li>数据与元数据可以这样来区别，前者是内容，后者是背景。背景常常比内容显示更多的信息，尤其是把元数据集合起来的时候。</li><li>互联网的流量变现的三个途径：<strong>广告、游戏和电子商务</strong>。</li><li>一对多是追求效率的提升，追求规模的最大化才能赚到钱。而一对一是追求个性化的匹配，因为打败极致效率的唯一方法就是个性化。</li><li>一鱼多吃，就是拿入口向产业链的上下游的延伸；一鱼三吃，就是锁定同样的人群，满足他们不同的跨行业的需求，表面跨行业，但是相对顺理成章。</li></ul><ul><li>理想的组织永远在跟着组织目标走，如果需要颗粒度更密集，那就把组织单位更加细小；如果发生阶段性变化，那适度弹性的组织更能胜任。其中，快速沟通和响应机制是必须的，尤其在瞬息万变的互联网行业。既然目标很难量化，那招合适的人适度放权就是一个必须的选择。</li><li>巨头试图通过扶植代理人的形式扩大制定游戏规则的边界，而那些倍受期许的独立势力正在左右逢源争取更高的收编价码。</li></ul><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/03/13/insight-in-innovation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【从0到1学习Java线程池】Java线程池原理</title>
      <link>http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/</guid>
      <pubDate>Mon, 27 Feb 2017 12:16:45 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这是【从0到1学习Java线程池】系列文章的第 贰 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章介绍了 Java 线程池的原理。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这是【从0到1学习Java线程池】系列文章的第 贰 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章介绍了 Java 线程池的原理。</p></blockquote><a id="more"></a><p>【从0到1学习Java线程池】系列文章共有3篇，目录如下：</p><ul><li><a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a></li><li><a href="http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/">【从0到1学习Java线程池】Java线程池原理</a></li><li><a href="http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/">【从0到1学习Java线程池】一个Java线程池的简单实现</a></li></ul><p>在上一篇文章中（<a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a>），我们总结了线程池的3个优点：</p><ul><li>线程复用</li><li>控制最大并发数</li><li>管理线程</li></ul><p>这篇文章会分别从这三个方面，结合具体的代码实现来剖析 Java 线程池的原理以及它的具体实现。</p><h1 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h1><p>我们知道线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用。这个功能就是线程复用。想要了解 Java 线程池是如何进行线程复用的，我们首先需要了解线程的生命周期。</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>下图描述了线程完整的生命周期：</p><p><img src="http://ww2.sinaimg.cn/mw690/4858d6a8jw1eu8b93kem2j20pb0dndl8.jpg" alt=""></p><p>在一个线程完整的生命周期中，它可能经历五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、终止（Zombie）。</p><p>在 Java中，Thread 通过new来新建一个线程，这个过程是是初始化一些线程信息，如线程名、id、线程所属group等，可以认为只是个普通的对象。调用Thread的<code>start()</code>后Java虚拟机会为其创建方法调用栈和程序计数器，同时将<code>hasBeenStarted</code>为true，之后如果再次调用<code>start()</code>方法就会有异常。</p><p>处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于 JVM 里线程调度器的调度。当线程获取CPU后，<code>run()</code>方法会被调用。不要自己去调用Thread的<code>run()</code>方法。之后根据CPU的调度，线程就会在<strong>就绪—运行—阻塞</strong>间切换，直到<code>run()</code>方法结束或其他方式停止线程，进入终止状态。</p><p>因此，如果要实现线程的复用，我们必须要保证线程池中的线程保持存活状态（就绪、运行、阻塞）。接下来，我们就来看看<code>ThreadPoolExecutor</code>是如何实现线程复用的。</p><h2 id="Worker-类"><a href="#Worker-类" class="headerlink" title="Worker 类"></a>Worker 类</h2><p><code>ThreadPoolExecutor</code>主要是通过一个类来控制线程复用的：Worker 类。</p><p>我们来看一下简化后的 Worker 类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">Runnable firstTask;</span><br><span class="line"></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line"><span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line"><span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">Runnable task = w.firstTask;</span><br><span class="line">w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">task.run();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以看到 Worker 实现了 Runnable 接口，并且它还有一个 Thread成员变量 thread，这个 thread 就是要开启运行的线程。我们看到 Worker 的构造方法中传递了一个 Runnable 参数，同时它把自己作为参数传入 <code>newThread()</code>，这样的话，当 Thread 的<code>start()</code>方法得到调用时，执行的其实是 Worker 的<code>run()</code>方法，即<code>runWorker()</code>方法。</p><p><code>runWorker()</code>方法之中有一个 while 循环，使用 <code>getTask()</code>来获取任务，并执行。接下来，我们将会看到<code>getTask()</code>是如何获取到 Runnable 对象的。</p><h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h2><p>我们来看一下简化后的<code>getTask()</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(一些特殊情况) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Runnable r = workQueue.take();</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到任务是从 workQueue中获取的，这个 workQueue 就是我们初始化 ThreadPoolExecutor 时存放任务的 BlockingQueue队列，这个队列里的存放的都是将要执行的 Runnable任务。因为 BlockingQueue 是个阻塞队列，<code>BlockingQueue.take()</code>返回的是空，则进入等待状态直到 BlockingQueue 有新的对象被加入时唤醒阻塞的线程。所以一般情况下，Thread的run()方法不会结束，而是不断执行workQueue里的Runnable任务，这就达到了线程复用的目的了。</p><h1 id="控制最大并发数"><a href="#控制最大并发数" class="headerlink" title="控制最大并发数"></a>控制最大并发数</h1><p>我们现在已经知道了 Java 线程池是如何做到线程复用的了，但是Runnable 是什么时候被放入 workQueue 队列中的呢，Worker里的Thread的又是什么时候调用<code>start()</code>开启新线程来执行Worker的run()方法的呢？从上面的分析中我们可以看出Worker里的<code>runWorker()</code>执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？它又是如何做到控制最大并发数的呢？</p><h2 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h2><p>通过查看 <code>execute()</code>就能解答上述的一些问题，同样是简化后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">// 当前线程数 &lt; corePoolSize</span></span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">// 直接启动新的线程。</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 活动线程数 &gt;= corePoolSize</span></span><br><span class="line">  <span class="comment">// runState为RUNNING &amp;&amp; 队列未满</span></span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="comment">// 再次检验是否为RUNNING状态</span></span><br><span class="line">    <span class="comment">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">      reject(command);</span><br><span class="line">    <span class="comment">// 采用线程池指定的策略拒绝任务</span></span><br><span class="line">    <span class="comment">// 两种情况：</span></span><br><span class="line">    <span class="comment">// 1.非RUNNING状态拒绝新的任务</span></span><br><span class="line">    <span class="comment">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker()"></a>addWorker()</h2><p>我们再来看一下<code>addWorker()</code>的简化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">  <span class="keyword">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">  <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">  t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，线程池工作过程中是如何添加任务的就很清晰了：</p><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException</li></ul><p>如果通过<code>addWorker()</code>成功创建新的线程，则通过<code>start()</code>开启新线程，同时将firstTask作为这个Worker里的<code>run()</code>中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以可以根据corePoolSize和maximumPoolSize来控制最大并发数。</p><p>过程如下图所示：</p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fd5ahj8k2sj20nu0dl0tu.jpg" alt=""></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>如果是做 Android 开发的，并且对 Handler 原理比较熟悉，你可能会觉得这个图挺熟悉，其中的一些过程和Handler，Looper，Meaasge使用中，很相似。<code>Handler.send(Message)</code>相当于<code>execute(Runnuble)</code>，Looper中维护的Meaasge队列相当于BlockingQueue，只不过需要自己通过同步来维护这个队列，Looper中的<code>loop()</code>函数循环从Meaasge队列取Meaasge和Worker中的<code>runWork()</code>不断从BlockingQueue取Runnable是同样的道理。</p><h1 id="管理线程"><a href="#管理线程" class="headerlink" title="管理线程"></a>管理线程</h1><p>上边的文章已经讲了，通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程，而线程的管理过程已经穿插在其中了，也很好理解。</p><p>在 ThreadPoolExecutor 有个AtomicInteger变量 ctl，这一个变量保存了两个内容：</p><ul><li>所有线程的数量</li><li>每个线程所处的状态</li></ul><p>其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到线程的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Worker的的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程是否在运行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &lt; SHUTDOWN; &#125;</span><br></pre></td></tr></table></figure><p>这里主要通过shutdown和shutdownNow()来分析线程池的关闭过程。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：</p><ul><li><strong>RUNNING状态：</strong>线程池正常运行，可以接受新的任务并处理队列中的任务；</li><li><strong>SHUTDOWN状态：</strong>不再接受新的任务，但是会执行队列中的任务；</li><li><strong>STOP状态：</strong>不再接受新任务，不处理队列中的任务</li></ul><p><code>shutdown()</code>这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务人会被执行；<code>shutdownNow()</code>方法将runState置为STOP。和<code>shutdown()</code>方法的区别是，这个方法会终止所有的线程，所以队列中的任务也不会被执行了。</p><p><strong>参考资料：</strong><a href="http://www.kuqin.com/shuoit/20160829/352799.html" target="_blank" rel="noopener">http://www.kuqin.com/shuoit/20160829/352799.html</a></p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【从0到1学习Java线程池】Java线程池的简介以及使用</title>
      <link>http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/</guid>
      <pubDate>Sun, 26 Feb 2017 13:39:50 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这是【从0到1学习Java线程池】系列文章的第 壹 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章主要介绍了 Java 线程池以及它的使用。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这是【从0到1学习Java线程池】系列文章的第 壹 篇，该系列文章总共三篇，介绍了 Java 线程池的使用以及原理，并且最后会实现一个基本的线程池。本篇文章主要介绍了 Java 线程池以及它的使用。</p></blockquote><a id="more"></a><p>【从0到1学习Java线程池】系列文章共有3篇，目录如下：</p><ul><li><a href="http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/">【从0到1学习Java线程池】Java线程池的简介以及使用</a></li><li><a href="http://blog.luoyuanhang.com/2017/02/27/thread-pool-in-java-2/">【从0到1学习Java线程池】Java线程池原理</a></li><li><a href="http://blog.luoyuanhang.com/2017/03/15/thread-pool-in-java-3/">【从0到1学习Java线程池】一个Java线程池的简单实现</a></li></ul><h1 id="线程池是什么？"><a href="#线程池是什么？" class="headerlink" title="线程池是什么？"></a>线程池是什么？</h1><p>线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><h2 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h2><p>在面向对象的编程过程中，创建对象和销毁对象是非常消耗时间和资源的。因此想要最小化这种消耗的一种思想就是『池化资源』。线程池就是这样的一种思想。我们通过重用线程池中的资源来减少创建和销毁线程所需要耗费的时间和资源。</p><p>线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用；另一个作用是可根据系统情况调整执行的线程数量，防止消耗过多内存。另外，通过线程池，能有效的控制线程的最大并发数，提高系统资源利用率，同时避免过多的资源竞争，避免堵塞。</p><p><strong>线程池的优点总结如下几个方面：</strong></p><ul><li>线程复用</li><li>控制最大并发数</li><li>管理线程</li></ul><h2 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h2><p>一般的线程池主要分为以下4个组成部分：</p><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><h2 id="线程池的常见应用场景"><a href="#线程池的常见应用场景" class="headerlink" title="线程池的常见应用场景"></a>线程池的常见应用场景</h2><p>许多服务器应用常常需要处理大量而短小的请求（例如，Web 服务器，数据库服务器等等），通常它们收到的请求数量很大，一个简单的模型是，当服务器收到来自远程的请求时，为每一个请求开启一个线程，在请求完毕之后再对线程进行销毁。这样处理带来的问题是，创建和销毁线程所消耗的时间往往比任务本身所需消耗的资源要大得多。那么应该怎么办呢？</p><p>线程池为线程生命周期开销问题和资源不足问题提供了解决方案。我们可以通过线程池做到线程复用，不需要频繁的创建和销毁线程，让线程池中的线程一直存在于线程池中，然后线程从任务队列中取得任务来执行。而且这样做的另一个好处有，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。</p><h1 id="Java线程池的简介"><a href="#Java线程池的简介" class="headerlink" title="Java线程池的简介"></a>Java线程池的简介</h1><p>Java中提供了实现线程池的框架Executor，并且提供了许多种类的线程池，接下来的文章中将会做详细介绍。</p><h2 id="Java线程池框架"><a href="#Java线程池框架" class="headerlink" title="Java线程池框架"></a>Java线程池框架</h2><p>Java中的线程池是通过Executor框架实现的，该框架中用到了<code>Executor</code>，<code>Executors</code>，<code>ExecutorService</code>，<code>ThreadPoolExecutor</code> ，<code>Callable</code>和<code>Future</code>、<code>FutureTask</code>这几个类。</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1fd45pk52lqj20ru0hvjtt.jpg" alt=""></p><ul><li>Executor：所有线程池的接口，只有一个方法</li><li>Executors：Executor 的工厂类，提供了创建各种不同线程池的方法，返回的线程池都实现了ExecutorService 接口</li><li>ThreadPoolExecutor：线程池的具体实现类，一般所有的线程池都是基于这个类实现的</li></ul><p>其中<code>ThreadPoolExecutor</code>的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>corePoolSize：线程池的核心线程数，线程池中运行的线程数也永远不会超过 corePoolSize 个，默认情况下会永远存活</li><li>maximumPoolSize：线程池中允许的最大线程数</li><li>keepAliveTime：空闲线程结束的超时时间</li><li>unit：是一个枚举，它表示的是 keepAliveTime 的单位</li><li>workQueue：工作队列，用于任务的存放</li></ul><h2 id="Java线程池的工作过程"><a href="#Java线程池的工作过程" class="headerlink" title="Java线程池的工作过程"></a>Java线程池的工作过程</h2><p>Java线程池的工作过程如下：</p><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ol><h2 id="常见的Java线程池"><a href="#常见的Java线程池" class="headerlink" title="常见的Java线程池"></a>常见的Java线程池</h2><p>生成线程池使用的是Executors的工厂方法，以下是常见的 Java 线程池：</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor是单个线程的线程池，即线程池中每次只有一个线程在运行，单线程串行执行任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,</span><br><span class="line">  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool是固定数量的线程池，只有核心线程，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列，直到前面的任务完成才继续执行。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是可缓存线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。其中，SynchronousQueue是一个是缓冲区为1的阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,</span><br><span class="line">  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>ScheduledThreadPool是核心线程池固定，大小无限制的线程池，支持定时和周期性的执行线程。创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在<code>DEFAULT_KEEPALIVEMILLIS</code>时间内回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPool(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">   DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">   <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-线程池的创建和使用"><a href="#Java-线程池的创建和使用" class="headerlink" title="Java 线程池的创建和使用"></a>Java 线程池的创建和使用</h1><p>我们可以通过Executors的工厂方法来创建一个线程池。但是我们该如何让线程池执行任务呢？</p><p>线程池最常用的提交任务的方法有两种：</p><ul><li><p>execute：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService.execute(Runnable runable)；</span><br></pre></td></tr></table></figure></li><li><p>submit：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask task = ExecutorService.submit(Runnable runnable);</span><br><span class="line">FutureTask&lt;T&gt; task = ExecutorService.submit(Runnable runnable,T Result);</span><br><span class="line">FutureTask&lt;T&gt; task = ExecutorService.submit(Callable&lt;T&gt; callable);</span><br></pre></td></tr></table></figure></li></ul><p>可以看出<code>submit</code>开启的是有返回结果的任务，会返回一个<code>FutureTask</code>对象，这样就能通过<code>get()</code>方法得到结果。<code>submit</code>最终调用的也是<code>execute(Runnable runable)</code>，<code>submit</code>只是将<code>Callable</code>对象或<code>Runnable</code>封装成一个<code>FutureTask</code>对象，因为<code>FutureTask</code>是个<code>Runnable</code>，所以可以在<code>execute</code>中执行。</p><p>下面的示例代码演示了如何创建一个线程池，并且使用它管理线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" is running."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleThreadExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//创建实现了Runnable接口对象</span></span><br><span class="line">        Thread tt1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread tt5 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//将线程放入池中并执行</span></span><br><span class="line">        pool.execute(tt1);</span><br><span class="line">        pool.execute(tt2);</span><br><span class="line">        pool.execute(tt3);</span><br><span class="line">        pool.execute(tt4);</span><br><span class="line">        pool.execute(tt5);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 is running.</span><br><span class="line">pool-1-thread-2 is running.</span><br><span class="line">pool-1-thread-1 is running.</span><br><span class="line">pool-1-thread-2 is running.</span><br><span class="line">pool-1-thread-1 is running.</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文的版权归作者 <a href="http://www.luoyuanhang.com" target="_blank" rel="noopener">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>山东大学人工智能课程复习提要（2017）</title>
      <link>http://blog.luoyuanhang.com/2017/02/03/AI-sdu-2016-summary/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/03/AI-sdu-2016-summary/</guid>
      <pubDate>Fri, 03 Feb 2017 06:40:14 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;本篇博客为山东大学人工智能课程（2016-2017）的复习提要，希望对大家的考试复习有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本篇博客为山东大学人工智能课程（2016-2017）的复习提要，希望对大家的考试复习有所帮助。</p></blockquote><a id="more"></a><h2 id="填空部分"><a href="#填空部分" class="headerlink" title="填空部分"></a>填空部分</h2><ol><li>构成产生式系统的基本元素有<u>综合数据库</u>、<u>规则库</u>、<u>控制系统</u>，控制策略按执行规则的方式分类，分为<u>正向</u>、<u>逆向</u>、<u>双向</u>三类。</li><li>归结过程中控制策略的作用是给出控制策略，以使仅对选择合适的子句间方可做归结，避免<u>多余的、不必要的归结式出现</u>。常见的控制策略有<u>线性归结策略</u>、<u>支持集策略</u>、<u>单元归结策略</u>、<u>输入归结</u>策略。</li><li>公式 G 和公式的子句集并不等值，但他们在<u>不可满足</u>的意义下是一致的。</li><li>与或图的启发式搜索算法 <u>AO*算法</u>的两个过程分别是<u>分解（将复杂的大问题分解为一组简单的小问题）</u>和<u>变换（将较难问题变换为较容易的等价的或等效的问题）</u></li><li>人工智能的研究途径主要有两种不同的观点，一种观点称为<u>符号主义</u>，认为人类智能基本单元是<u>符号</u>。另一种观点称为<u>连接主义</u>，认为职能的基本单元是<u>神经元</u>。</li><li>集合{P(a, x, f(g(y)), P(z, f(z), f(u)))} 的 mgu（最一般合一置换）为 <u>{z/a, f(x)/x, u/g(y)}</u>。</li><li>语义网络是对知识的<u>有向图</u>表示方法，一个最简单的语义网络是一个形如<u>节点</u>、<u>弧</u>、<u>节点</u>的三元组，语义网络可以描述事物间多种复杂的语义关系，常用 ISA、AKO 弧表示节点间具有<u>类属</u>的分类关系。语义网络下的推理是通过<u>匹配、继承</u>实现的。</li><li>当前人工智能研究的热点之一就是机器学习。常见的机器学习方法课分为<u>决策树学习</u>、<u>神经网络</u>、<u>蚁群算法</u>、<u>粒子群算法</u>和<u>遗传算法</u>等。一个机器学习系统应该有<u>环境</u>、<u>知识库</u>、<u>学习环节</u>和<u>执行环节</u>四个基本部分组成。</li><li>常用的知识表示法有<u>逻辑表示法</u>、<u>语义网络</u>、<u>框架理论</u>、<u>过程表示</u>、<u>脚本表示</u>等。</li><li>有两个算法 A*算法 A1 和 A2，若 A1比 A2有较多的启发信息，则 h1(n) <u>大于</u> h2(n)</li><li>关于 A 算法与 A*算法，若规定 h(n)&gt;=0,并且定义启发函数：f*(n) = g*(n)+h*(n) 表示初始状态 S0 经点 n 到目标状态 Sg最优路径的费用。其中 g*(n) 为 S0 到 n 的最小费用，h*(n) 为到 Sg 的实际最小费用。若另 <u>h(n)==0</u> ，则 A算法相当于<u>宽度优先搜索</u>。若另 <u>g(n)==h(n)==0</u> ，则相当于<u>随机算法</u>。若另 <u>g(n)==0</u> ，则相当于<u>最佳优先算法</u>。特别是当要求 <u>h(n)&lt;=h*(n)</u>，就称这种 A 算法为 A* 算法。</li><li>群智能是指无智能或简单智能的主题通过任何形式的聚集协同二表现出智能行为的特点。群智能潜在的两大特点是<u>并行性</u>和<u>分布式</u>。其典型算法有<u>蚁群算法</u>和<u>粒子群算法</u>。已知的群智能理论的研究和应用证明群智能算法是一种能够有效解决大<u>多数优化问题</u>的新方法。</li><li>蚁群算法是模拟自然界中蚂蚁寻找从巢穴到食物的最佳路径的行为而设计的，蚂蚁在遇到食物返回的路上会分泌<u>信息素</u>，信息素会随着时间慢慢挥发，且关键路径上的信息素相对浓度<u>高</u>，蚁群算法已被广泛应用于许多优化问题中，其中有<u>聚类问题</u>、<u>路由算法设计</u>、<u>图着色</u>、<u>车辆调度</u>、<u>机器人路径规划</u>。</li><li>粒子群优化算法是模拟<u>鸟群</u>或<u>蜂群</u>或<u>个体之间的协作和信息共享</u>的觅食行为而设计的，其基本思想是通过群体中<u>广泛应用于各类优化问题上</u>和在<u>军事领域中的应用</u>来寻找最优解。粒子群优化算法的应用领域有<u>对巡航导弹的飞行高度进行优化</u>、<u>车辆路径问题的应用</u>、<u>邮政投递</u>、<u>火车及汽车的调度</u>、<u>港口装卸集装箱</u>。</li><li>遗传算法是以达尔文的自然选择学说为基础发展起来的。遗传算法的三种基本操作是<u>复制、交叉、变异</u>；在遗传算法中，衡量个体优劣的尺度是<u>适应度</u>，它决定某些个体是繁殖或是消亡，同时也是驱动遗传算法的动力。</li><li>蚁群算法是模拟自然界中蚂蚁寻找从巢穴到食物的最佳路径的行为而设计的，依据蚁群算法的基本原理，蚁群算法中的行为因子有<u>觅食规则</u>、<u>移动规则</u>、<u>避障规则</u>、<u>信息素规则</u>、<u>范围</u>、<u>环境</u>等。</li><li>近年有学者提出的人工鱼群算法（Artificial Fish Swarm Algorith - AFSA）是模仿自然界中鱼群的行为而提出来的解决问题的算法，从模拟鱼群的<u>聚集行为</u>、<u>觅食行为</u>、<u>跟随行为</u>和<u>移动行为</u>等方面来模拟自然界中的鱼群行为。</li><li>遗传算法将『优胜劣汰，适者生存』的<u>生物进化原理</u>引入优化参数形成的编码串群体中，按所选择的<u>适应度函数</u>并通过遗传中的<u>复制</u>、<u>交叉</u>以及<u>变异</u>对个体进行<u>筛选</u>，<u>适应度高</u>的个体被保留下来，组成新的群体，新的群体既继承了上一代的信息，又优于上一代。</li><li>决策树是一种知识概念表示方法，能表示与或规则；是一种<u>图形表示的监督学习方法</u>。而人工神经网络（ANNs）是<u>非图形符号表示法</u>，又是一种函数表示法；即从大量的数据中<u>学习值为实数、离散值或向量的函数</u>。人工神经网络对于训练数据中『错误』数据的<u>错误健壮性很好</u>。人工神经网络的训练学习过程中有一个称为『学习速率 n』的常数，n取值过大会<u>引起漂移</u>，n 取值过小会<u>收敛速度太慢，学习效率不高</u>。大量的数据中抽取规则函数，错误健壮性很好。</li><li>多层神经网络的学习过程中有一种是反向传播算法（Back Propagation-BP）， 其基本思想是利用<u>输出单元的误差再计算上一层单元的误差，以次向上传播</u>以次向上传播，俗称反向传播。又称<u>逆推学习算法</u>。</li><li>归纳学习需要的预先假定，称为归纳偏置，归纳学习算法隐含了归纳偏置， 候选消除算法的归纳偏置是<u>目标概念可以在假设空间中找到</u>，所以又称<u>限定偏置</u>。ID3是一种典型的决策树学习方法，ID3的归纳偏置有两点，分别是<u>搜索完整的假设空间</u>，<u>优先选择较小的树</u>。Find-S 算法<u>寻找极大特殊假设</u>使用一般到特殊序，在偏序结构的一个分支上 执行<u>一般到特殊搜索</u>搜索，寻找一个与样例一致的<u>最特殊</u>假设。</li><li>自然语言处理是研究用机器处理人类语言的理论和技术,又叫<u>自然语言理解</u>, 它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法, 自然语言处理研究面临的两大困难是<u>歧义病构</u>和<u>音歧义</u>,其中歧义分为<u>分词歧义</u>、<u>短语歧义</u>、<u>词义歧义</u>、 <u>语用歧义</u>四个方面。</li><li>在证据理论(Evident Theory)中引入了信任函数(BeL)，它满足了<u>概率论弱公理</u>。在概率论中，当先验概率很难获得，但又要被迫给出时，用证据理论能区分<u>不确定性</u>和<u>不知道</u>的差别。因而它比概率论更 适合于<u>专家系统推理方法</u>。概率论是证据理论的一个特例，有时也称<u>证据理论</u>为广义概率论。</li><li>贝叶斯网是一个在弧的连接关系上加入<u>连接强度</u> 的因果关系网络。由两个部分组成，其一是 DAG，即 <u>有向无环图</u>  ;其二是 CPT， 即 <u>概率分配表</u> 。贝叶斯网络通常使用三种推理是 <u>因果推理</u> 、 <u>诊断推理</u> 、  <u>辩解推理</u>  。</li><li>在确定性推理模型中的可信度因子 CF(H,E) <u>证据 e 得到的假设 h 的确定性因子</u>  的取值范围为<u>[-1,+1]</u>  ;主观 Bayes 方法中规定规 则的静态强度 LS,LN 的值应 <u>[0,∞)</u>。</li></ol><h2 id="简答部分"><a href="#简答部分" class="headerlink" title="简答部分"></a>简答部分</h2><ol><li><p>人工智能方法与传统程序的不同有哪些？</p><p>答：<strong>传统方法解决问题利用已有知识 , 问题可以方便的结构化数据结构 , 数学形式表达， 数学公式、算法。利用知识特别是依赖人类经验的启发知识是人工智能方法与传统数学方法的根本不同之处，基于此，人工智能可以解决众多的难以数学表达的非结构化 的实际问题 , 人工智能首先研究的是以符号表示的知识 , 而不是数值为研究对象 , 其次采用的是启发式推理的方法而不是常规的算法 , 控制结构和领域知识是分离的，同时还允许出现相对正确的答案。</strong></p></li><li><p>在与或图的问题求解过程中，哪几类节点称为能解节点?</p><p>答：<strong>终节点是能解节点；若非终节点有”或”子节点时，当且仅当其子节点至少有一能解时，该非终节点才能解；若非终节点有”与”子节点时，当且仅当其子节点均能解时，该非终节点才能解。</strong></p></li><li><p>宽度优先搜索和深度优先搜索有何不同?在何种情况下宽度优先搜索优于深度优先搜索?在何种情况下深度优先搜索优于宽度优先搜索?两种搜索策略是否都是完备的?</p><p>答：<strong>宽度优先搜索就是逐层穷举搜索。深度优先搜索就是分支优先搜索待搜索问题的解存在且关键路径较短时宽 度优先搜索优于深度优先搜索;待搜索问题的解存在且关键路径较长，而深度优先搜索过程中优先发展的正好是解所在的路径时深度优先搜索优于宽度优先搜索。宽度优先搜索是完备的 。</strong></p></li><li><p>举例解释语义网络(Semantic Network)与知识图谱(Knowledge graph)的区别与联系。</p><p>答：<strong>知识图谱是通过将数学、图形学、可视化技术、信息科学等的理论与方法与计量学的引文分析、共现分析等方法结合，并利用可视化的图谱形象地展示知识体系的方法。 它把复杂的知识领域通过数据挖掘、信息处理、知识计量和图形绘制而显示出来，揭示知识领域的动态发展规律， 为学科研究供切实的、有价值的参考。 据不完全统计，Google 知识图谱到目前为止包含了 5 亿个实体和 35 亿条事实(形如实体-关系-实体， 和实体-属性值)。</strong></p><p><strong>语义网络 特点 (1) 结构性好: 语义网络是一种结构化的知识表示方法，它能够把事物的属性和事物间的各种语义关系显示地表示出来; (2)联想性: 语义网络作为人类联想记忆模型提出来，强调的就是事物之间的语义关系。 (3)自然性: 语义网络实际上是一个带有标示的有向图，可直观的把事物的属性及事物间的语义联系表示出来，便于理解。 利用语义网络表示知识的问题有:自然语言理解，问答系统， 专家系统等。 缺点:推理规则不十分明显，表达范围有限，一旦结点个数太多，网络结构复杂。</strong></p></li><li><p>举例说明大型应用软件系统开发过程中采用的软件技术(体系)架构是如何体现框架理论知识表示思想的。</p><p>答：<strong>软件开发过程中框架理论的使用软件框架(架构)特点: 为某一特定目的实现一个基本的、可执行的 构架 ；包含了应用程序从启动到运行的主要流程；流程中那些无法确定的步骤留给用户来实现；程序运行时框架系统自动调用用户实现的功能组件；系统的行为是主动的。</strong></p><p><strong>软件开发过程中框架理论的使用：人们将相同类型问题的解决途径进行抽象， 抽取成一个应用框架 Framework；提供了一套明确机制；让开发人员很容易的扩展和控制整个 Framework 开发上的结构。</strong></p><p><strong>软件开发过程中框架理论的使用：</strong></p><p><strong>系统级框架： MFC 框架、 .NET 中的应用框架、 JavaAWT</strong></p><p><strong>中间件框架： Spring 框架、 Struts 框架、 Hibernate 框架、 EXTjs 框架</strong></p><p><strong>企业应用框架为不同行业的应用开发专用的企业级框架系统 ：JBOSS, eBOSS, websphere等</strong></p><p><strong>软件开发过程中框架理论的使用：</strong></p><p><strong>Struts 框架: Struts 对 Model，View 和 Controller 都提供了对应的组件;</strong></p><p><strong>Mode 槽:ActionForm 和 JavaBean 组成;</strong></p><p><strong>View 槽: JSP(或 HTML、PHP……)实现;</strong></p><p><strong>Controller 槽:核心控制器，业务逻辑控制器。</strong></p></li><li><p>简要说明粒子群优化算法与遗传算法的共性和差异。</p><p><strong>共性：( 1 )都属于仿生算法;( 2 )都属于全局优化方法;( 3 )都属于随机搜索算法;( 4 )都隐含并行性;( 5 )根据个体的适配信息进行搜索，因此不受函数约束条件的限制， 如连续性、可导性等;( 6 )对高维复杂问题，往往会遇到早熟收敛和收敛性能差的缺点，都无法保证收敛到最优点。</strong></p><p><strong>差异：(1) PSO 有记忆，所有粒子都保存较优解的知识，而 GA ，以前的知识随着种群的改变被改变; (2) PSO 中的粒子是一种单向共享信息机制。而 GA 中的染色体之间相互共享信息，使得整个种群都向最优区域移动; (3) GA 需要编码和遗传操作，而 PSO 没有交叉和变异操作，粒子只是通过内部速度进行更新，因此原理更简单、参数更少、实现更容易。</strong></p></li><li><p>影响算法 A 启发能力的重要因素有哪些。</p><p><strong>( 1 )路径的耗散值; ( 2 )求解路径时所扩展的节点数; ( 3 )计算 h 所需的工作量。</strong></p><p><strong>因此选择 h 函数时，应综合考虑这些因素以便使启发能力最大</strong></p></li><li><p>决策树学习法与神经网络学习法的区别。</p><p><strong>决策树是知识一种图形符号表示，能表示与或规则;形象直观地图形符号</strong></p><p><strong>神经网络学习是非图形符号表示法，是一种函数表示法;从大量的数据中抽取规则函数</strong></p></li><li><p>为什么说遗传算法是一种“智能式搜索”，又是一种“渐进式优化搜索”。</p><p><strong>遗传算法的搜索策略，既不是盲目式的乱搜索，也不是穷举式的全面搜索， 它是有指导的搜索。指导遗传算法执行搜索的依据是适应度，也就是它的目标函数。利用适应度，使遗传算法逐步逼近目标值。</strong></p><p><strong>渐进式优化 : 遗传算法利用复制、交换、突变等操作，使新一代的结果优越于旧一代，通过不断迭代，逐渐得出最优的结果，它是一种反复迭代的过程</strong></p></li><li><p>简述α-β过程的剪枝规则。</p><p><strong>后辈节点的值≤祖先节点的值时，α剪枝</strong></p><p><strong>后辈节点的值≥祖先节点的值时，β剪枝</strong></p></li><li><p>简述关于群智能理论(算法)研究存在那些问题。</p><p><strong>数学理论基础相对薄弱，涉及的各种参数设置没有确切的理论依据带有随机性，每次的求解不一定一样，当处理突发事件时，系统的反映可能是不可预测的，这在一定程度上增加了其应用风险。</strong></p></li></ol><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/03/AI-sdu-2016-summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Raspberry3 上搭建 Go 环境</title>
      <link>http://blog.luoyuanhang.com/2017/02/02/run-go-on-raspberry-3/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/02/run-go-on-raspberry-3/</guid>
      <pubDate>Thu, 02 Feb 2017 14:29:53 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这篇博客讲的是如何在 Raspberry3（树莓派3）上搭建 Go 语言环境，所使用的 Go 语言的版本是1.7.4&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>这篇博客讲的是如何在 Raspberry3（树莓派3）上搭建 Go 语言环境，所使用的 Go 语言的版本是1.7.4</p></blockquote><a id="more"></a><h2 id="搭建Go环境"><a href="#搭建Go环境" class="headerlink" title="搭建Go环境"></a>搭建Go环境</h2><ul><li><p>ssh 登录树莓派</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@YOUR_RASPBERRY_IP</span><br></pre></td></tr></table></figure></li><li><p>下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.7.4.linux-armv6l.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local/ -xzf go/go1.7.4.linux-armv6l.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/profile</span><br></pre></td></tr></table></figure><p>在文件中加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>在控制台输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.7.4 linux/arm</span><br></pre></td></tr></table></figure><p>即为安装成功。</p><hr><blockquote><p>本文的版权归作者 <a href="http://blog.luoyuanhang.com">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/02/run-go-on-raspberry-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Raft 一致性算法论文译文</title>
      <link>http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/</guid>
      <pubDate>Thu, 02 Feb 2017 13:50:40 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为&lt;a href=&quot;https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《In search of an Understandable Consensus Algorithm (Extended Version)》&lt;/a&gt;(寻找一种易于理解的一致性算法)&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为<a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">《In search of an Understandable Consensus Algorithm (Extended Version)》</a>(寻找一种易于理解的一致性算法)</p></blockquote><a id="more"></a><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>Raft 是一种用来管理日志复制的一致性算法。它和 Paxos 的性能和功能是一样的，但是它和 Paxos 的结构不一样；这使得 Raft 更容易理解并且更易于建立实际的系统。为了提高理解性，Raft 将一致性算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须需要考虑的状态。从用户学习的结果来看，Raft 比 Paxos 更容易学会。Raft 还包括了一种新的机制来使得动态改变集群成员，它使用重叠大多数（overlapping majorities）来保证安全。</p><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。正因为此，他们扮演着建立大规模可靠的软件系统的关键角色。在过去的十年中 Paxos 一直都主导着有关一致性算法的讨论：大多数一致性算法的实现都基于它或者受它影响，并且 Paxos 也成为了教学生关于一致性知识的主要工具。</p><p>不幸的是，尽管在降低它的复杂性方面做了许多努力，Paxos 依旧很难理解。并且，Paxos 需要经过复杂的修改才能应用于实际中。这些导致了系统构构建者和学生都十分头疼。</p><p>在被 Paxos 折磨之后，我们开始寻找一种在系统构建和教学上更好的新的一致性算法。我们的首要目标是让它易于理解：我们能不能定义一种面向实际系统的一致性算法并且比 Paxos 更容易学习呢？并且，我们希望这种算法能凭直觉就能明白，这对于一个系统构建者来说是十分必要的。对于一个算法，不仅仅是让它工作起来很重要，知道它是如何工作的更重要。</p><p>我们工作的结果是一种新的一致性算法，叫做 Raft。在设计 Raft 的过程中我们应用了许多专门的技巧来提升理解性，包括算法分解（分为领导选取（leader selection），日志复制（log replication）和安全性（safety））和减少状态（state space reduction）（相对于 Paxos，Raft 减少了非确定性的程度和服务器互相不一致的方式）。在两所学校的43个学生的研究中发现，Raft 比 Paxos 要更容易理解：在学习了两种算法之后，其中的33个学生回答 Raft 的问题要比回答 Paxos 的问题要好。</p><p>Raft 算法和现在一些已经有的算法在一些地方很相似（主要是 <a href="http://www.pmg.csail.mit.edu/papers/vr.pdf" target="_blank" rel="noopener">Oki 和 Liskov 的 Viewstamped Replication</a>。但是 Raft 有几个新的特性：</p><ul><li>强领导者（Strong Leader）：Raft 使用一种比其他算法更强的领导形式。例如，日志条目只从领导者发送向其他服务器。这样就简化了对日志复制的管理，使得 Raft 更易于理解。</li><li>领导选取（Leader Selection）：Raft 使用随机定时器来选取领导者。这种方式仅仅是在所有算法都需要实现的心跳机制上增加了一点变化，它使得在解决冲突时更简单和快速。</li><li>成员变化（Membership Change）：Raft 为了调整集群中成员关系使用了新的联合一致性（joint consensus）的方法，这种方法中大多数不同配置的机器在转换关系的时候会交迭（overlap）。这使得在配置改变的时候，集群能够继续操作。</li></ul><p>我们认为，Raft 在教学方面和实际实现方面比 Paxos 和其他算法更出众。它比其他算法更简单、更容易理解；它能满足一个实际系统的需求；它拥有许多开源的实现并且被许多公司所使用；它的安全特性已经被证明；并且它的效率和其他算法相比也具有竞争力。</p><p>这篇论文剩下的部分会讲如下内容：复制状态机（replicated state machine）问题（第2节），讨论 Paxos 的优缺点（第3节），讨论我们用的为了达到提升理解性的方法（第4节），陈述 Raft 一致性算法（第5~8节），评价 Raft 算法（第9节），对相关工作的讨论（第10节）。</p><h1 id="2-复制状态机（Replicated-State-Machine）"><a href="#2-复制状态机（Replicated-State-Machine）" class="headerlink" title="2 复制状态机（Replicated State Machine）"></a>2 复制状态机（Replicated State Machine）</h1><p>一致性算法是在<a href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf" target="_blank" rel="noopener">复制状态机</a>的背景下提出来的。在这个方法中，在一组服务器的状态机产生同样的状态的副本因此即使有一些服务器崩溃了这组服务器也还能继续执行。复制状态机在分布式系统中被用于解决许多有关容错的问题。例如，GFS，HDFS还有 RAMCloud 这些大规模的系统都是用一个单独的集群领导者，使用一个单独的复制状态机来进行领导选取和存储配置信息来应对领导者的崩溃。使用复制状态机的例子有 Chubby 和 ZooKeeper。</p><p><br><br></p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1fbxcex0w1fj20gt08vwfr.jpg" alt=""></p><center>图-1：复制状态机的架构。一致性算法管理来自客户端状态命令的复制日志。状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</center><p><br><br></p><p>如图-1所示，复制状态机是通过复制日志来实现的。每一台服务器保存着一份日志，日志中包含一系列的命令，状态机会按顺序执行这些命令。因为每一台计算机的状态机都是确定的，所以每个状态机的状态都是相同的，执行的命令是相同的，最后的执行结果也就是一样的了。</p><p>如何保证复制日志一致就是一致性算法的工作了。在一台服务器上，一致性模块接受客户端的命令并且把命令加入到它的日志中。它和其他服务器上的一致性模块进行通信来确保每一个日志最终包含相同序列的请求，即使有一些服务器宕机了。一旦这些命令被正确的复制了，每一个服务器的状态机都会按同样的顺序去执行它们，然后将结果返回给客户端。最终，这些服务器看起来就像一台可靠的状态机。</p><p>应用于实际系统的一致性算法一般有以下特性：</p><ul><li>确保安全性（从来不会返回一个错误的结果），即使在所有的非拜占庭（Non-Byzantine）情况下，包括网络延迟、分区、丢包、冗余和乱序的情况下。</li><li>高可用性，只要集群中的大部分机器都能运行，可以互相通信并且可以和客户端通信，这个集群就可用。因此，一般来说，一个拥有 5 台机器的集群可以容忍其中的 2 台的失败（fail）。服务器停止工作了我们就认为它失败（fail）了，没准一会当它们拥有稳定的存储时就能从中恢复过来，重新加入到集群中。</li><li>不依赖时序保证一致性，时钟错误和极端情况下的消息延迟在最坏的情况下才会引起可用性问题。</li><li>通常情况下，一条命令能够尽可能快的在大多数节点对一轮远程调用作出相应时完成，一少部分慢的机器不会影响系统的整体性能。</li></ul><h1 id="3-Paxos-算法的不足"><a href="#3-Paxos-算法的不足" class="headerlink" title="3 Paxos 算法的不足"></a>3 Paxos 算法的不足</h1><p>在过去的10年中，Leslie Lamport 的 Paxos 算法几乎已经成为了一致性算法的代名词：它是授课中最常见的算法，同时也是许多一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，例如一个单一复制日志条目（single replicated log entry）。我们把这个子集叫做单一决策 Paxos（single-decree Paxos）。之后 Paxos通过组合多个这种协议来完成一系列的决策，例如一个日志（multi-Paxos）。Paxos 确保安全性和活跃性（liveness），并且它支持集群成员的变更。它的正确性已经被证明，通常情况下也很高效。</p><p>不幸的是，Paxos 有两个致命的缺点。第一个是 Paxos 太难以理解。它的完整的解释晦涩难懂；很少有人能完全理解，只有少数人成功的读懂了它。并且大家做了许多努力来用一些简单的术语来描述它。尽管这些解释都关注于单一决策子集问题，但仍具有挑战性。在 NSDI 2012 会议上的一次非正式调查显示，我们发现大家对 Paxos 都感到不满意，其中甚至包括一些有经验的研究员。我们自己也曾深陷其中，我们在读过几篇简化它的文章并且设计了我们自己的算法之后才完全理解了  Paxos，而整个过程花费了将近一年的时间。</p><p>我们假定 Paxos 的晦涩来源于它将单决策子集作为它的基础。单决策（Single-decree）Paxos 是晦涩且微妙的：它被划分为两个没有简单直观解释的阶段，并且难以独立理解。正因为如此，它不能很直观的让我们知道为什么单一决策协议能够工作。为多决策 Paxos 设计的规则又添加了额外的复杂性和精巧性。我们相信多决策问题能够分解为其它更直观的方式。</p><p>Paxos 的第二个缺点是它难以在实际环境中实现。其中一个原因是，对于多决策 Paxos （multi-Paxos） ，大家还没有一个一致同意的算法。Lamport 的描述大部分都是有关于单决策 Paxos （single-decree Paxos）；他仅仅描述了实现多决策的可能的方法，缺少许多细节。有许多实现 Paxos 和优化 Paxos 的尝试，但是他们都和 Lamport 的描述有些出入。例如，Chubby 实现的是一个类似 Paxos 的算法，但是在许多情况下的细节没有公开。</p><p>另外，Paxos 的结构也是不容易在一个实际系统中进行实现的，这是单决策问题分解带来的又一个问题。例如，从许多日志条目中选出条目然后把它们融合到一个序列化的日志中并没有带来什么好处，它仅仅增加了复杂性。围绕着日志来设计一个系统是更简单、更高效的：新日志按照严格的顺序添加到日志中去。另一个问题是，Paxos 使用对等的点对点的实现作为它的核心（尽管它最终提出了一种弱领导者的形式来优化性能）。这种方法在只有一个决策被制定的情况下才显得有效，但是很少有现实中的系统使用它。如果要做许多的决策，选择一个领导人，由领带人来协调是更简单有效的方法。</p><p>因此，在实际的系统应用中和 Paxos 算法都相差很大。所有开始于 Paxos 的实现都会遇到很多问题，然后由此衍生出了许多与 Paxos 有很大不同的架构。这是既费时又容易出错的，并且理解 Paxos 的难度又非常大。Paxos 算法在它正确性的理论证明上是很好的，但是在实现上的价值就远远不足了。来自 Chubby 的实现的一条评论就能够说明：</p><blockquote><p>Paxos 算法的描述与实际实现之间存在巨大的鸿沟…最终的系统往往建立在一个没有被证明的算法之上。</p></blockquote><p>正因为存在这些问题，我们认为 Paxos 不仅对于系统的构建者来说不友好，同时也不利于教学。鉴于一致性算法对于大规模软件系统的重要性，我们决定试着来设计一种另外的比 Paxos 更好的一致性算法。Raft 就是这样的一个算法。</p><h1 id="4-易于理解的设计"><a href="#4-易于理解的设计" class="headerlink" title="4 易于理解的设计"></a>4 易于理解的设计</h1><p>设计 Raft 的目标有如下几个：</p><ul><li>它必须提供一个完整的、实际的基础来进行系统构建，为的是减少开发者的工作；</li><li>它必须在所有情况下都能保证安全可用；</li><li>它对于常规操作必须高效；</li><li>最重要的目标是：<strong>易于理解</strong>，它必须使得大多数人能够很容易的理解；</li><li>另外，它必须能让开发者有一个直观的认识，这样才能使系统构建者们去对它进行扩展。</li></ul><p>在设计 Raft 的过程中，我们不得不在许多种方法中做出选择。当面临这种情况时，我们通常会权衡可理解性：每种方法的可理解性是如何的？（例如，它的状态空间有多复杂？它是不是有很细微的含义？）它的可读性如何？读者能不能轻易地理解这个方法和它的含义？</p><p>我们意识到对这种可理解性的分析具有高度的主观性；尽管如此，我们使用了两种适用的方式。第一种是众所周知的问题分解：我们尽可能将问题分解成为若干个可解决的、可被理解的小问题。例如，在 Raft 中，我们把问题分解成为了<strong>领导选取（leader election）</strong>、<strong>日志复制（log replication）</strong>、<strong>安全（safety）</strong>和<strong>成员变化（membership changes）</strong>。</p><p>我们采用的第二个方法是通过减少需要考虑的状态的数量将状态空间简化，这能够使得整个系统更加一致并且尽可能消除不确定性。特别地，日志之间不允许出现空洞，并且 Raft 限制了限制了日志不一致的可能性。尽管在大多数情况下，我们都都在试图消除不确定性，但是有时候有些情况下，不确定性使得算法更易理解。尤其是，随机化方法使得不确定性增加，但是它减少了状态空间。我们使用随机化来简化了 Raft 中的领导选取算法。</p><h1 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5 Raft 一致性算法"></a>5 Raft 一致性算法</h1><p>Raft 是一种用来管理第 2 章中提到的复制日志的算法。表-2 为了方便参考是一个算法的总结版本，表-3 列举了算法中的关键性质；表格中的这些元素将会在这一章剩下的部分中分别进行讨论。</p><p><strong>状态：</strong></p><p><u>在所有服务器上持久存在的：（在响应远程过程调用 RPC 之前稳定存储的）</u></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">currentTerm</td><td style="text-align:center">服务器最后知道的任期号（从0开始递增）</td></tr><tr><td style="text-align:center">votedFor</td><td style="text-align:center">在当前任期内收到选票的候选人 id（如果没有就为 null）</td></tr><tr><td style="text-align:center">log[]</td><td style="text-align:center">日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号</td></tr></tbody></table><p><u>在所有服务器上不稳定存在的：</u></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">commitIndex</td><td style="text-align:center">已知的被提交的最大日志条目的索引值（从0开始递增）</td></tr><tr><td style="text-align:center">lastApplied</td><td style="text-align:center">被状态机执行的最大日志条目的索引值（从0开始递增）</td></tr></tbody></table><p><u>在领导人服务器上不稳定存在的：（在选举之后初始化的）</u></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">nextIndex[]</td><td style="text-align:center">对于每一个服务器，记录需要发给它的下一个日志条目的索引（初始化为领导人上一条日志的索引值+1）</td></tr><tr><td style="text-align:center">matchIndex[]</td><td style="text-align:center">对于每一个服务器，记录已经复制到该服务器的日志的最高索引值（从0开始递增）</td></tr></tbody></table><center>表-2-i</center><p><strong>附加日志远程过程调用 （AppendEntries RPC）</strong></p><p>由领导人来调用复制日志（5.3节）；也会用作heartbeat</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">term</td><td style="text-align:center">领导人的任期号</td></tr><tr><td style="text-align:center">leaderId</td><td style="text-align:center">领导人的 id，为了其他服务器能重定向到客户端</td></tr><tr><td style="text-align:center">prevLogIndex</td><td style="text-align:center">最新日志之前的日志的索引值</td></tr><tr><td style="text-align:center">prevLogTerm</td><td style="text-align:center">最新日志之前的日志的领导人任期号</td></tr><tr><td style="text-align:center">entries[]</td><td style="text-align:center">将要存储的日志条目（表示 heartbeat 时为空，有时会为了效率发送超过一条）</td></tr><tr><td style="text-align:center">leaderCommit</td><td style="text-align:center">领导人提交的日志条目索引值</td></tr></tbody></table><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">term</td><td style="text-align:center">当前的任期号，用于领导人更新自己的任期号</td></tr><tr><td style="text-align:center">success</td><td style="text-align:center">如果其它服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td></tr></tbody></table><p><strong>接受者需要实现：</strong></p><ol><li>如果 <code>term &lt; currentTerm</code>返回 false（5.1节）</li><li>如果在<code>prevLogIndex</code>处的日志的任期号与<code>prevLogTerm</code>不匹配时，返回 false（5.3节）</li><li>如果一条已经存在的日志与新的冲突（index 相同但是任期号 term 不同），则删除已经存在的日志和它之后所有的日志（5.3节）</li><li>添加任何在已有的日志中不存在的条目</li><li>如果<code>leaderCommit &gt; commitIndex</code>，将<code>commitIndex</code>设置为<code>leaderCommit</code>和最新日志条目索引号中较小的一个</li></ol><center>表-2-ii</center><p><strong>投票请求 RPC（RequestVote RPC）</strong></p><p>由候选人发起收集选票（5.2节）</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">term</td><td style="text-align:center">候选人的任期号</td></tr><tr><td style="text-align:center">candidateId</td><td style="text-align:center">请求投票的候选人 id</td></tr><tr><td style="text-align:center">lastLogIndex</td><td style="text-align:center">候选人最新日志条目的索引值</td></tr><tr><td style="text-align:center">lastLogTerm</td><td style="text-align:center">候选人最新日志条目对应的任期号</td></tr></tbody></table><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">term</td><td style="text-align:center">目前的任期号，用于候选人更新自己</td></tr><tr><td style="text-align:center">voteGranted</td><td style="text-align:center">如果候选人收到选票为 true</td></tr></tbody></table><p><strong>接受者需要实现：</strong></p><ol><li>如果<code>term &lt; currentTerm</code>返回 false（5.1节）</li><li>如果<code>votedFor</code>为空或者与<code>candidateId</code>相同，并且候选人的日志和自己的日志一样新，则给该候选人投票（5.2节 和 5.4节）</li></ol><center>表-2-iii</center><p><strong>服务器需要遵守的规则：</strong></p><p><u>所有服务器：</u></p><ul><li>如果<code>commitIndex &gt; lastApplied</code>，<code>lastApplied</code>自增，将<code>log[lastApplied]</code>应用到状态机（5.3节）</li><li>如果 RPC 的请求或者响应中包含一个 term T 大于 <code>currentTerm</code>，则<code>currentTerm</code>赋值为 T，并切换状态为追随者（Follower）（5.1节）</li></ul><p><u>追随者（followers）: 5.2节</u></p><ul><li>响应来自候选人和领导人的 RPC</li><li>如果在超过选取领导人时间之前没有收到来自当前领导人的<code>AppendEntries RPC</code>或者没有收到候选人的投票请求，则自己转换状态为候选人</li></ul><p><u>候选人：5.2节</u></p><ul><li>转变为选举人之后开始选举：<ul><li><code>currentTerm</code>自增</li><li>给自己投票</li><li>重置选举计时器</li><li>向其他服务器发送<code>RequestVote RPC</code></li></ul></li><li>如果收到了来自大多数服务器的投票：成为领导人</li><li>如果收到了来自新领导人的<code>AppendEntries RPC（heartbeat）</code>：转换状态为追随者</li><li>如果选举超时：开始新一轮的选举</li></ul><p><u>领导人：</u></p><ul><li>一旦成为领导人：向其他所有服务器发送空的<code>AppendEntries RPC（heartbeat）</code>;在空闲时间重复发送以防止选举超时（5.2节）</li><li>如果收到来自客户端的请求：向本地日志增加条目，在该条目应用到状态机后响应客户端（5.3节）</li><li>对于一个追随者来说，如果上一次收到的日志索引大于将要收到的日志索引（nextIndex）：通过<code>AppendEntries RPC</code>将 nextIndex 之后的所有日志条目发送出去<ul><li>如果发送成功：将该追随者的 <code>nextIndex</code>和<code>matchIndex</code>更新</li><li>如果由于日志不一致导致<code>AppendEntries RPC</code>失败：<code>nextIndex</code>递减并且重新发送（5.3节）</li></ul></li><li>如果存在一个满足<code>N &gt; commitIndex</code>和<code>matchIndex[i] &gt;= N</code>并且<code>log[N].term == currentTerm</code>的 N，则将<code>commitIndex</code>赋值为 N</li></ul><center>表-2-iv</center><center>表-2：Raft 一致性算法的总结（不包括成员变化 membership changes 和日志压缩 log compaction）</center><p><br><br></p><table><thead><tr><th style="text-align:center">性质</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">选举安全原则（Election Safety）</td><td style="text-align:center">一个任期（term）内最多允许有一个领导人被选上（5.2节）</td></tr><tr><td style="text-align:center">领导人只增加原则（Leader Append-Only）</td><td style="text-align:center">领导人永远不会覆盖或者删除自己的日志，它只会增加条目</td></tr><tr><td style="text-align:center">日志匹配原则（Log Matching）</td><td style="text-align:center">如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同（5.3 节）</td></tr><tr><td style="text-align:center">领导人完全原则（Leader Completeness)</td><td style="text-align:center">如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的领导人中</td></tr><tr><td style="text-align:center">状态机安全原则（State Machine Safety）</td><td style="text-align:center">如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目（5.4.3节）</td></tr></tbody></table><center>表-3：Raft 算法保证这些特性任何时刻都成立</center><p><br><br></p><p>Raft 通过首先选出一个领导人来实现一致性，然后给予领导人完全管理复制日志（replicated log）的责任。领导人接收来自客户端的日志条目，并把它们复制到其他的服务器上，领带人还要告诉服务器们什么时候将日志条目应用到它们的状态机是安全的。通过选出领导人能够简化复制日志的管理工作。例如，领导人能够决定将新的日志条目放到哪，而并不需要和其他的服务器商议，数据流被简化成从领导人流向其他服务器。如果领导人宕机或者和其他服务器失去连接，就可以选取下一个领导人。</p><p>通过选出领导人，Raft 将一致性问题分解成为三个相对独立的子问题：</p><ul><li><strong>领导人选取（Leader election）：</strong> 在一个领导人宕机之后必须要选取一个新的领导人（5.2节）</li><li><strong>日志复制（Log replication）：</strong> 领导人必须从客户端接收日志然后复制到集群中的其他服务器，并且强制要求其他服务器的日志保持和自己相同</li><li><strong>安全性（Safety）：</strong> Raft 的关键的安全特性是 表-3 中提到的状态机安全原则（State Machine Safety）:如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目。5.4节阐述了 Raft 是如何保证这条原则的，解决方案涉及到一个对于选举机制另外的限制，这一部分会在 5.2节 中说明。</li></ul><p>在说明了一致性算法之后，本章会讨论有关可用性（availability）的问题和系统中时序（timing）的问题。</p><h2 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h2><p>一个 Raft 集群包括若干服务器；对于一个典型的 5 服务器集群，该集群能够容忍 2 台机器不能正常工作，而整个系统保持正常。在任意的时间，每一个服务器一定会处于以下三种状态中的一个：<em>领导人</em>、<em>候选人</em>、<em>追随者</em>。在正常情况下，只有一个服务器是领导人，剩下的服务器是追随者。追随者们是被动的：他们不会发送任何请求，只是响应来自领导人和候选人的请求。领导人来处理所有来自客户端的请求（如果一个客户端与追随者进行通信，追随者会将信息发送给领导人）。候选人是用来选取一个新的领导人的，这一部分会在 5.2节 进行阐释。图-4 阐述了这些状态，和它们之间的转换；它们的转换会在下边进行讨论。</p><p><br><br></p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fc9uv9fx6wj20hn07xt9z.jpg" alt=""></p><center>图-4：服务器的状态。追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。</center><p><br><br></p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fc9vx0s6l6j20ef05odg9.jpg" alt=""></p><center>图-5：时间被分为一个个的任期（term），每一个任期的开始都是领导人选举。在成功选举之后，一个领导人会在任期内管理整个集群。如果选举失败，该任期就会因为没有领带人而结束。这个转变会在不同的时间的不同服务器上观察到。</center><p><br><br></p><p>如 图-5 所示，Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），就像 5.2节 所描述的那样，一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最少要有一个领导人。</p><p>不同的服务器可能会在任期内观察到多次不同的状态转换，在某些情况下，一台服务器可能看不到一次选举或者一个完整的任期。任期在 Raft 中充当逻辑时钟的角色，并且它们允许服务器检测过期的信息，比如过时的领导人。每一台服务器都存储着一个当前任期的数字，这个数字会单调的增加。当服务器之间进行通信时，会互相交换当前任期号；如果一台服务器的当前任期号比其它服务器的小，则更新为较大的任期号。如果一个候选人或者领导人意识到它的任期号过时了，它会立刻转换为追随者状态。如果一台服务器收到的请求的任期号是过时的，那么它会拒绝此次请求。</p><p>Raft 中的服务器通过远程过程调用（RPC）来通信，基本的 Raft 一致性算法仅需要 2 种 RPC。RequestVote RPC 是候选人在选举过程中触发的（5.2节），AppendEntries RPC 是领导人触发的，为的是复制日志条目和提供一种心跳（heartbeat）机制（5.3节）。第7章加入了第三种 RPC 来在各个服务器之间传输快照（snapshot）。如果服务器没有及时收到 RPC 的响应，它们会重试，并且它们能够并行的发出 RPC 来获得最好的性能。</p><h2 id="5-2-领导人选取"><a href="#5-2-领导人选取" class="headerlink" title="5.2 领导人选取"></a>5.2 领导人选取</h2><p>Raft 使用一种心跳机制（heartbeat）来触发领导人的选取。当服务器启动时，它们会初始化为追随者。一太服务器会一直保持追随者的状态只要它们能够收到来自领导人或者候选人的有效 RPC。领导人会向所有追随者周期性发送心跳（heartbeat，不带有任何日志条目的 AppendEntries RPC）来保证它们的领导人地位。如果一个追随者在一个周期内没有收到心跳信息，就叫做选举超时（election timeout）,然后它就会假定没有可用的领导人并且开始一次选举来选出一个新的领导人。</p><p>为了开始选举，一个追随者会自增它的当前任期并且转换状态为候选人。然后，它会给自己投票并且给集群中的其他服务器发送 RequestVote RPC。一个候选人会一直处于该状态，直到下列三种情形之一发生：</p><ul><li>它赢得了选举；</li><li>另一台服务器赢得了选举；</li><li>一段时间后没有任何一台服务器赢得了选举</li></ul><p>这些情形会在下面的章节中分别讨论。</p><p>一个候选人如果在一个任期内收到了来自集群中大多数服务器的投票就会赢得选举。在一个任期内，一台服务器最多能给一个候选人投票，按照先到先服务原则（first-come-first-served）（注意：在 5.4节 针对投票添加了一个额外的限制）。大多数原则使得在一个任期内最多有一个候选人能赢得选举（表-3 中提到的选举安全原则）。一旦有一个候选人赢得了选举，它就会成为领导人。然后它会像其他服务器发送心跳信息来建立自己的领导地位并且组织新的选举。</p><p>当一个候选人等待别人的选票时，它有可能会收到来自其他服务器发来的声明其为领导人的 AppendEntries RPC。如果这个领导人的任期（包含在它的 RPC 中）比当前候选人的当前任期要大，则候选人认为该领导人合法，并且转换自己的状态为追随者。如果在这个 RPC 中的任期小于候选人的当前任期，则候选人会拒绝此次 RPC， 继续保持候选人状态。</p><p>第三种情形是一个候选人既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。</p><p>Raft 使用随机的选举超时时间来确保第三种情形很少发生，并且能够快速解决。为了防止在一开始是选票就被瓜分，选举超时时间是在一个固定的间隔内随机选出来的（例如，150~300ms）。这种机制使得在大多数情况下只有一个服务器会率先超时，它会在其它服务器超时之前赢得选举并且向其它服务器发送心跳信息。同样的机制被用于选票一开始被瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，在超时进行下一次选举之前一直等待。这能够减小在新的选举中一开始选票就被瓜分的可能性。9.3节 展示了这种方法能够快速的选出一个领导人。</p><p>选举是一个理解性引导我们设计替代算法的一个例子。最开始时，我们计划使用一种排名系统：给每一个候选人分配一个唯一的排名，用于在竞争的候选人之中选择领导人。如果一个候选人发现了另一个比它排名高的候选人，那么它会回到追随者的状态，这样排名高的候选人会很容易地赢得选举。但是我们发现这种方法在可用性方面有一点问题（一个低排名的服务器在高排名的服务器宕机后，需要等待超时才能再次成为候选人，但是如果它这么做的太快，它能重置选举领带人的过程）。我们对这个算法做了多次调整，但是每次调整后都会出现一些新的问题。最终我们认为随机重试的方法是更明确并且更易于理解的。</p><h2 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h2><p>一旦选出了领导人，它就开始接收客户端的请求。每一个客户端请求都包含一条需要被复制状态机（replicated state machine）执行的命令。领导人把这条命令作为新的日志条目加入到它的日志中去，然后并行的向其他服务器发起 AppendEntries RPC ，要求其它服务器复制这个条目。当这个条目被安全的复制之后（下面的部分会详细阐述），领导人会将这个条目应用到它的状态机中并且会向客户端返回执行结果。如果追随者崩溃了或者运行缓慢或者是网络丢包了，领导人会无限的重试 AppendEntries RPC（甚至在它向客户端响应之后）知道所有的追随者最终存储了所有的日志条目。</p><p><br><br></p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1fc9zgzzchkj20hl0d7wg4.jpg" alt=""></p><center>图-6：日志由有序编号的日志条目组成。每个日志条目包含它被创建时的任期号（每个方块中的数字），并且包含用于状态机执行的命令。如果一个条目能够被状态机安全执行，就被认为可以提交了。</center><p><br><br></p><p>日志就像 图-6 所示那样组织的。每个日志条目存储着一条被状态机执行的命令和当这条日志条目被领导人接收时的任期号。日志条目中的任期号用来检测在不同服务器上日志的不一致性，并且能确保 图-3 中的一些特性。每个日志条目也包含一个整数索引来表示它在日志中的位置。</p><p>领导人决定什么时候将日志条目应用到状态机是安全的；这种条目被称为可被提交（commited）。Raft 保证可被提交（commited）的日志条目是持久化的并且最终会被所有可用的状态机执行。一旦被领导人创建的条目已经复制到了大多数的服务器上，这个条目就称为可被提交的（例如，图-6中的7号条目）。领导人日志中之前的条目都是可被提交的（commited），包括由之前的领导人创建的条目。5.4节将会讨论当领导人更替之后这条规则的应用问题的细节，并且也讨论了这种提交方式是安全的。领导人跟踪记录它所知道的被提交条目的最大索引值，并且这个索引值会包含在之后的 AppendEntries RPC 中（包括心跳 heartbeat 中），为的是让其他服务器都知道这条条目已经提交。一旦一个追随者知道了一个日志条目已经被提交，它会将该条目应用至本地的状态机（按照日志顺序）。</p><p>我们设计了 Raft 日志机制来保证不同服务器上日志的一致性。这样做不仅简化了系统的行为使得它更可预测，并且也是保证安全性不可或缺的一部分。Raft 保证以下特性，并且也保证了 表-3 中的日志匹配原则（Log Matching Property）:</p><ul><li>如果在不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li><li>如果在不同日志中的两个条目有着相同的索引和任期号，则它们之间的所有条目都是完全一样的。</li></ul><p>第一条特性源于领导人在一个任期里在给定的一个日志索引位置最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，领导人会把新日志条目紧接着之前的条目的索引位置和任期号都包含在里面。如果追随者没有在它的日志中找到相同索引和任期号的日志，它就会拒绝新的日志条目。这个一致性检查就像一个归纳步骤：一开始空的日志的状态一定是满足日志匹配原则的，一致性检查保证了当日志添加时的日志匹配原则。因此，只要 AppendEntries 返回成功的时候，领导人就知道追随者们的日志和它的是一致的了。</p><p><br><br></p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fca1aw93cnj20gf0baabf.jpg" alt=""></p><center>图-7：当最上边的领导人掌权之后，追随者日志可能有以下情况（a~f）。一个格子表示一个日志条目；格子中的数字是它的任期。一个追随者可能会丢失一些条目（a, b）；可能多出来一些未提交的条目（c, d）；或者两种情况都有（e, f）。例如，场景 f 在如下情况下就会发生：如果一台服务器在任期2时是领导人并且往它的日志中添加了一些条目，然后在将它们提交之前就宕机了，之后它很快重启了，成为了任期3的领导人，又往它的日志中添加了一些条目，然后在任期2和任期3中的条目提交之前它又宕机了并且几个任期内都一直处于宕机状态。</center><p><br><br></p><p>在一般情况下，领导人和追随者们的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而，领导人的崩溃会导致日志不一致（旧的领导人可能没有完全复制完日志中的所有条目）。这些不一致会导致一系列领导人和追随者崩溃。图-7 阐述了一些追随者可能和新的领导人日志不同的情况。一个追随者可能会丢失掉领导人上的一些条目，也有可能包含一些领导人没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p><p>在 Raft 算法中，领导人通过强制追随者们复制它的日志来处理日志的不一致。这就意味着，在追随者上的冲突日志会被领导者的日志覆盖。5.4节会说明当添加了一个额外的限制之后这是安全的。</p><p>为了使得追随者的日志同自己的一致，领导人需要找到追随者同它的日志一致的地方，然后删除追随者在该位置之后的条目，然后将自己在该位置之后的条目发送给追随者。这些操作都在 AppendEntries RPC 进行一致性检查时完成。领导人给每一个追随者维护了一个<code>nextIndex</code>，它表示领导人将要发送给该追随者的下一条日志条目的索引。当一个领导人开始掌权时，它会将<code>nextIndex</code>初始化为它的最新的日志条目索引数+1（图-7 中的 11）。如果一个追随者的日志和领导者的不一致，AppendEntries 一致性检查会在下一次 AppendEntries RPC 时返回失败。在失败之后，领导人会将<code>nextIndex</code>递减然后重试 AppendEntries RPC。最终<code>nextIndex</code>会达到一个领导人和追随者日志一致的地方。这时，AppendEntries 会返回成功，追随者中冲突的日志条目都被移除了，并且添加所缺少的上了领导人的日志条目。一旦 AppendEntries 返回成功，追随者和领导人的日志就一致了，这样的状态会保持到该任期结束。</p><p>如果需要的话，算法还可以进行优化来减少 AppendEntries RPC 失败的次数。例如，当拒绝了一个 AppendEntries 请求，追随者可以记录下冲突日志条目的任期号和自己存储那个任期的最早的索引。通过这些信息，领导人能够直接递减<code>nextIndex</code>跨过那个任期内所有的冲突条目；这样的话，一个冲突的任期需要一次 AppendEntries RPC，而不是每一个冲突条目需要一次 AppendEntries RPC。在实践中，我们怀疑这种优化是否是必要的，因为AppendEntries 一致性检查很少失败并且也不太可能出现大量的日志条目不一致的情况。</p><p>通过这种机制，一个领导人在掌权时不需要采取另外特殊的方式来恢复日志的一致性。它只需要使用一些常规的操作，通过响应 AppendEntries 一致性检查的失败能使得日志自动的趋于一致。一个领导人从来不会覆盖或者删除自己的日志（表-3 中的领导人只增加原则）。</p><p>这个日志复制机制展示了在第2章中阐述的所希望的一致性特性：Raft 能够接受，复制并且应用新的日志条目只要大部分的服务器是正常的。在通常情况下，一条新的日志条目可以在一轮 RPC 内完成在集群的大多数服务器上的复制；并且一个速度很慢的追随者并不会影响整体的性能。</p><p>##5.4 安全性</p><p>之前的章节中讨论了 Raft 算法是如何进行领导选取和复制日志的。然而，到目前为止这个机制还不能保证每一个状态机能按照相同的顺序执行同样的指令。例如，当领导人提交了若干日志条目的同时一个追随者可能宕机了，之后它又被选为了领导人然后用新的日志条目覆盖掉了旧的那些，最后，不同的状态机可能执行不同的命令序列。</p><p>这一节通过在领带人选取部分加入了一个限制来完善了 Raft 算法。这个限制能够保证对于固定的任期，任何的领导人都拥有之前任期提交的全部日志条目（表-3 中的领导人完全原则）。有了这一限制，日志提交的规则就更清晰了。最后，我们提出了对于领导人完全原则的简单证明并且展示了它是如何修正复制状态机的行为的。</p><p>###5.4.1 选举限制</p><p>在所有的以领导人为基础的一致性算法中，领导人最终必须要存储全部已经提交的日志条目。在一些一致性算法中，例如：<a href="http://people.csail.mit.edu/cowling/vr/vr-revisited.pdf" target="_blank" rel="noopener">Viewstamped Replication</a>，即使一开始没有包含全部已提交的条目也可以被选为领导人。这些算法都有一些另外的机制来保证找到丢失的条目并将它们传输给新的领导人，这个过程要么在选举过程中完成，要么在选举之后立即开始。不幸的是，这种方式大大增加了复杂性。Raft 使用了一种更简单的方式来保证在新的领导人开始选举的时候在之前任期的所有已提交的日志条目都会出现在上边，而不需要将这些条目传送给领导人。这就意味着日志条目只有一个流向：从领导人流向追随者。领导人永远不会覆盖已经存在的日志条目。</p><p>Raft 使用投票的方式来阻止没有包含全部日志条目的服务器赢得选举。一个候选人为了赢得选举必须要和集群中的大多数进行通信，这就意味着每一条已经提交的日志条目最少在其中一台服务器上出现。如果候选人的日志至少和大多数服务器上的日志一样新（up-to-date，这个概念会在下边有详细介绍），那么它一定包含有全部的已经提交的日志条目。RequestVote RPC 实现了这个限制：这个 RPC（远程过程调用）包括候选人的日志信息，如果它自己的日志比候选人的日志要新，那么它会拒绝候选人的投票请求。</p><p>Raft 通过比较日志中最后一个条目的索引和任期号来决定两个日志哪一个更新。如果两个日志的任期号不同，任期号大的更新；如果任期号相同，更长的日志更新。</p><p>###5.4.2 提交之前任期的日志条目</p><p><img src="http://wx4.sinaimg.cn/mw690/4858d6a8ly1fcc521xcvnj20ih08o75m.jpg" alt=""></p><center>图-8：如图的时间序列说明了为什么领导人不能通过之前任期的日志条目判断它的提交状态。（a）中的 S1 是领导人并且部分复制了索引2上的日志条目。（b）中 S1 崩溃了；S5 通过 S3，S4 和自己的选票赢得了选举，并且在索引2上接收了另一条日志条目。（c）中 S5 崩溃了，S1 重启了，通过 S2，S3 和自己的选票赢得了选举，并且继续索引2处的复制，这时任期2的日志条目已经在大部分服务器上完成了复制，但是还并没有提交。如果在（d）时刻 S1 崩溃了，S5 会通过 S2，S3，S4 的选票成为领导人，然后用它自己在任期3的日志条目覆盖掉其他服务器的日志条目。然而，如果在崩溃之前，S1 在它的当前任期在大多数服务器上复制了一条日志条目，就像在（e）中那样，那么这条条目就会被提交（S5就不会赢得选举）。在这时，之前的日志条目就会正常被提交。</center><p><br><br></p><p>正如 5.3节 中描述的那样，只要一个日志条目被存在了在多数的服务器上，领导人就知道当前任期就可以提交该条目了。如果领导人在提交之前就崩溃了，之后的领导人会试着继续完成对日志的复制。然而，领导人并不能断定存储在大多数服务器上的日志条目一定在之前的任期中被提交了。图-8 说明了一种情况，一条存储在了大多数服务器上的日志条目仍然被新上任的领导人覆盖了。</p><p>为了消除 图-8 中描述的问题，Raft 从来不会通过计算复制的数目来提交之前人气的日志条目。只有领导人当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，通过观察该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用了一种更加保守的方法。</p><p>因为当领导人从之前任期复制日志条目时日志条目保留了它们最开始的任期号，所以这使得 Raft 在提交规则中增加了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要从之前的任期中复制日志条目，它必须要使用当前的新任期号。Raft 的方法使得判断日志更加容易，因为它们全程都保持着同样的任期号。另外，和其它的一致性算法相比，Raft 算法中的新领导人会发送更少的之前任期的日志条目（其他算法必须要发送冗余的日志条目并且在它们被提交之前来重新排序）。</p><h3 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h3><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fcc713vey3j20d3075js9.jpg" alt=""></p><center>图-9：如果 S1（任期 T 的领导人）在它的任期提交了一条日志条目，并且 S5 在之后的任期 U 成为了领导人，那么最少会有一台服务器（S3）接收了这条日志条目并且会给 S5 投票。</center><p><br><br></p><p>给出了完整的 Raft 算法，现在我们能够更精确的论证领导人完全原则（Leader Completeness)（这基于 9.2节 提出的安全性证明）。我们假定领导人完全原则是不成立的，然后推导出矛盾。假定任期 T 的领导人 leader<sub>T</sub>在它的任期提交了一个日志条目，但是这条日志条目并没有存储在之后的任期中的领导人上。我们设大于 T 的最小的任期 U 的领导人（leader<sub>U</sub>） 没有存储这条日志条目。</p><ol><li>在 leader<sub>U</sub> 选举时一定没有那条被提交的日志条目（领导人从来不会删除或者覆盖日志条目）。</li><li>leader<sub>T</sub> 复制了这个条目到集群的大多数的服务器上。因此，只是有一台服务器（投票者）即接收了来自 leader<sub>T</sub> 的日志条目并且给 leader<sub>U</sub> 投票，就像 图-9 中所示那样。这个投票者是产生矛盾的关键。</li><li>投票者必须在给 leader<sub>U</sub> 投票之前接收来自 leader<sub>T</sub> 的日志条目；否则它会拒绝来自 leader<sub>T</sub> 的 AppendEntries 请求（它的当前任期会比 T 要大）。</li><li>投票者会在它给 leader<sub>U</sub> 投票时存储那个条目，因为任何中间的领导人都保有该条目（基于假设），领导人从来不会移除这个条目，并且追随者也只会在和领导人冲突时才会移除日志条目。</li><li>投票者给 leader<sub>U</sub> 投票了，所以 leader<sub>U</sub> 的日志必须和投票者的一样新。这就导致了一个矛盾。</li><li>首先，如果投票者和 leader<sub>U</sub> 最后一条日志条目的任期号相同，那么 leader<sub>U</sub> 的日志一定和投票者的一样长，因此它的日志包含全部投票者的日志条目。这是矛盾的，因为在假设中投票者和 leader<sub>U</sub> 包含的已提交条目是不同的。</li><li>除此之外， leader<sub>U</sub> 的最后一条日志的任期号一定比投票者的大。另外，它也比 T 要大，因为投票者的最后一条日志条目的任期号最小也要是 T（它包含了所有任期 T 提交的日志条目）。创建  leader<sub>U</sub> 最后一条日志条目的上一任领导人必须包含已经提交的日志条目（基于假设）。那么，根据日志匹配原则（Log Matching），leader<sub>U</sub> 也一定包含那条提交的日志条目，这也是矛盾的。</li><li>这时就完成了矛盾推导。因此，所有比任期 T 大的领导人一定包含所有在任期 T 提交的日志条目。</li><li>日志匹配原则（Log Matching）保证了未来的领导人也会包含被间接提交的日志条目，就像 图-8 中（d）时刻索引为2的条目。</li></ol><p>通过给出了 领导人完全原则（Leader Completeness)，我们能够证明 表-3 中的状态机安全原则（State Machine Safety），状态机安全原则（State Machine Safety）讲的是如果一台服务器将给定索引上的日志条目应用到了它自己的状态机上，其它服务器的同一索引位置不可能应用的是其它条目。在一个服务器应用一条日志条目到它自己的状态机中时，它的日志必须和领导人的日志在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性（Log Completeness Property）保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft 算法需要服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p><p>##5.5 追随者和候选人崩溃</p><p>截止到目前，我们只讨论了领导人崩溃的问题。追随者和候选人崩溃的问题解决起来要比领导人崩溃要简单得多，这两者崩溃的处理方式是一样的。如果一个追随者或者候选人崩溃了，那么之后的发送给它的 RequestVote RPC 和 AppendEntries RPC 会失败。Raft 通过无限的重试来处理这些失败；如果崩溃的服务器重启了，RPC 就会成功完成。如果一个服务器在收到了 RPC 之后但是在响应之前崩溃了，那么它会在重启之后再次收到同一个 RPC。因为 Raft 中的 RPC 都是幂等的，因此不会有什么问题。例如，如果一个追随者收到了一个已经包含在它的日志中的 AppendEntries 请求，它会忽视这个新的请求。</p><p>##5.6 时序和可用性</p><p>我们对于 Raft 的要求之一就是安全性不依赖于时序（timing）：系统不能仅仅因为一些事件发生的比预想的快一些或慢一些就产生错误。然而，可用性（系统可以及时响应客户端的特性）不可避免的要依赖时序。例如，如果消息交换在服务器崩溃时花费更多的时间，候选人不会等待太长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p><p>领导人选取是 Raft 中对时序要求最关键的地方。Raft 会选出并且保持一个稳定的领导人只有系统满足下列时序要求（timing requirement）：</p><center>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</center><p>在这个不等式中，<code>broadcastTime</code>指的是一台服务器并行的向集群中的其他服务器发送 RPC 并且收到它们的响应的平均时间；<code>electionTimeout</code>指的就是在 5.2节 描述的选举超时时间；<code>MTBF</code>指的是单个服务器发生故障的间隔时间的平均数。<code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使领导人能够持续发送心跳信息（heartbeat）来阻止追随者们开始选举；根据已经给出的随机化选举超时时间方法，这个不等式也使得瓜分选票的情况变成不可能。<code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当领导人崩溃时，整个大约会在<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小的一部分。</p><p><code>broadcastTime</code>和<code>MTBF</code>是由系统决定的性质，但是<code>electionTimeout</code>是我们必须做出选择的。Raft 的 RPC 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，这取决于存储的技术。因此，<code>electionTimeout</code>一般在 10ms 到 500ms 之间。大多数的服务器的<code>MTBF</code>都在几个月甚至更长，很容易满足这个时序需求。</p><p>#6 集群成员变化</p><p>截止到目前，我们都假定集群的配置（加入到一致性算法的服务器集合）是固定的。在实际中，我们会经常更改配置，例如，替换掉那些崩溃的机器或者更改复制级别。虽然通过关闭整个集群，升级配置文件，然后重启整个集群也可以解决这个问题，但是这回导致在更改配置的过程中，整个集群不可用。另外，如果存在需要手工操作，那么就会有操作失误的风险。为了避免这些问题，我们决定采用自动改变配置并且把这部分加入到了 Raft 一致性算法中。</p><p>为了让配置修改机制能够安全，那么在转换的过程中在任何时间点两个领导人不能再同一个任期被同时选为领导人。不幸的是，服务器集群从旧的配置直接升级到新的配置的任何方法都是不安全的，一次性自动的转换所有服务器是不可能的，所以集群可以在转换的过程中划分成两个单独的组（如 图-10 所示）。<br><br><br></p><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fccbvshy16j20f00a374x.jpg" alt=""></p><center>图-10：从一个配置切换到另一个配置是不安全的因为不同的服务器会在不同的时间点进行切换。在这个例子中，集群数量从三台转换成五台。不幸的是，在一个时间点有两个服务器能被选举成为领导人，一个是在使用旧的配置的机器中（C<sub>old</sub>）选出的领导人，另一个领导人是通过新的配置（C<sub>new</sub>）选出来的。</center><p><br><br></p><p>为了保证安全性，集群配置的调整必须使用两阶段（two-phase）方法。有许多种实现两阶段方法的实现。例如，一些系统在第一个阶段先把旧的配置设为无效使得它无法处理客户端请求，然后在第二阶段启用新的配置。在 Raft 中，集群先切换到一个过渡配置，我们称其为共同一致（joint consensus）；一旦共同一致被提交了，然后系统再切换到新的配置。共同一致是旧的配置和新的配置的组合：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、老配置的服务器都能成为领导人。</li><li>需要分别在两种配置上获得大多数的支持才能达成一致（针对选举和提交）</li></ul><p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然能够响应服务器请求。<br><br><br></p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fccchdn7t2j20gq088q3t.jpg" alt=""></p><center>图-11：集群配置变更的时间线。虚线表示的是已经被创建但是还没提交的配置条目，实线表示的是最新提交的配置条目。领导人首先在它的日志中创建 C<sub>old,new</sub>配置条目并且将它提交到C<sub>old,new</sub>（使用旧配置的大部分服务器和使用新配置的大部分服务器）。然后创建它创建C<sub>new</sub>配置条目并且将它提交到使用新配置的大部分机器上。这样就不存在C<sub>old</sub>和C<sub>new</sub>能够分别同时做出决定的时刻。</center><p><br><br></p><p>集群配置在复制日志中用特殊的日志条目来存储和通信；图-11 展示了配置变更的过程。当一个领导人接收到一个改变配置 C<sub>old</sub> 为 C<sub>new</sub> 的请求，它会为了共同一致以前面描述的日志条目和副本的形式将配置存储起来（图中的 C<sub>old,new</sub>）。一旦一个服务器将新的配置日志条目增加到它的日志中，它就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论它是否已经被提交）。这意味着领导人要使用 C<sub>old,new</sub> 的规则来决定日志条目 C<sub>old,new</sub> 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C<sub>old</sub> 配置也可能是 C<sub>old,new</sub> 配置，这取决于赢得选举的候选人是否已经接收到了 C<sub>old,new</sub> 配置。在任何情况下， C<sub>new</sub> 配置在这一时期都不会单方面的做出决定。</p><p>一旦 C<sub>old,new</sub> 被提交，那么无论是 C<sub>old</sub> 还是 C<sub>new</sub>，在没有经过他人批准的情况下都不可能做出决定，并且领导人完全特性（Leader Completeness Property）保证了只有拥有 C<sub>old,new</sub> 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C<sub>new</sub> 配置的日志条目并复制给集群就是安全的了。另外，每个服务器在收到新的配置的时候就会立即生效。当新的配置在 C<sub>new</sub> 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如 图-11，C<sub>old</sub> 和 C<sub>new</sub> 没有任何机会同时做出单方面的决定；这就保证了安全性。</p><p>针对重新配置提出了三个问题。第一个问题是一开始的时候新的服务器可能没有任何日志条目。如果它们在这个状态下加入到集群中，那么它们需要一段时间来更新追赶，在这个阶段它们还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新的时候使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权的身份加入到集群中来（领导人复制日志给他们，但是不把它们考虑到大多数中）。一旦新的服务器追赶上了集群中的其它机器，重新配置可以像上面描述的一样处理。</p><p>第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C<sub>new</sub> 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括自己；它复制日志但是不把它自己看作是大多数之一。当 C<sub>new</sub> 被提交时，会发生领导人过渡，因为这时是新的配置可以独立工作的最早的时间点（总是能够在 C<sub>new</sub> 配置下选出新的领导人）。在此之前，可能只能从 C<sub>old</sub> 中选出领导人。</p><p>第三个问题是，移除不在 C<sub>new</sub> 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳（heartbeat），所以当选举超时时，它们就会进行新的选举过程。它们会发送带有新的任期号的 RequestVote RPC，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。</p><p>为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略 RequestVote RPC。特别的，当服务器在当前最小选举超时时间内收到一个 RequestVote RPC，它不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么它就不会被更大的任期号废除。</p><p>#7 日志压缩</p><p>Raft 产生的日志在持续的正常操作中不断增长，但是在实际的系统中，它不会无限的增长下去。随着日志的不断增长，它会占据越来越多的空间并且花费更多的时间重置。如果没有一个机制使得它能够废弃在日志中不断累积的过时的信息就会引起可用性问题。</p><p>快照（snapshot）是最简单的压缩方式。在快照中，全部的当前系统状态都被写入到快照中，存储到持久化的存储中，然后在那个时刻之前的全部日志都可以被丢弃。在 Chubby 和 ZooKeeper 中都使用了快照技术，这一章的剩下的部分会介绍 Raft 中使用的快照技术。</p><p>增量压缩（incremental approaches）的方法，例如日志清理（log cleaning）或者日志结构合并树（log-structured merge trees），都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以使用和快照相同的接口来实现 LSM tree ，但是日志清除方法就需要修改 Raft 了。</p><p><br><br></p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fccdvbs2y7j20g70ae75i.jpg" alt=""></p><center>图-12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。</center><p><br><br></p><p>图-12 展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也将一些少量的元数据包含到快照中：最后被包含的索引（last included index）指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），最后被包含的任期（last included term）指的是该条目的任期号。保留这些数据是为了支持快照前的第一个条目的附加日志请求时的一致性检查，因为这个条目需要最后的索引值和任期号。为了支持集群成员更新（第 6 章），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</p><p>尽管通常服务器都是独立的创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 章）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给它们。</p><p><strong> 安装快照 RPC（InstallSnapshot RPC）</strong></p><p>在领导人发送快照给跟随者时使用调用。领导人总是按顺序发送。</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">term</td><td style="text-align:center">领导人的任期</td></tr><tr><td style="text-align:center">leaderId</td><td style="text-align:center">为了追随者能重定向到客户端</td></tr><tr><td style="text-align:center">lastIncludedIndex</td><td style="text-align:center">快照中包含的最后日志条目的索引值</td></tr><tr><td style="text-align:center">lastIncludedTerm</td><td style="text-align:center">快照中包含的最后日志条目的任期号</td></tr><tr><td style="text-align:center">offset</td><td style="text-align:center">分块在快照中的偏移量</td></tr><tr><td style="text-align:center">data[]</td><td style="text-align:center">快照块的原始数据</td></tr><tr><td style="text-align:center">done</td><td style="text-align:center">如果是最后一块数据则为真</td></tr></tbody></table><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">term</td><td style="text-align:center">currentTerm，用于领导人更新自己</td></tr></tbody></table><p>接受者需要实现：</p><ol><li>如果<code>term &lt; currentTerm</code>立刻回复</li><li>如果是第一个分块（offset 为 0）则创建新的快照</li><li>在指定的偏移量写入数据</li><li>如果 <code>done</code>为 false，则回复并继续等待之后的数据</li><li>保存快照文件，丢弃所有存在的或者部分有着更小索引号的快照</li><li>如果现存的日志拥有相同的最后任期号和索引值，则后面的数据继续保留并且回复</li><li>丢弃全部日志</li><li>能够使用快照来恢复状态机（并且装载快照中的集群配置）</li></ol><center>表-13：InstallSnapshot RPC 的总结。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生存的信号，所以跟随者可以重置选举超时计时器。</center><p><br><br></p><p>在这种情况下领导人使用一种叫做安装快照（InstallSnapshot）的新的 RPC 来发送快照给太落后的跟随者；见 表-13。当跟随者通过这种 RPC 接收到快照时，它必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者直接丢弃它所有的日志；这些会被快照所取代，但是可能会和没有提交的日志产生冲突。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照之后的条目必须是正确的和并且被保留下来。</p><p>这种快照的方式背离了 Raft 的强领导人原则（strong leader principle），因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织它们的数据了。</p><p>我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</p><p>还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，它就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</p><p>第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制（copy-on-write）的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</p><p>#8 客户端交互</p><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端是如何发现领导人的和 Raft 是如何支持线性化语义（linearizable semantics）的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><p>Raft 中的客户端将所有请求发送给领导人。当客户端启动的时候，它会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供它最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p><p>我们 Raft 的目标是要实现线性化语义（linearizable semantics）（每一次操作立即执行，在它调用和收到回复之间只执行一次）。但是，如上述所说，Raft 是可以多次执行同一条命令的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>只读（read-only）的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回过期数据(stale data)的风险，因为领导人响应客户端请求时可能已经被新的领导人作废了，但是它还不知道。线性化的读操作必须不能返回过期数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全原则（Leader Completeness Property）保证了领导人一定拥有所有已经被提交的日志条目，但是在它任期开始的时候，它可能不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来进行实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废除了（如果一个更新的领导人被选举出来，它自己的信息就已经过期了）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳（heartbeat）信息来处理这个问题。另外，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时序来保证安全性（它假设时间误差是有界的）。</p><p>#9 实现和评价</p><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p><p>这一章会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p><p>##9.1 可理解性</p><p>为了比较 Paxos 和 Raft 算法的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文除了日志压缩之外的所有内容；Paxos 课程包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者独立的区别从第一个算法处学来的经验。我们计算参加人员的每一个小测验的得分来看参与者是否对 Raft 的理解更好。</p><table><thead><tr><th style="text-align:center">因素</th><th style="text-align:center">消除偏见的手段</th><th style="text-align:center">复习材料</th></tr></thead><tbody><tr><td style="text-align:center">相同的讲课质量</td><td style="text-align:center">使用相同的讲师。Paxos 的讲义是基于之前在几所大学中使用的材料的并且做了改进。Paxos 的讲义要长 14%</td><td style="text-align:center">视频</td></tr><tr><td style="text-align:center">相同的测试难度</td><td style="text-align:center">用难度给问题分组，在测试中成对出现</td><td style="text-align:center">测验</td></tr><tr><td style="text-align:center">公平的打分</td><td style="text-align:center">使用红字标题。随机顺序打分，两个测验交替进行。</td><td style="text-align:center">红字标题</td></tr></tbody></table><center> 表-1：考虑到的可能造成偏见的因素，以及解决方案和对应的复习材料</center><p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些 Paxos 的经验，并且 Paxos 的视频要长 14%。如表-1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p><p><br><br></p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1fccg1gulewj20dy0cjjsf.jpg" alt=""></p><center>图-14：表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩的散点图。在对角线之上的点表示在 Raft 获得了更高分数的学生。</center><p><br><br></p><p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图-14 展示了每个参与者的得分。一对 t -测试表明，拥有 95% 的可信度，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型显示，对小测验的选择会产生 12.5 分的差别在对 Raft 的好感度上。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft 的小测验得分会比 Paxos 低 6.3 分；我们不知道为什么，但这在统计学上是这样的。<br><br><br></p><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fccg5giieaj20io082wfk.jpg" alt=""></p><center>图-15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。</center><p><br><br></p><p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图-15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p><p>关于 Raft 用户学习有一个更加详细的讨论，详见<a href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">http://ramcloud.stanford.edu/ ̃ongaro/thesis.pdf</a></p><p>##9.2 正确性</p><p>在第5章，我们已经进行了一个<a href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">正式的说明</a>，和对一致性机制的安全性证明。这个正式说明通过 <a href="https://www.amazon.com/Specifying-Systems-Language-Hardware-Engineers/dp/032114306X" target="_blank" rel="noopener">TLA+</a> 让 表-2 中的信息非常清晰。它大约有 400 行并且充当了证明的主题。同时对于任何想实现的人也是十分有用的。我们非常机械的通过 TLA 证明系统证明了日志完全特性（Log Completeness Property）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明这个说明中的类型安全 type safety）。而且，我们已经写了一个<a href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">非正式的证明</a>关于状态机安全性质是完备的，并且是相当清晰的（大约 3500 个词）。</p><p>##9.3 性能</p><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答以下两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？<br><br><br></p><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1fccglcmgnjj20i20gc0vq.jpg" alt=""></p><p><center>图-16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。</center><br><br><br></p><p>为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图-16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p><p>图-16 上面的图表表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程由于太多的选票瓜分的情况往往都需要花费超过 10 秒钟。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p><p>图-16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。</p><p>#10 相关工作</p><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p><ul><li>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰的论文。</li><li>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。</li><li>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 有着很大的差别。</li><li>Paxos 可以应用的性能优化。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p><p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 中不同的消息类型，相对的，Raft 只有 4 中消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p><p>Raft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p><p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致（joint consensus）的方法因为它对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Raft 没有采用 Lamport 的基于 α 的方法是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较而言，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。和 VR、SMART 比较而言，Raft 的方法同时需要更少的额外机制来实现。</p><p>#11 总结</p><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p><p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；这个过程是我们发现我们最终很少有技术上的重复，例如问题分解和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p><p>#12 鸣谢</p><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie res，和伯克利 CS 294-91 课程、斯坦福 CS 240 课程的学生。Scott Klemmer 帮我们设计了用户调查，Nelson Ray 建议我们进行统计学的分析。在用户调查时使用的关于 Paxos 的幻灯片很大一部分是从 Lorenzo Alvisi 的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 Ezra Hoch，他们找到了 Raft 中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括 Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，Arjun Gopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，Aleksandar Kracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，David Ramos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，Deian Stefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，Matei Zaharia 以及 24 位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 Eddie Kohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft 带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale 系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由 STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA 支持，在国家科学基金会的 0963859 号批准，并且获得了来自 Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。Diego Ongaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><p>#引用</p><ol><li>BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., AND LI, P. Paxos replicated state machines as the basis of a high-performance data store. In Proc. NSDI’11, USENIX Conference on Networked Systems Design and Implementation (2011), USENIX, pp. 141–154.</li><li>BURROWS, M. The Chubby lock service for loosely- coupled distributed systems. In Proc. OSDI’06, Sympo- sium on Operating Systems Design and Implementation (2006), USENIX, pp. 335–350.</li><li>CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. Multicoordinated Paxos. In Proc. PODC’07, ACM Sym- posium on Principles of Distributed Computing (2007), ACM, pp. 316–317.</li><li>CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live: an engineering perspective. In Proc. PODC’07, ACM Symposium on Principles of Distributed Computing (2007), ACM, pp. 398–407.</li><li>CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A., BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: a distributed storage system for structured data. In Proc. OSDI’06, USENIX Symposium on Operating Systems Design and Implementation (2006), USENIX, pp. 205–218.</li><li>CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C., FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P., HSIEH, W., KAN- THAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S., MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y., SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’s globally-distributed database. In Proc. OSDI’12, USENIX Conference on Operating Systems Design and Implemen- tation (2012), USENIX, pp. 251–264.</li><li>COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D., AND VANZETTO, H. TLA+ proofs. In Proc. FM’12, Symposium on Formal Methods (2012), D. Giannakopoulou and D. Me ́ry, Eds., vol. 7436 of Lec- ture Notes in Computer Science, Springer, pp. 147–154.</li><li>GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google file system. In Proc. SOSP’03, ACM Symposium on Operating Systems Principles (2003), ACM, pp. 29–43.</li><li>GRAY,C.,ANDCHERITON,D.Leases:Anefficientfault- tolerant mechanism for distributed file cache consistency. In Proceedings of the 12th ACM Ssymposium on Operating Systems Principles (1989), pp. 202–210.</li><li>HERLIHY, M. P., AND WING, J. M. Linearizability: a correctness condition for concurrent objects. ACM Trans- actions on Programming Languages and Systems 12 (July 1990), 463–492.</li><li>HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B. ZooKeeper: wait-free coordination for internet-scale systems. In Proc ATC’10, USENIX Annual Technical Con- ference (2010), USENIX, pp. 145–158.</li><li>JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab: High-performance broadcast for primary-backup sys- tems. In Proc. DSN’11, IEEE/IFIP Int’l Conf. on Depend- able Systems &amp; Networks (2011), IEEE Computer Society, pp. 245–256.</li><li>KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep. CNDS-2008-2, Johns Hopkins University, 2008.</li><li>LAMPORT, L. Time, clocks, and the ordering of events in a distributed system. Commununications of the ACM 21, 7 (July 1978), 558–565.</li><li>LAMPORT, L. The part-time parliament. ACM Transac- tions on Computer Systems 16, 2 (May 1998), 133–169.</li><li>LAMPORT, L. Paxos made simple. ACM SIGACT News 32, 4 (Dec. 2001), 18–25.</li><li>LAMPORT, L. Specifying Systems, The TLA+ Language and Tools for Hardware and Software Engineers. Addison- Wesley, 2002.</li><li>LAMPORT, L. Generalized consensus and Paxos. Tech. Rep. MSR-TR-2005-33, Microsoft Research, 2005.</li><li>LAMPORT, L. Fast paxos. Distributed Computing 19, 2 (2006), 79–103.</li><li>LAMPSON, B. W. How to build a highly available system using consensus. In Distributed Algorithms, O. Baboaglu and K. Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</li><li>LAMPSON, B. W. The ABCD’s of Paxos. In Proc. PODC’01, ACM Symposium on Principles of Distributed Computing (2001), ACM, pp. 13–13.</li><li>LISKOV, B., AND COWLING, J. Viewstamped replica- tion revisited. Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.</li><li>LogCabin source code. logcabin/logcabin.</li><li>LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J. R., AND HOWELL, J. The SMART way to migrate replicated stateful services. In Proc. Eu- roSys’06, ACM SIGOPS/EuroSys European Conference on Computer Systems (2006), ACM, pp. 103–115.</li><li>MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: building efficient replicated state machines for WANs. In Proc. OSDI’08, USENIX Conference on Operating Systems Design and Implementation (2008), USENIX, pp. 369–384.</li><li>MAZIE` RES, D. Paxos made practical.<a href="http://www.scs.stanford.edu/~dm/home/papers/paxos.pdf" target="_blank" rel="noopener">http://www.scs.stanford.edu/~dm/home/papers/paxos.pdf</a> , Jan. 2007.</li><li>MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is more consensus in egalitarian parliaments. In Proc. SOSP’13, ACM Symposium on Operating System Principles (2013), ACM.</li><li>Raft user study. <a href="http://ramcloud.stanford.edu/~ongaro/userstudy/" target="_blank" rel="noopener">http://ramcloud.stanford.edu/~ongaro/userstudy/</a>.</li><li>OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A new primary copy method to support highly-available distributed systems. In Proc. PODC’88, ACM Symposium on Principles of Distributed Computing (1988), ACM, pp. 8–17.</li><li>O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. The log-structured merge-tree (LSM-tree). Acta Informat- ica 33, 4 (1996), 351–385.</li><li>ONGARO, D. Consensus: Bridging Theory and Practice. PhD thesis, Stanford University, 2014 (work in progress).<a href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">http://ramcloud.stanford.edu/~ongaro/thesis.pdf</a></li><li>ONGARO, D., AND OUSTERHOUT, J. In search of an understandable consensus algorithm. In Proc ATC’14, USENIX Annual Technical Conference (2014), USENIX.</li><li>OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C., LEVERICH, J., MAZIE`RES, D., MI- TRA, S., NARAYANAN, A., ONGARO, D., PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN, R. The case for RAMCloud. Com- munications of the ACM 54 (July 2011), 121–130.</li><li>Raft consensus algorithm website. <a href="http://raftconsensus.github.io" target="_blank" rel="noopener">http://raftconsensus.github.io</a>.</li><li>REED, B. Personal communications, May 17, 2013.</li><li>ROSENBLUM, M., AND OUSTERHOUT, J. K. The design and implementation of a log-structured file system. ACM Trans. Comput. Syst. 10 (February 1992), 26–52.</li><li>SCHNEIDER, F. B. Implementing fault-tolerant services using the state machine approach: a tutorial. ACM Com- puting Surveys 22, 4 (Dec. 1990), 299–319.</li><li>SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoop distributed file system. In Proc. MSST’10, Symposium on Mass Storage Sys- tems and Technologies (2010), IEEE Computer Society, pp. 1–10.</li><li>VAN RENESSE, R. Paxos made moderately complex. Tech. rep., Cornell University, 2012.</li></ol><hr><blockquote><p>本文的版权归作者 <a href="http://www.luoyuanhang.com" target="_blank" rel="noopener">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/02/raft-paper-in-zh-CN/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《精进》短评&amp;书摘</title>
      <link>http://blog.luoyuanhang.com/2017/02/01/jingjin-reading-notes/</link>
      <guid>http://blog.luoyuanhang.com/2017/02/01/jingjin-reading-notes/</guid>
      <pubDate>Wed, 01 Feb 2017 02:04:33 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;《&lt;a href=&quot;https://www.amazon.cn/dp/B01GDK26FW/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1485912723&amp;amp;sr=1-1&amp;amp;keywords=%E7%B2%BE%E8%BF%9B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;精进：如何成为一个很厉害的人&lt;/a&gt;》是一本自我管理类的书籍，作者提出了一种提升自我的方式：用持续精确的努力，来不断进步，逐渐提升自我，这就是精进。在看过这本书之后对于作者提出的一些概念十分惊喜，并且表示赞同；但是对于有些观点不敢苟同。毕竟自我管理这样的书籍，不论作者提出了多么独到的观点，如果比应用于个人的实践中去的话，都是纸上谈兵。以下是我读书时整理的一些书摘，并且整理出了一些书中提到的概念。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>《<a href="https://www.amazon.cn/dp/B01GDK26FW/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1485912723&amp;sr=1-1&amp;keywords=%E7%B2%BE%E8%BF%9B" target="_blank" rel="noopener">精进：如何成为一个很厉害的人</a>》是一本自我管理类的书籍，作者提出了一种提升自我的方式：用持续精确的努力，来不断进步，逐渐提升自我，这就是精进。在看过这本书之后对于作者提出的一些概念十分惊喜，并且表示赞同；但是对于有些观点不敢苟同。毕竟自我管理这样的书籍，不论作者提出了多么独到的观点，如果比应用于个人的实践中去的话，都是纸上谈兵。以下是我读书时整理的一些书摘，并且整理出了一些书中提到的概念。</p></blockquote><a id="more"></a><h2 id="概念索引"><a href="#概念索引" class="headerlink" title="概念索引"></a>概念索引</h2><ul><li>变构学习模型（24）</li><li>必要难度（32）</li><li>常规型专长（22）</li><li>沉没成本谬误（18）</li><li>产品（16）</li><li>多线程工作（20）</li><li>混乱（27）</li><li>侯世达定律（10）</li><li>近期未来（5）</li><li>精益创业（15）</li><li>矩阵方法（28）</li><li>帕金森第一定律（9）</li><li>求知（25）</li><li>社会认同陷阱（39）</li><li>收益半衰期（6）</li><li>适应性专长（22）</li><li>收益值（6）</li><li>心智独特性（38）</li><li>远期未来（5）</li><li>自我决定论（34）</li><li>最小化可行产品（15）</li></ul><h2 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h2><ol><li>我们总是在惯性中生活，在教导下学习，在成规中思考，在劝解中决定，并在无助的结果中自责。我们着实需要一种智识和能力，去观察、反思自己被局限的生活，去发现和实践更多成长和成才的路径。</li><li>郑重是这样一种态度:不敷衍、不迟疑、不摇摆，认真地聚焦于当下的事情，自觉而专注地投入；郑重是这样一种态度:因恪守本心而知事情轻重缓急，因尽全力无保留而使其事竟成、光阴未曾虚度。</li><li>根据不同的时间视角可以划分出五种人:<ul><li>第一种是积极过去视角</li><li>第二种是消极过去视角</li><li>第三种是享乐主义视角</li><li>第四种是以宿命的观点看待当下的人，即具有宿命论视角</li><li>第五种是习惯往前看、为未来谋划的人，这种视角被称为未来视角</li></ul></li><li>更好对待时间的十条建议：<ul><li>生活在当下——不瞻前顾后，不左顾右盼，不患得患失;</li><li>严肃地对待时间——审慎、郑重地思考时间对我们的价值并用好它;</li><li>留意自己拥有的空间 并享受它——找到自己的“独享时刻”，不要疲于奔命;</li><li>反思自己和其他人的时间视角——认识到自己和他人时间视角的异同，换位思考;</li><li>从现在出发联结过去——过去并没有远去，它对今天仍具有意义;</li><li>并不完全沉浸于过去——比过去更重要的是现在;</li><li>制订实现目标的计划——未来视角让我们的行动更加有序;</li><li>平衡计划和非计划时间——由于随机性和不可预见因素的影响，我们的生活并不能完全被计划，平衡计划和非计划就是在未来视角和现在视角之间找到 平衡点;</li><li>视未来存在于当下——未来并非遥不可及，它就出现在即将到来的每一分每一秒;</li><li>对未来保持积极的态度——既然未来难以预测，那么以 积极的心态面对它能让我们在当下更有行动力。</li></ul></li><li>要想处理好“远期未来”和“近期未来”，我们可以采用下面两个策略:<ul><li>使远期未来的目标更加具体化、情境化和可实施;</li><li>降低近期未来中的“非期望行为 ”的便利性，主动增加挑战的难度。</li></ul></li><li>在分析一件事情值不值得去做、花多少精力去做的时候，可以从两个角度来评估:一是这件事在当下将给“我”带来的收益大小，这个收益可以是心智、情感层面的，也可以是身体、物质层面的，我称之为“收益值”;二是这项收益随时间衰减的速度，我称之为“收益半衰期”，半衰期长的事件，其影响会持续较久。</li><li>现代社会的快节奏、碎片化和功利性等特点，使得现代人很容易陷入“两个无能”之中，一是“选择无能”，二是“执行无能”</li><li>辨认“信息噪音”有一个立竿见影的方法，就是调整评估信息价值的时间尺度。</li><li>帕金森第一定律:工作会自动膨胀，直至占满所有可用的时间。</li><li>侯世达定律:“实际做事花费的时间总是比预期的要长，即使预期中考虑了侯世达定律。”</li><li>仅仅是好的选择是不够的，我们需要的是最好的选择。</li><li>说到“格局为何”，电影《一代宗师》已经做了很好的回答，即“看自己、看天地、看众生”。</li><li>开始并完成一件事情，比做好它更重要。</li><li>种一棵树最好的时间是十年前，其次是现在。即刻行动应该是我们最重要的一条行动法则。</li><li>“精益创业”(Lean Startup)是当前互联网创业最流行的方法之一。“精益创业”中有个关键概念叫 “最小化可行产品”(minimum viable product，MVP)，它指的是可以使用最少资源、被最快制作出来的、可执行基本功能的、能被用户使用的试验性产品，创业者应该尽快把最小化可行产品 发布出去，然后根据用户使用它的反馈来进行优化，这一过程称为“构建—测量—学习”(Build-Measure-Learn)的循环。</li><li>那么，对一个个体来讲，他的最小化可行产品是什么呢? 回答这个问题就要搞清楚“产品”这个概念的内涵:<ul><li>1.“产品”不是过程，而是结果;</li><li>2.“产品”不是对 原料、素材的简单堆积，而是对它们结构性的整合和组织;</li><li>3.“产品”不是创制者锁在自己保险箱里的东西，而要能被其他人使用和检验;</li><li>4.“产品”能独立对世界产生影响，它应该能创造出正向的价值，使人受益;</li><li>5.“产品”也是一种媒介。</li></ul></li><li>法国作家莫里哀说:“我们越是爱自己的朋友，就越是会批评他们。”</li><li>产品迭代需要推倒重来的勇气，这并不容易，因为人们总是留恋自己已经付出的努力，而不管这些曾经的努力对未来是否已经失去了价值，这也称为“沉没成本谬误”。</li><li>所以以精益创业的方式去走向人生的成功，便要做到这三点:<ul><li>克服“过度准备”的惯性，向前一步，把未完成的事情完成;</li><li>克服“自我防卫”的心态，乐于接受反面意见并加以慎重地审视;</li><li>克服“沉没成本”的固执，有勇气否定并重新构造自己的产品。</li></ul></li><li>多线程工作，首先需要一段专注不受干扰的时间，完成工作中最核心部分的思考。</li><li>只有最后能够作用于现实的学习，才是唯一有效的学习。</li><li>教育心理学家把在某一领域有专长的人士，分为“常规型专长”(routing expertise)和“适应型专长”(adaptive expertise)两类，其中具有常规型专长的人 具有一个基本固定的知识系统，可以以很高的效率把他们所接触到的信息材料按照已有的框架进行分析，而具有适应型专长的人则可以让自己的能力不断地“进化”，通过对知识的广度和深度的扩展来适应问题解决的需要。</li><li>学习应该是深度和广度的结合。广度能够让人不闭塞，深度能够让人不只是学之皮毛。</li><li>“变构学习模型”(allosteric learning model):“构成学习者思维独特性的并非是他所录入的观点序列，而是他有能力启动和调用的关联。”</li><li>求知分为三个层级:信息、知识和技能。技能是学习的终点，信息和知识是迈向这个终点的路与桥。</li><li>学会有意识地去分析不同领域知识之间的潜在关联，通过不同知识的迁移、印证、互补，获得启发，甚至生成新的思想或者发现。</li><li>混乱是秩序的另一种形式。通过混乱颠覆固有的、模式化的思维习惯，最终构建出新的秩序。</li><li>使用矩阵方法，我们可以采用如下三个步骤:<ul><li>抽象出尽可能完整的分解问题的维度(比如产品的最终形态无法穷举，但是决定产品形态的抽象维度可以 穷举);</li><li>对每一维度，通过取反、细分等操作，找出尽可能多的表现值，以构成维度矩阵;</li><li>在维度矩阵中不同维度的表现值之间尝试建立各种组合。</li></ul></li><li>努力不是一场意志力的较量，而是一种需要学习的策略。</li><li>专心做好一件事，哪怕这件事看上去极不起眼。三心二意、畏葸不前、瞻前顾后、贪多求快、跟风冒进都是大忌。</li><li>胡适说，不苟且就是“狷介”。胡适认为，狷介不仅是一种德行，也是一种做学问的品格，也就是“一丝一毫不草率不苟且的工作习惯”。</li><li>一条重要的提升学习效果的原则，叫“必要难度”(desirable difficulties)，通俗点讲，就是学习的时候，要给自己增加一些难度，这对提升学习效果是非常必要的。</li><li>人总是喜欢轻易地作评判、下定论、贴标签，用过于简单的概括来代替细致深入的观察。</li><li>当代心理学中有一个著名的理论叫“自我决定论”，说人有三种基本的心理需要，分别是自主的需要(autonomy)、能力的需要(competence)和归属的需要(relatedness)，如果这些需要得到了满足，那么人就会更加主动、积极和愉快地工作和学习。</li><li>在新思想或新技术刚刚开始兴起无人问津之时就投入进去，成为某一个新知识领域的先驱，实现知识能力的“低买高卖”。</li><li>如何求解现实问题?<ul><li>1.正确地认识问题，而不是简单地使用别人的问题表述。</li><li>2.对问题进行完全独立的思考，不借助书本和搜索引擎，因为你面前的问题是独一无二的、全新的。</li><li>3.继续独立地思考，但是你可以在希望比较大的求解方向下，有针对性地寻找相关联的知识，此时你需要快速筛选和学习新知识，甚至需要不带偏见的、 尽可能多地寻找各种可能有益的知识，也包括与他人交流意见。</li><li>4.在结合知识以分析问题的过程中，你可能会试着提出一些假设性的理论或者模型。</li><li>5.你提出的理论必定需要修正，这时你可以用你的理论去尝试解决问题，也可以试用于各种扩展情境，如果发现其bug就立即修正。</li><li>6.但由于理论毕竟是对现实的抽象，所以你还需要去关注各种细节性的问题，去通盘考虑现实情况，去穷尽和评估各种因素。</li></ul></li><li>在现实世界中思考理论问题，在理论世界中思考现实问题。</li><li>具有心智独特性的人所具有的优势:<ul><li>在主流观点之外洞察出别人未曾发现的机会;</li><li>形成个人核心竞争力，避免低层次的同质化竞争，使自己不可替代 ;</li><li>拒绝他人和大众给自己贴上的标签，以更开放和自由的心态发展自己;</li><li>因为不必迎合社会主流而节约了大量时间精力，可以专注于做好自己的事情;</li><li>为大众带来新鲜的见解和启发，形成对公众的影响力;</li><li>具有更高的可 辨识性，更易于形成个人品牌;</li><li>吸引到其他独特而优秀的人，与他们成为朋友或者合作伙伴。</li></ul></li><li>当我们避开了追求社会认同的陷阱，也意识到去做酷事的价值以后，我们可能便走上了因独特而成功的道路。在这条道路上，下面七个方法能够助我们一 臂之力:<ul><li>1.抗拒自己的欲望，或者延迟满足欲望;</li><li>2.质疑貌似最可信的言论，不盲从任何人;</li><li>3.屏蔽流行信息，或者只在固定的时段接收流行信息;</li><li>4.思考最不可能的事，为其发展出可能性;</li><li>5.保留和发展自己的“怪癖”，并将其发展成自己的竞争力;</li><li>6.为小事物狂热，并在小事物中发现大世界;</li><li>7.开展思想试验和行动试验，让思想和行动相互激发。</li></ul></li></ol><hr><blockquote><p>本文的版权归作者 <a href="http://www.luoyuanhang.com" target="_blank" rel="noopener">罗远航</a> 所有，采用 <a href="http://creativecommons.org/licenses/by-nc/3.0/" target="_blank" rel="noopener">Attribution-NonCommercial 3.0 License</a>。任何人可以进行转载、分享，但不可在未经允许的情况下用于商业用途；转载请注明出处。感谢配合！</p></blockquote>]]></content:encoded>
      
      <comments>http://blog.luoyuanhang.com/2017/02/01/jingjin-reading-notes/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
